<!DOCTYPE HTML>
<html lang="zh_TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Embedded Rust Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script type="text/javascript" src="ltd-provenance.js"></script>
        <script type="text/javascript" src="ltd-current.js"></script>
        <script type="text/javascript" src="../../ltd-config.js"></script>
        <script type="text/javascript" src="../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-1ff81d97.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-fa1d9b19.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Embedded Rust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-embedded/book" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="ä»‹ç´¹"><a class="header" href="#ä»‹ç´¹">ä»‹ç´¹</a></h1>
<p>æ­¡è¿ä¾†åˆ°ã€ŠåµŒå…¥å¼ Rust æ‰‹å†Šã€‹ï¼šä¸€æœ¬ä»‹ç´¹å¦‚ä½•åœ¨ã€Œè£¸æ©Ÿã€åµŒå…¥å¼ç³»çµ±ï¼ˆå¦‚å¾®æ§åˆ¶å™¨ï¼‰ä¸Šä½¿ç”¨ Rust ç¨‹å¼èªè¨€çš„å…¥é–€æ›¸ã€‚</p>
<h2 id="åµŒå…¥å¼-rust-çš„é©ç”¨å°è±¡"><a class="header" href="#åµŒå…¥å¼-rust-çš„é©ç”¨å°è±¡">åµŒå…¥å¼ Rust çš„é©ç”¨å°è±¡</a></h2>
<p>åµŒå…¥å¼ Rust é©åˆæƒ³é€²è¡ŒåµŒå…¥å¼é–‹ç™¼ã€åŒæ™‚äº«å— Rust èªè¨€æä¾›çš„é«˜éšæ¦‚å¿µèˆ‡å®‰å…¨ä¿è­‰çš„äººã€‚ï¼ˆå¦è¦‹ <a href="https://doc.rust-lang.org/book/ch00-00-introduction.html">Rust çš„é©ç”¨å°è±¡</a>ï¼‰</p>
<h2 id="ç¯„ç–‡"><a class="header" href="#ç¯„ç–‡">ç¯„ç–‡</a></h2>
<p>æœ¬æ›¸çš„ç›®æ¨™æ˜¯ï¼š</p>
<ul>
<li>
<p>è®“é–‹ç™¼è€…å¿«é€Ÿä¸Šæ‰‹åµŒå…¥å¼ Rust é–‹ç™¼ã€‚ä¾‹å¦‚ï¼šå¦‚ä½•è¨­å®šé–‹ç™¼ç’°å¢ƒã€‚</p>
</li>
<li>
<p>åˆ†äº«ä½¿ç”¨ Rust é€²è¡ŒåµŒå…¥å¼é–‹ç™¼çš„_ç•¶å‰_æœ€ä½³å¯¦å‹™ã€‚ä¾‹å¦‚ï¼šå¦‚ä½•å–„ç”¨ Rust èªè¨€ç‰¹æ€§ä¾†å¯«å‡ºæ›´æ­£ç¢ºçš„åµŒå…¥å¼è»Ÿé«”ã€‚</p>
</li>
<li>
<p>åœ¨æŸäº›æƒ…æ³ä¸‹ä½œç‚ºé£Ÿè­œã€‚ä¾‹å¦‚ï¼šå¦‚ä½•åœ¨å–®ä¸€å°ˆæ¡ˆä¸­æ··ç”¨ C èˆ‡ Rustï¼Ÿ</p>
</li>
</ul>
<p>æœ¬æ›¸åŠ›æ±‚é€šç”¨ï¼Œä½†ç‚ºäº†è®“è®€è€…èˆ‡ä½œè€…æ›´å®¹æ˜“ä¸Šæ‰‹ï¼Œæ‰€æœ‰ç¯„ä¾‹éƒ½æ¡ç”¨ ARM Cortex-M æ¶æ§‹ã€‚ä¸éï¼Œæœ¬æ›¸ä¸å‡è¨­è®€è€…ç†Ÿæ‚‰è©²æ¶æ§‹ï¼Œä¸¦åœ¨éœ€è¦æ™‚è§£é‡‹å…¶ç‰¹å®šç´°ç¯€ã€‚</p>
<h2 id="æœ¬æ›¸çš„è®€è€…"><a class="header" href="#æœ¬æ›¸çš„è®€è€…">æœ¬æ›¸çš„è®€è€…</a></h2>
<p>æœ¬æ›¸é¢å‘å…·å‚™åµŒå…¥å¼æˆ– Rust èƒŒæ™¯çš„äººï¼Œä½†æˆ‘å€‘ç›¸ä¿¡æ‰€æœ‰å°åµŒå…¥å¼ Rust æ„Ÿåˆ°å¥½å¥‡çš„äººéƒ½èƒ½å¾æœ¬æ›¸ä¸­æœ‰æ‰€æ”¶ç©«ã€‚è‹¥ä½ æ²’æœ‰ç›¸é—œå…ˆå‚™çŸ¥è­˜ï¼Œæˆ‘å€‘å»ºè­°å…ˆé–±è®€ã€Œå‡è¨­èˆ‡å…ˆå‚™æ¢ä»¶ã€ç« ç¯€ä¸¦è£œè¶³ä¸è¶³ï¼Œè®“ä½ å¾æœ¬æ›¸ç²ç›Šæ›´å¤šä¸¦æå‡é–±è®€é«”é©—ã€‚ä½ ä¹Ÿå¯æŸ¥çœ‹ã€Œå…¶ä»–è³‡æºã€ç« ç¯€ï¼Œå°‹æ‰¾ä½ æƒ³è£œå……çš„ä¸»é¡Œã€‚</p>
<h3 id="å‡è¨­èˆ‡å…ˆå‚™æ¢ä»¶"><a class="header" href="#å‡è¨­èˆ‡å…ˆå‚™æ¢ä»¶">å‡è¨­èˆ‡å…ˆå‚™æ¢ä»¶</a></h3>
<ul>
<li>
<p>ä½ å·²èƒ½ç†Ÿç·´ä½¿ç”¨ Rust ç¨‹å¼èªè¨€ï¼Œä¸¦åœ¨æ¡Œé¢ç’°å¢ƒæ’°å¯«ã€åŸ·è¡Œèˆ‡é™¤éŒ¯ Rust æ‡‰ç”¨ç¨‹å¼ã€‚ä½ ä¹Ÿæ‡‰ç†Ÿæ‚‰ <a href="https://doc.rust-lang.org/edition-guide/">2018 edition</a> çš„æ…£ä¾‹ï¼Œå› ç‚ºæœ¬æ›¸ä»¥ Rust 2018 ç‚ºç›®æ¨™ã€‚</p>
</li>
<li>
<p>ä½ èƒ½ä»¥ Cã€C++ æˆ– Ada ç­‰å…¶ä»–èªè¨€é€²è¡ŒåµŒå…¥å¼ç³»çµ±é–‹ç™¼èˆ‡é™¤éŒ¯ï¼Œä¸¦ç†Ÿæ‚‰ä»¥ä¸‹æ¦‚å¿µï¼š</p>
<ul>
<li>äº¤å‰ç·¨è­¯</li>
<li>è¨˜æ†¶é«”å°æ˜ å‘¨é‚Š</li>
<li>ä¸­æ–·</li>
<li>I2Cã€SPIã€åºåˆ—åŸ ç­‰å¸¸è¦‹ä»‹é¢</li>
</ul>
</li>
</ul>
<h3 id="å…¶ä»–è³‡æº"><a class="header" href="#å…¶ä»–è³‡æº">å…¶ä»–è³‡æº</a></h3>
<p>å¦‚æœä½ å°ä¸Šè¿°å…§å®¹ä¸ç†Ÿæ‚‰ï¼Œæˆ–æƒ³äº†è§£æœ¬æ›¸æåŠçš„ç‰¹å®šä¸»é¡Œï¼Œä»¥ä¸‹è³‡æºå¯èƒ½æœƒæœ‰å¹«åŠ©ã€‚</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>è©±é¡Œ</th><th>è³‡æº</th><th>æè¿°</th></tr>
</thead>
<tbody>
<tr><td>Rust</td><td><a href="https://doc.rust-lang.org/book/">Rust æ‰‹å†Š</a></td><td>è‹¥ä½ å°šæœªç†Ÿæ‚‰ Rustï¼Œæˆ‘å€‘å¼·çƒˆå»ºè­°å…ˆé–±è®€æ­¤æ›¸ã€‚</td></tr>
<tr><td>Rustã€åµŒå…¥å¼</td><td><a href="https://docs.rust-embedded.org/discovery/">Discovery æ‰‹å†Š</a></td><td>è‹¥ä½ å¾æœªåšéåµŒå…¥å¼é–‹ç™¼ï¼Œé€™æœ¬æ›¸å¯èƒ½æ˜¯æ›´å¥½çš„èµ·é»</td></tr>
<tr><td>Rustã€åµŒå…¥å¼</td><td><a href="https://docs.rust-embedded.org">Embedded Rust Bookshelf</a></td><td>åœ¨é€™è£¡å¯ä»¥æ‰¾åˆ° Rust åµŒå…¥å¼å·¥ä½œç¾¤æä¾›çš„å…¶ä»–è³‡æºã€‚</td></tr>
<tr><td>Rustã€åµŒå…¥å¼</td><td><a href="https://docs.rust-embedded.org/embedonomicon/">Embedonomicon</a></td><td>ä½¿ç”¨ Rust é€²è¡ŒåµŒå…¥å¼é–‹ç™¼æ™‚çš„ç¹ç‘£ç´°ç¯€ã€‚</td></tr>
<tr><td>Rustã€åµŒå…¥å¼</td><td><a href="https://docs.rust-embedded.org/faq.html">åµŒå…¥å¼ FAQ</a></td><td>é—œæ–¼åµŒå…¥å¼æƒ…å¢ƒä¸­çš„ Rust å¸¸è¦‹å•é¡Œã€‚</td></tr>
<tr><td>Rustã€åµŒå…¥å¼</td><td><a href="https://google.github.io/comprehensive-rust/bare-metal.html">Comprehensive Rust ğŸ¦€ï¼šè£¸æ©Ÿ</a></td><td>è£¸æ©Ÿ Rust é–‹ç™¼ 1 æ—¥èª²ç¨‹çš„æ•™å­¸æ•™æ</td></tr>
<tr><td>ä¸­æ–·</td><td><a href="https://en.wikipedia.org/wiki/Interrupt">ä¸­æ–·</a></td><td>-</td></tr>
<tr><td>è¨˜æ†¶é«”å°æ˜  I/O/å‘¨é‚Š</td><td><a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">è¨˜æ†¶é«”å°æ˜  I/O</a></td><td>-</td></tr>
<tr><td>SPIã€UARTã€RS232ã€USBã€I2Cã€TTL</td><td><a href="https://electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-ttl-etc-what-are-all-of-these-and-how-do-th">é—œæ–¼ SPIã€UART èˆ‡å…¶ä»–ä»‹é¢çš„ Stack Exchange è¨è«–</a></td><td>-</td></tr>
</tbody>
</table>
</div>
<h3 id="ç¿»è­¯"><a class="header" href="#ç¿»è­¯">ç¿»è­¯</a></h3>
<p>æœ¬æ›¸ç”±ç†±å¿ƒå¿—å·¥ç¿»è­¯å®Œæˆã€‚è‹¥ä½ å¸Œæœ›ä½ çš„ç¿»è­¯åˆ—åœ¨æ­¤è™•ï¼Œè«‹é–‹ PR åŠ å…¥ã€‚</p>
<ul>
<li>
<p><a href="https://tomoyuki-nakabayashi.github.io/book/">æ—¥æ–‡</a>ï¼ˆ<a href="https://github.com/tomoyuki-nakabayashi/book">å„²å­˜åº«</a>ï¼‰</p>
</li>
<li>
<p><a href="https://xxchang.github.io/book/">ä¸­æ–‡</a>ï¼ˆ<a href="https://github.com/XxChang/book">å„²å­˜åº«</a>ï¼‰</p>
</li>
</ul>
<h2 id="å¦‚ä½•ä½¿ç”¨é€™æœ¬æ‰‹å†Š"><a class="header" href="#å¦‚ä½•ä½¿ç”¨é€™æœ¬æ‰‹å†Š">å¦‚ä½•ä½¿ç”¨é€™æœ¬æ‰‹å†Š</a></h2>
<p>è©²æ‰‹å†Šä¸€èˆ¬å‡è¨­ä½ å¾å‰å¾€å¾Œé–±è®€ã€‚å¾ŒçºŒç« ç¯€æœƒå»ºç«‹åœ¨å‰é¢ç« ç¯€çš„æ¦‚å¿µä¹‹ä¸Šï¼Œè€Œå‰é¢ç« ç¯€å¯èƒ½ä¸æœƒæ·±å…¥æŸäº›è©±é¡Œï¼Œä¸¦åœ¨å¾ŒçºŒç« ç¯€å†å›é ­è©³è¿°ã€‚</p>
<p>æœ¬æ›¸å¤šæ•¸ç¯„ä¾‹æœƒä½¿ç”¨ STMicroelectronics çš„ <a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a> é–‹ç™¼æ¿ã€‚æ­¤é–‹ç™¼æ¿åŸºæ–¼ ARM Cortex-M æ¶æ§‹ï¼Œé›–ç„¶æ­¤æ¶æ§‹çš„å¤šæ•¸ CPU åŸºæœ¬åŠŸèƒ½ç›¸åŒï¼Œä½†ä¸åŒå» å•†çš„å¾®æ§åˆ¶å™¨å‘¨é‚Šèˆ‡å…¶ä»–å¯¦ä½œç´°ç¯€å„ä¸ç›¸åŒï¼Œç”šè‡³åŒä¸€å» å•†ä¸åŒå®¶æ—ä¹Ÿå¯èƒ½ä¸åŒã€‚</p>
<p>å› æ­¤ï¼Œæˆ‘å€‘å»ºè­°è³¼è²· <a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a> é–‹ç™¼æ¿ä¾†è·Ÿè‘—æœ¬æ›¸ç¯„ä¾‹æ“ä½œã€‚</p>
<h2 id="ç‚ºæœ¬æ›¸åšå‡ºè²¢ç»"><a class="header" href="#ç‚ºæœ¬æ›¸åšå‡ºè²¢ç»">ç‚ºæœ¬æ›¸åšå‡ºè²¢ç»</a></h2>
<p>æœ¬æ›¸çš„å·¥ä½œç”±<a href="https://github.com/rust-embedded/book">æ­¤å„²å­˜åº«</a> å”èª¿ï¼Œä¸»è¦ç”±<a href="https://github.com/rust-embedded/wg#the-resources-team">è³‡æºåœ˜éšŠ</a> é–‹ç™¼ã€‚</p>
<p>å¦‚æœä½ åœ¨è·Ÿè‘—æœ¬æ›¸æŒ‡å¼•æ™‚é‡åˆ°å›°é›£ï¼Œæˆ–ç™¼ç¾æŸäº›ç« ç¯€ä¸å¤ æ¸…æ¥šæˆ–é›£ä»¥ç†è§£ï¼Œé‚£å°±æ˜¯å•é¡Œï¼Œæ‡‰åœ¨æœ¬æ›¸çš„<a href="https://github.com/rust-embedded/book/issues/">è­°é¡Œè¿½è¹¤å™¨</a> å›å ±ã€‚</p>
<p>éå¸¸æ­¡è¿ä¿®æ­£éŒ¯å­—èˆ‡æ–°å¢å…§å®¹çš„ Pull Requestï¼</p>
<h2 id="é‡è¤‡ä½¿ç”¨æœ¬è³‡æ–™"><a class="header" href="#é‡è¤‡ä½¿ç”¨æœ¬è³‡æ–™">é‡è¤‡ä½¿ç”¨æœ¬è³‡æ–™</a></h2>
<p>æœ¬æ›¸ä»¥ä»¥ä¸‹æˆæ¬Šæ¢æ¬¾é‡‹å‡ºï¼š</p>
<ul>
<li>æœ¬æ›¸åŒ…å«çš„ç¨‹å¼ç¢¼ç¯„ä¾‹èˆ‡ç¨ç«‹çš„ Cargo å°ˆæ¡ˆåŒæ™‚æ¡ç”¨ <a href="https://opensource.org/licenses/MIT">MIT æˆæ¬Š</a> èˆ‡ <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License v2.0</a> æˆæ¬Šã€‚</li>
<li>æœ¬æ›¸çš„æ–‡å­—ã€åœ–ç‰‡èˆ‡åœ–è¡¨æ¡ç”¨ Creative Commons <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA v4.0</a> æˆæ¬Šã€‚</li>
</ul>
<p>TL;DRï¼šè‹¥ä½ æƒ³åœ¨ä½œå“ä¸­ä½¿ç”¨æˆ‘å€‘çš„æ–‡å­—æˆ–åœ–ç‰‡ï¼Œä½ éœ€è¦ï¼š</p>
<ul>
<li>çµ¦äºˆé©ç•¶çš„å¼•ç”¨ï¼ˆä¾‹å¦‚åœ¨æŠ•å½±ç‰‡ä¸­æåˆ°æœ¬æ›¸ï¼Œä¸¦æä¾›ç›¸é—œé é¢çš„é€£çµï¼‰</li>
<li>æä¾› <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA v4.0</a> æˆæ¬Šé€£çµ</li>
<li>èªªæ˜æ˜¯å¦å°ç´ æåšéä»»ä½•è®Šæ›´ï¼Œä¸¦å°‡ä½ å°ç´ æçš„ä¿®æ”¹ä»¥ç›¸åŒæˆæ¬Šé‡‹å‡º</li>
</ul>
<p>å¦‚æœä½ è¦ºå¾—æœ¬æ›¸æœ‰å¹«åŠ©ï¼Œä¹Ÿè«‹å‹™å¿…è®“æˆ‘å€‘çŸ¥é“ï¼</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="meet-your-hardware"><a class="header" href="#meet-your-hardware">Meet Your Hardware</a></h1>
<p>Letâ€™s get familiar with the hardware weâ€™ll be working with.</p>
<h2 id="stm32f3discovery-the-f3"><a class="header" href="#stm32f3discovery-the-f3">STM32F3DISCOVERY (the â€œF3â€)</a></h2>
<p align="center">
<img title="F3" src="assets/f3.jpg">
</p>

<p>What does this board contain?</p>
<ul>
<li>
<p>A <a href="https://www.st.com/en/microcontrollers/stm32f303vc.html">STM32F303VCT6</a> microcontroller. This microcontroller has</p>
<ul>
<li>
<p>A single-core ARM Cortex-M4F processor with hardware support for single-precision floating point operations and a maximum clock frequency of 72 MHz.</p>
</li>
<li>
<p>256 KiB of â€œFlashâ€ memory. (1 KiB = 10<strong>24</strong> bytes)</p>
</li>
<li>
<p>48 KiB of RAM.</p>
</li>
<li>
<p>A variety of integrated peripherals such as timers, I2C, SPI and USART.</p>
</li>
<li>
<p>General purpose Input Output (GPIO) and other types of pins accessible through the two rows of headers along side the board.</p>
</li>
<li>
<p>A USB interface accessible through the USB port labeled â€œUSB USERâ€.</p>
</li>
</ul>
</li>
<li>
<p>An <a href="https://en.wikipedia.org/wiki/Accelerometer">accelerometer</a> as part of the <a href="https://www.st.com/en/mems-and-sensors/lsm303dlhc.html">LSM303DLHC</a> chip.</p>
</li>
<li>
<p>A <a href="https://en.wikipedia.org/wiki/Magnetometer">magnetometer</a> as part of the <a href="https://www.st.com/en/mems-and-sensors/lsm303dlhc.html">LSM303DLHC</a> chip.</p>
</li>
<li>
<p>A <a href="https://en.wikipedia.org/wiki/Gyroscope">gyroscope</a> as part of the <a href="https://www.pololu.com/file/0J563/L3GD20.pdf">L3GD20</a> chip.</p>
</li>
<li>
<p>8 user LEDs arranged in the shape of a compass.</p>
</li>
<li>
<p>A second microcontroller: a <a href="https://www.st.com/en/microcontrollers/stm32f103cb.html">STM32F103</a>. This microcontroller is actually part of an on-board programmer / debugger and is connected to the USB port named â€œUSB ST-LINKâ€.</p>
</li>
</ul>
<p>For a more detailed list of features and further specifications of the board take a look at the <a href="https://www.st.com/en/evaluation-tools/stm32f3discovery.html">STMicroelectronics</a> website.</p>
<p>A word of caution: be careful if you want to apply external signals to the board. The microcontroller STM32F303VCT6 pins take a nominal voltage of 3.3 volts. For further information consult the <a href="https://www.st.com/resource/en/datasheet/stm32f303vc.pdf">6.2 Absolute maximum ratings section in the manual</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="no_std-rust-ç’°å¢ƒ"><a class="header" href="#no_std-rust-ç’°å¢ƒ"><code>no_std</code> Rust ç’°å¢ƒ</a></h1>
<p>The term Embedded Programming is used for a wide range of different classes of programming. Ranging from programming 8-Bit MCUs (like the <a href="https://www.st.com/resource/en/datasheet/st72325j6.pdf">ST72325xx</a>) with just a few KB of RAM and ROM, up to systems like the Raspberry Pi (<a href="https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications">Model B 3+</a>) which has a 32/64-bit 4-core Cortex-A53 @ 1.4 GHz and 1GB of RAM. Different restrictions/limitations will apply when writing code depending on what kind of target and use case you have.</p>
<p>There are two general Embedded Programming classifications:</p>
<h2 id="hosted-environments"><a class="header" href="#hosted-environments">Hosted Environments</a></h2>
<p>These kinds of environments are close to a normal PC environment. What this means is that you are provided with a System Interface <a href="https://en.wikipedia.org/wiki/POSIX">E.G. POSIX</a> that provides you with primitives to interact with various systems, such as file systems, networking, memory management, threads, etc. Standard libraries in turn usually depend on these primitives to implement their functionality. You may also have some sort of sysroot and restrictions on RAM/ROM-usage, and perhaps some special HW or I/Os. Overall it feels like coding on a special-purpose PC environment.</p>
<h2 id="bare-metal-environments"><a class="header" href="#bare-metal-environments">Bare Metal Environments</a></h2>
<p>In a bare metal environment no code has been loaded before your program. Without the software provided by an OS we can not load the standard library. Instead the program, along with the crates it uses, can only use the hardware (bare metal) to run. To prevent rust from loading the standard library use <code>no_std</code>. The platform-agnostic parts of the standard library are available through <a href="https://doc.rust-lang.org/core/">libcore</a>. libcore also excludes things which are not always desirable in an embedded environment. One of these things is a memory allocator for dynamic memory allocation. If you require this or any other functionalities there are often crates which provide these.</p>
<h3 id="the-libstd-runtime"><a class="header" href="#the-libstd-runtime">The libstd Runtime</a></h3>
<p>As mentioned before using <a href="https://doc.rust-lang.org/std/">libstd</a> requires some sort of system integration, but this is not only because <a href="https://doc.rust-lang.org/std/">libstd</a> is just providing a common way of accessing OS abstractions, it also provides a runtime. This runtime, among other things, takes care of setting up stack overflow protection, processing command line arguments, and spawning the main thread before a programâ€™s main function is invoked. This runtime also wonâ€™t be available in a <code>no_std</code> environment.</p>
<h2 id="æ‘˜è¦"><a class="header" href="#æ‘˜è¦">æ‘˜è¦</a></h2>
<p><code>#![no_std]</code> is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate. The <a href="https://doc.rust-lang.org/core/">libcore</a> crate in turn is a platform-agnostic subset of the std crate which makes no assumptions about the system the program will run on. As such, it provides APIs for language primitives like floats, strings and slices, as well as APIs that expose processor features like atomic operations and SIMD instructions. However it lacks APIs for anything that involves platform integration. Because of these properties no_std and <a href="https://doc.rust-lang.org/core/">libcore</a> code can be used for any kind of bootstrapping (stage 0) code like bootloaders, firmware or kernels.</p>
<h3 id="æ¦‚è¦½"><a class="header" href="#æ¦‚è¦½">æ¦‚è¦½</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>feature</th><th>no_std</th><th>std</th></tr>
</thead>
<tbody>
<tr><td>heap (dynamic memory)</td><td>*</td><td>âœ“</td></tr>
<tr><td>collections (Vec, BTreeMap, etc)</td><td>**</td><td>âœ“</td></tr>
<tr><td>stack overflow protection</td><td>âœ˜</td><td>âœ“</td></tr>
<tr><td>runs init code before main</td><td>âœ˜</td><td>âœ“</td></tr>
<tr><td>libstd available</td><td>âœ˜</td><td>âœ“</td></tr>
<tr><td>libcore available</td><td>âœ“</td><td>âœ“</td></tr>
<tr><td>writing firmware, kernel, or bootloader code</td><td>âœ“</td><td>âœ˜</td></tr>
</tbody>
</table>
</div>
<p>* Only if you use the <code>alloc</code> crate and use a suitable allocator like <a href="https://github.com/rust-embedded/alloc-cortex-m">alloc-cortex-m</a>.</p>
<p>** Only if you use the <code>collections</code> crate and configure a global default allocator.</p>
<p>** HashMap and HashSet are not available due to a lack of a secure random number generator.</p>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md">RFC-1184</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="å·¥å…·"><a class="header" href="#å·¥å…·">å·¥å…·</a></h1>
<p>Dealing with microcontrollers involves using several different tools as weâ€™ll be dealing with an architecture different than your laptopâ€™s and weâ€™ll have to run and debug programs on a <em>remote</em> device.</p>
<p>Weâ€™ll use all the tools listed below. Any recent version should work when a minimum version is not specified, but we have listed the versions we have tested.</p>
<ul>
<li>Rust 1.31, 1.31-beta, or a newer toolchain PLUS ARM Cortex-M compilation support.</li>
<li><a href="https://github.com/rust-embedded/cargo-binutils"><code>cargo-binutils</code></a> ~0.1.4</li>
<li><a href="https://www.qemu.org/"><code>qemu-system-arm</code></a>. Tested versions: 3.0.0</li>
<li>OpenOCD &gt;=0.8. Tested versions: v0.9.0 and v0.10.0</li>
<li>GDB with ARM support. Version 7.12 or newer highly recommended. Tested versions: 7.10, 7.11, 7.12 and 8.1</li>
<li><a href="https://github.com/ashleygwilliams/cargo-generate"><code>cargo-generate</code></a> or <code>git</code>. These tools are optional but will make it easier to follow along with the book.</li>
</ul>
<p>The text below explains why we are using these tools. Installation instructions can be found on the next page.</p>
<h2 id="cargo-generate-æˆ–-git"><a class="header" href="#cargo-generate-æˆ–-git"><code>cargo-generate</code> æˆ– <code>git</code></a></h2>
<p>Bare metal programs are non-standard (<code>no_std</code>) Rust programs that require some adjustments to the linking process in order to get the memory layout of the program right. This requires some additional files (like linker scripts) and settings (like linker flags). We have packaged those for you in a template such that you only need to fill in the missing information (such as the project name and the characteristics of your target hardware).</p>
<p>Our template is compatible with <code>cargo-generate</code>: a Cargo subcommand for creating new Cargo projects from templates. You can also download the template using <code>git</code>, <code>curl</code>, <code>wget</code>, or your web browser.</p>
<h2 id="cargo-binutils"><a class="header" href="#cargo-binutils"><code>cargo-binutils</code></a></h2>
<p><code>cargo-binutils</code> is a collection of Cargo subcommands that make it easy to use the LLVM tools that are shipped with the Rust toolchain. These tools include the LLVM versions of <code>objdump</code>, <code>nm</code> and <code>size</code> and are used for inspecting binaries.</p>
<p>The advantage of using these tools over GNU binutils is that (a) installing the LLVM tools is the same one-command installation (<code>rustup component add llvm-tools</code>) regardless of your OS and (b) tools like <code>objdump</code> support all the architectures that <code>rustc</code> supports â€“ from ARM to x86_64 â€“ because they both share the same LLVM backend.</p>
<h2 id="qemu-system-arm"><a class="header" href="#qemu-system-arm"><code>qemu-system-arm</code></a></h2>
<p>QEMU is an emulator. In this case we use the variant that can fully emulate ARM systems. We use QEMU to run embedded programs on the host. Thanks to this you can follow some parts of this book even if you donâ€™t have any hardware with you!</p>
<h1 id="tooling-for-embedded-rust-debugging"><a class="header" href="#tooling-for-embedded-rust-debugging">Tooling for Embedded Rust Debugging</a></h1>
<h2 id="æ¦‚è¦½-1"><a class="header" href="#æ¦‚è¦½-1">æ¦‚è¦½</a></h2>
<p>Debugging embedded systems in Rust requires specialized tools including software to manage the debugging process, debuggers to inspect and control program execution, and hardware probes to facilitate interaction between the host and the embedded device. This document outlines essential software tools like Probe-rs and OpenOCD, which simplify and support the debugging process, alongside prominent debuggers such as GDB and the Probe-rs Visual Studio Code extension. Additionally, it covers key hardware probes such as Rusty-probe, ST-Link, J-Link, and MCU-Link, which are integral for effective debugging and programming of embedded devices.</p>
<h2 id="é©…å‹•é™¤éŒ¯å·¥å…·çš„è»Ÿé«”"><a class="header" href="#é©…å‹•é™¤éŒ¯å·¥å…·çš„è»Ÿé«”">é©…å‹•é™¤éŒ¯å·¥å…·çš„è»Ÿé«”</a></h2>
<h3 id="probe-rs"><a class="header" href="#probe-rs">Probe-rs</a></h3>
<p>Probe-rs is a modern, Rust-focused software designed to work with debuggers in embedded systems. Unlike OpenOCD, Probe-rs is built with simplicity in mind and aims to reduce the configuration burden often found in other debugging solutions. It supports various probes and targets, providing a high-level interface for interacting with embedded hardware. Probe-rs integrates directly with Rust tooling, and integrates with Visual Studio Code through its extension, allowing developers to streamline their debugging workflow.</p>
<h3 id="openocd-open-on-chip-debugger"><a class="header" href="#openocd-open-on-chip-debugger">OpenOCD (Open On-Chip Debugger)</a></h3>
<p>OpenOCD is an open-source software tool used for debugging, testing, and programming embedded systems. It provides an interface between the host system and embedded hardware, supporting various transport layers like JTAG and SWD (Serial Wire Debug). OpenOCD integrates with GDB, which is a debugger. OpenOCD is widely supported, with extensive documentation and a large community, but may require complex configuration, especially for custom embedded setups.</p>
<h2 id="é™¤éŒ¯å™¨"><a class="header" href="#é™¤éŒ¯å™¨">é™¤éŒ¯å™¨</a></h2>
<p>A debugger allows developers to inspect and control the execution of a program in order to identify and correct errors or bugs. It provides functionalities such as setting breakpoints, stepping through code line by line, and examining the values of variables and memory states. Debuggers are essential for thorough software development and maintenance, enabling developers to ensure that their code behaves as intended under various conditions.</p>
<p>é™¤éŒ¯å™¨çŸ¥é“å¦‚ä½•ï¼š</p>
<ul>
<li>Interact with the memory mapped registers.</li>
<li>è¨­å®šä¸­æ–·é»/ç›£çœ‹é»ã€‚</li>
<li>Read and write to the memory mapped registers.</li>
<li>Detect when the MCU has been halted for a debug event.</li>
<li>Continue MCU execution after a debug event has been encountered.</li>
<li>Erase and write to the microcontrollerâ€™s FLASH.</li>
</ul>
<h3 id="probe-rs-visual-studio-code-extension"><a class="header" href="#probe-rs-visual-studio-code-extension">Probe-rs Visual Studio Code Extension</a></h3>
<p>Probe-rs has a Visual Studio Code extension, providing a seamless debugging experience without extensive setup. Through this connection, developers can use Rust-specific features like pretty printing and detailed error messages, ensuring that their debugging process aligns with the Rust ecosystem.</p>
<h3 id="gdb-gnu-debugger"><a class="header" href="#gdb-gnu-debugger">GDB (GNU Debugger)</a></h3>
<p>GDB is a versatile debugging tool that allows developers to examine the state of programs while they run or after they crash. For embedded Rust, GDB connects to the target system via OpenOCD or other debugging servers to interact with the embedded code. GDB is highly configurable and supports features like remote debugging, variable inspection, and conditional breakpoints. It can be used on a variety of platforms, and has extensive support for Rust-specific debugging needs, such as pretty printing and integration with IDEs.</p>
<h2 id="probes"><a class="header" href="#probes">Probes</a></h2>
<p>A hardware probe is a device used in the development and debugging of embedded systems to facilitate communication between a host computer and the target embedded device. It typically supports protocols like JTAG or SWD, enabling it to program, debug, and analyze the microcontroller or microprocessor on the embedded system. Hardware probes are crucial for developers to set breakpoints, step through code, and inspect memory and processor registers, effectively allowing them to diagnose and fix issues in real-time.</p>
<h3 id="rusty-probe"><a class="header" href="#rusty-probe">Rusty-probe</a></h3>
<p>Rusty-probe is an open-sourced USB-based hardware debugging probe designed to work with probe-rs. The combination of Rusty-Probe and probe-rs provides an easy-to-use, cost-effective solution for developers working with embedded Rust applications.</p>
<h3 id="st-link"><a class="header" href="#st-link">ST-Link</a></h3>
<p>The ST-Link is a popular debugging and programming probe developed by STMicroelectronics primarily for their STM32 and STM8 microcontroller series. It supports both debugging and programming via JTAG or SWD (Serial Wire Debug) interfaces. ST-Link is widely used due to its direct support from STMicroelectronicsâ€™ extensive range of development boards and its integration into major IDEs, making it a convenient choice for developers working with STM microcontrollers.</p>
<h3 id="j-link"><a class="header" href="#j-link">J-Link</a></h3>
<p>J-Link, developed by SEGGER Microcontroller, is a robust and versatile debugger supporting a wide range of CPU cores and devices beyond just ARM, such as RISC-V. Known for its high performance and reliability, J-Link supports various communication interfaces, including JTAG, SWD, and fine-pitch JTAG interfaces. It is favored for its advanced features like unlimited breakpoints in flash memory and its compatibility with a multitude of development environments.</p>
<h3 id="mcu-link"><a class="header" href="#mcu-link">MCU-Link</a></h3>
<p>MCU-Link is a debugging probe that also functions as a programmer, provided by NXP Semiconductors. It supports a variety of ARM Cortex microcontrollers and interfaces seamlessly with development tools like MCUXpresso IDE. MCU-Link is particularly notable for its versatility and affordability, making it an accessible option for hobbyists, educators, and professional developers alike.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="å®‰è£å·¥å…·"><a class="header" href="#å®‰è£å·¥å…·">å®‰è£å·¥å…·</a></h1>
<p>This page contains OS-agnostic installation instructions for a few of the tools:</p>
<h3 id="rust-å·¥å…·éˆ"><a class="header" href="#rust-å·¥å…·éˆ">Rust å·¥å…·éˆ</a></h3>
<p>Install rustup by following the instructions at <a href="https://rustup.rs">https://rustup.rs</a>.</p>
<p><strong>NOTE</strong> Make sure you have a compiler version equal to or newer than <code>1.31</code>. <code>rustc -V</code> should return a date newer than the one shown below.</p>
<pre><code class="language-text">$ rustc -V
rustc 1.31.1 (b6c32da9b 2018-12-18)
</code></pre>
<p>For bandwidth and disk usage concerns the default installation only supports native compilation. To add cross compilation support for the ARM Cortex-M architectures choose one of the following compilation targets. For the STM32F3DISCOVERY board used for the examples in this book, use the <code>thumbv7em-none-eabihf</code> target. <a href="https://developer.arm.com/ip-products/processors/cortex-m#c-7d3b69ce-5b17-4c9e-8f06-59b605713133">Find the best Cortex-M for you.</a></p>
<p>Cortex-M0, M0+, and M1 (ARMv6-M architecture):</p>
<pre><code class="language-console">rustup target add thumbv6m-none-eabi
</code></pre>
<p>Cortex-M3 (ARMv7-M architecture):</p>
<pre><code class="language-console">rustup target add thumbv7m-none-eabi
</code></pre>
<p>Cortex-M4 and M7 without hardware floating point (ARMv7E-M architecture):</p>
<pre><code class="language-console">rustup target add thumbv7em-none-eabi
</code></pre>
<p>Cortex-M4F and M7F with hardware floating point (ARMv7E-M architecture):</p>
<pre><code class="language-console">rustup target add thumbv7em-none-eabihf
</code></pre>
<p>Cortex-M23 (ARMv8-M architecture):</p>
<pre><code class="language-console">rustup target add thumbv8m.base-none-eabi
</code></pre>
<p>Cortex-M33 and M35P (ARMv8-M architecture):</p>
<pre><code class="language-console">rustup target add thumbv8m.main-none-eabi
</code></pre>
<p>Cortex-M33F and M35PF with hardware floating point (ARMv8-M architecture):</p>
<pre><code class="language-console">rustup target add thumbv8m.main-none-eabihf
</code></pre>
<h3 id="cargo-binutils-1"><a class="header" href="#cargo-binutils-1"><code>cargo-binutils</code></a></h3>
<pre><code class="language-text">cargo install cargo-binutils

rustup component add llvm-tools
</code></pre>
<p>WINDOWS: prerequisite C++ Build Tools for Visual Studio 2019 is installed. https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&amp;rel=16</p>
<h3 id="cargo-generate"><a class="header" href="#cargo-generate"><code>cargo-generate</code></a></h3>
<p>Weâ€™ll use this later to generate a project from a template.</p>
<pre><code class="language-console">cargo install cargo-generate
</code></pre>
<p>Note: on some Linux distros (e.g. Ubuntu) you may need to install the packages <code>libssl-dev</code> and <code>pkg-config</code> prior to installing cargo-generate.</p>
<h3 id="os-specific-instructions"><a class="header" href="#os-specific-instructions">OS-Specific Instructions</a></h3>
<p>Now follow the instructions specific to the OS you are using:</p>
<ul>
<li><a href="#linux">Linux</a></li>
<li><a href="#windows">Windows</a></li>
<li><a href="#macos">macOS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="linux"><a class="header" href="#linux">Linux</a></h1>
<p>Here are the installation commands for a few Linux distributions.</p>
<h2 id="è»Ÿé«”åŒ…"><a class="header" href="#è»Ÿé«”åŒ…">è»Ÿé«”åŒ…</a></h2>
<ul>
<li>Ubuntu 18.04 or newer / Debian stretch or newer</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> <code>gdb-multiarch</code> is the GDB command youâ€™ll use to debug your ARM Cortex-M programs</p>
</blockquote>
<!-- Debian stretch -->
<!-- GDB 7.12 -->
<!-- OpenOCD 0.9.0 -->
<!-- QEMU 2.8.1 -->
<!-- Ubuntu 18.04 -->
<!-- GDB 8.1 -->
<!-- OpenOCD 0.10.0 -->
<!-- QEMU 2.11.1 -->
<pre><code class="language-console">sudo apt install gdb-multiarch openocd qemu-system-arm
</code></pre>
<ul>
<li>Ubuntu 14.04 and 16.04</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> is the GDB command youâ€™ll use to debug your ARM Cortex-M programs</p>
</blockquote>
<!-- Ubuntu 14.04 -->
<!-- GDB 7.6 (!) -->
<!-- OpenOCD 0.7.0 (?) -->
<!-- QEMU 2.0.0 (?) -->
<pre><code class="language-console">sudo apt install gdb-arm-none-eabi openocd qemu-system-arm
</code></pre>
<ul>
<li>Fedora 27 or newer</li>
</ul>
<!-- Fedora 27 -->
<!-- GDB 7.6 (!) -->
<!-- OpenOCD 0.10.0 -->
<!-- QEMU 2.10.2 -->
<pre><code class="language-console">sudo dnf install gdb openocd qemu-system-arm
</code></pre>
<ul>
<li>Arch Linux</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> <code>arm-none-eabi-gdb</code> is the GDB command youâ€™ll use to debug ARM Cortex-M programs</p>
</blockquote>
<pre><code class="language-console">sudo pacman -S arm-none-eabi-gdb qemu-system-arm openocd
</code></pre>
<h2 id="udev-rules"><a class="header" href="#udev-rules">udev rules</a></h2>
<p>This rule lets you use OpenOCD with the Discovery board without root privilege.</p>
<p>Create the file <code>/etc/udev/rules.d/70-st-link.rules</code> with the contents shown below.</p>
<pre><code class="language-text"># STM32F3DISCOVERY rev A/B - ST-LINK/V2
ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3748", TAG+="uaccess"

# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1
ATTRS{idVendor}=="0483", ATTRS{idProduct}=="374b", TAG+="uaccess"
</code></pre>
<p>Then reload all the udev rules with:</p>
<pre><code class="language-console">sudo udevadm control --reload-rules
</code></pre>
<p>If you had the board plugged to your laptop, unplug it and then plug it again.</p>
<p>You can check the permissions by running this command:</p>
<pre><code class="language-console">lsusb
</code></pre>
<p>Which should show something like</p>
<pre><code class="language-text">(..)
Bus 001 Device 018: ID 0483:374b STMicroelectronics ST-LINK/V2.1
(..)
</code></pre>
<p>Take note of the bus and device numbers. Use those numbers to create a path like <code>/dev/bus/usb/&lt;bus&gt;/&lt;device&gt;</code>. Then use this path like so:</p>
<pre><code class="language-console">ls -l /dev/bus/usb/001/018
</code></pre>
<pre><code class="language-text">crw-------+ 1 root root 189, 17 Sep 13 12:34 /dev/bus/usb/001/018
</code></pre>
<pre><code class="language-console">getfacl /dev/bus/usb/001/018 | grep user
</code></pre>
<pre><code class="language-text">user::rw-
user:you:rw-
</code></pre>
<p>The <code>+</code> appended to permissions indicates the existence of an extended permission. The <code>getfacl</code> command tells the user <code>you</code> can make use of this device.</p>
<p>Now, go to the <a href="#é©—è­‰å®‰è£">next section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="macos"><a class="header" href="#macos">macOS</a></h1>
<p>All the tools can be installed using <a href="http://brew.sh/">Homebrew</a> or <a href="https://www.macports.org/">MacPorts</a>:</p>
<h2 id="install-tools-with-homebrew"><a class="header" href="#install-tools-with-homebrew">Install tools with <a href="http://brew.sh/">Homebrew</a></a></h2>
<pre><code class="language-text">$ # GDB
$ brew install arm-none-eabi-gdb

$ # OpenOCD
$ brew install openocd

$ # QEMU
$ brew install qemu
</code></pre>
<blockquote>
<p><strong>NOTE</strong> If OpenOCD crashes you may need to install the latest version using:</p>
</blockquote>
<pre><code class="language-text">$ brew install --HEAD openocd
</code></pre>
<h2 id="install-tools-with-macports"><a class="header" href="#install-tools-with-macports">Install tools with <a href="https://www.macports.org/">MacPorts</a></a></h2>
<pre><code class="language-text">$ # GDB
$ sudo port install arm-none-eabi-gcc

$ # OpenOCD
$ sudo port install openocd

$ # QEMU
$ sudo port install qemu
</code></pre>
<p>Thatâ€™s all! Go to the <a href="#é©—è­‰å®‰è£">next section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<h2 id="arm-none-eabi-gdb"><a class="header" href="#arm-none-eabi-gdb"><code>arm-none-eabi-gdb</code></a></h2>
<p>ARM provides <code>.exe</code> installers for Windows. Grab one from <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">here</a>, and follow the instructions. Just before the installation process finishes tick/select the â€œAdd path to environment variableâ€ option. Then verify that the tools are in your <code>%PATH%</code>:</p>
<pre><code class="language-text">$ arm-none-eabi-gdb -v
GNU gdb (GNU Tools for Arm Embedded Processors 7-2018-q2-update) 8.1.0.20180315-git
(..)
</code></pre>
<h2 id="openocd"><a class="header" href="#openocd">OpenOCD</a></h2>
<p>Thereâ€™s no official binary release of OpenOCD for Windows but if youâ€™re not in the mood to compile it yourself, the xPack project provides a binary distribution, <a href="https://xpack.github.io/openocd/">here</a>. Follow the provided installation instructions. Then update your <code>%PATH%</code> environment variable to include the path where the binaries were installed. (<code>C:\Users\USERNAME\AppData\Roaming\xPacks\@xpack-dev-tools\openocd\0.10.0-13.1\.content\bin\</code>, if youâ€™ve been using the easy install)</p>
<p>Verify that OpenOCD is in your <code>%PATH%</code> with:</p>
<pre><code class="language-text">$ openocd -v
Open On-Chip Debugger 0.10.0
(..)
</code></pre>
<h2 id="qemu"><a class="header" href="#qemu">QEMU</a></h2>
<p>Grab QEMU from <a href="https://www.qemu.org/download/#windows">the official website</a>.</p>
<h2 id="st-link-usb-driver"><a class="header" href="#st-link-usb-driver">ST-LINK USB driver</a></h2>
<p>Youâ€™ll also need to install <a href="http://www.st.com/en/embedded-software/stsw-link009.html">this USB driver</a> or OpenOCD wonâ€™t work. Follow the installer instructions and make sure you install the right version (32-bit or 64-bit) of the driver.</p>
<p>Thatâ€™s all! Go to the <a href="#é©—è­‰å®‰è£">next section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="é©—è­‰å®‰è£"><a class="header" href="#é©—è­‰å®‰è£">é©—è­‰å®‰è£</a></h1>
<p>In this section we check that some of the required tools / drivers have been correctly installed and configured.</p>
<p>Connect your laptop / PC to the discovery board using a Mini-USB USB cable. The discovery board has two USB connectors; use the one labeled â€œUSB ST-LINKâ€ that sits on the center of the edge of the board.</p>
<p>Also check that the ST-LINK header is populated. See the picture below; the ST-LINK header is highlighted.</p>
<p align="center">
<img title="Connected discovery board" src="assets/verify.jpeg">
</p>

<p>Now run the following command:</p>
<pre><code class="language-console">openocd -f interface/stlink.cfg -f target/stm32f3x.cfg
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: Old versions of openocd, including the 0.10.0 release from 2017, do not contain the new (and preferable) <code>interface/stlink.cfg</code> file; instead you may need to use <code>interface/stlink-v2.cfg</code> or <code>interface/stlink-v2-1.cfg</code>.</p>
</blockquote>
<p>You should get the following output and the program should block the console:</p>
<pre><code class="language-text">Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport "hla_swd". To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.919881
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<p>The contents may not match exactly but you should get the last line about breakpoints and watchpoints. If you got it then terminate the OpenOCD process and move to the <a href="#é–‹å§‹ä¸Šæ‰‹">next section</a>.</p>
<p>If you didnâ€™t get the â€œbreakpointsâ€ line then try one of the following commands.</p>
<pre><code class="language-console">openocd -f interface/stlink-v2.cfg -f target/stm32f3x.cfg
</code></pre>
<pre><code class="language-console">openocd -f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg
</code></pre>
<p>If one of those commands works it means you got an old hardware revision of the discovery board. That wonâ€™t be a problem but commit that fact to memory as youâ€™ll need to configure things a bit differently later on. You can move to the <a href="#é–‹å§‹ä¸Šæ‰‹">next section</a>.</p>
<p>If none of the commands work as a normal user then try to run them with root permission (e.g. <code>sudo openocd ..</code>). If the commands do work with root permission then check that the <a href="#udev-rules">udev rules</a> have been correctly set.</p>
<p>If you have reached this point and OpenOCD is not working please open <a href="https://github.com/rust-embedded/book/issues">an issue</a> and weâ€™ll help you out!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="é–‹å§‹ä¸Šæ‰‹"><a class="header" href="#é–‹å§‹ä¸Šæ‰‹">é–‹å§‹ä¸Šæ‰‹</a></h1>
<p>åœ¨æœ¬ç¯€ä¸­ï¼Œæˆ‘å€‘å°‡å¸¶ä½ èµ°éæ’°å¯«ã€å»ºç½®ã€ç‡’éŒ„èˆ‡é™¤éŒ¯åµŒå…¥å¼ç¨‹å¼çš„æµç¨‹ã€‚ä½ å¯ä»¥åœ¨ä¸éœ€ç‰¹æ®Šç¡¬é«”çš„æƒ…æ³ä¸‹å˜—è©¦å¤§å¤šæ•¸ç¯„ä¾‹ï¼Œå› ç‚ºæˆ‘å€‘æœƒä½¿ç”¨ QEMUï¼ˆå¸¸è¦‹çš„é–‹æºç¡¬é«”æ¨¡æ“¬å™¨ï¼‰å±•ç¤ºåŸºç¤ã€‚å”¯æœ‰<a href="#ç¡¬é«”">ç¡¬é«”</a>ç« ç¯€éœ€è¦å¯¦é«”ç¡¬é«”ï¼Œæˆ‘å€‘æœƒä½¿ç”¨ OpenOCD å° <a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a> é€²è¡Œç‡’éŒ„ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="qemu-1"><a class="header" href="#qemu-1">QEMU</a></h1>
<p>Weâ€™ll start writing a program for the <a href="http://www.ti.com/product/LM3S6965">LM3S6965</a>, a Cortex-M3 microcontroller. We have chosen this as our initial target because it <a href="https://wiki.qemu.org/Documentation/Platforms/ARM#Supported_in_qemu-system-arm">can be emulated</a> using QEMU so you donâ€™t need to fiddle with hardware in this section and we can focus on the tooling and the development process.</p>
<p><strong>IMPORTANT</strong> Weâ€™ll use the name â€œappâ€ for the project name in this tutorial. Whenever you see the word â€œappâ€ you should replace it with the name you selected for your project. Or, you could also name your project â€œappâ€ and avoid the substitutions.</p>
<h2 id="creating-a-non-standard-rust-program"><a class="header" href="#creating-a-non-standard-rust-program">Creating a non standard Rust program</a></h2>
<p>Weâ€™ll use the <a href="https://github.com/rust-embedded/cortex-m-quickstart"><code>cortex-m-quickstart</code></a> project template to generate a new project from it. The created project will contain a barebone application: a good starting point for a new embedded rust application. In addition, the project will contain an <code>examples</code> directory, with several separate applications, highlighting some of the key embedded rust functionality.</p>
<h3 id="ä½¿ç”¨-cargo-generate"><a class="header" href="#ä½¿ç”¨-cargo-generate">ä½¿ç”¨ <code>cargo-generate</code></a></h3>
<p>é¦–å…ˆå®‰è£ cargo-generate</p>
<pre><code class="language-console">cargo install cargo-generate
</code></pre>
<p>æ¥è‘—ç”Ÿæˆæ–°å°ˆæ¡ˆ</p>
<pre><code class="language-console">cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart
</code></pre>
<pre><code class="language-text"> Project Name: app
 Creating project called `app`...
 Done! New project created /tmp/app
</code></pre>
<pre><code class="language-console">cd app
</code></pre>
<h3 id="ä½¿ç”¨-git"><a class="header" href="#ä½¿ç”¨-git">ä½¿ç”¨ <code>git</code></a></h3>
<p>Clone the repository</p>
<pre><code class="language-console">git clone https://github.com/rust-embedded/cortex-m-quickstart app
cd app
</code></pre>
<p>And then fill in the placeholders in the <code>Cargo.toml</code> file</p>
<pre><code class="language-toml">[package]
authors = ["{{authors}}"] # "{{authors}}" -&gt; "John Smith"
edition = "2018"
name = "{{project-name}}" # "{{project-name}}" -&gt; "app"
version = "0.1.0"

# ..

[[bin]]
name = "{{project-name}}" # "{{project-name}}" -&gt; "app"
test = false
bench = false
</code></pre>
<h3 id="using-neither"><a class="header" href="#using-neither">Using neither</a></h3>
<p>Grab the latest snapshot of the <code>cortex-m-quickstart</code> template and extract it.</p>
<pre><code class="language-console">curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/master.zip
unzip master.zip
mv cortex-m-quickstart-master app
cd app
</code></pre>
<p>Or you can browse to <a href="https://github.com/rust-embedded/cortex-m-quickstart"><code>cortex-m-quickstart</code></a>, click the green â€œClone or downloadâ€ button and then click â€œDownload ZIPâ€.</p>
<p>Then fill in the placeholders in the <code>Cargo.toml</code> file as done in the second part of the â€œUsing <code>git</code>â€ version.</p>
<h2 id="program-overview"><a class="header" href="#program-overview">Program Overview</a></h2>
<p>For convenience here are the most important parts of the source code in <code>src/main.rs</code>:</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

use panic_halt as _;

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    loop {
        // your code goes here
    }
}</code></pre>
<p>This program is a bit different from a standard Rust program so letâ€™s take a closer look.</p>
<p><code>#![no_std]</code> indicates that this program will <em>not</em> link to the standard crate, <code>std</code>. Instead it will link to its subset: the <code>core</code> crate.</p>
<p><code>#![no_main]</code> indicates that this program wonâ€™t use the standard <code>main</code> interface that most Rust programs use. The main (no pun intended) reason to go with <code>no_main</code> is that using the <code>main</code> interface in <code>no_std</code> context requires nightly.</p>
<p><code>use panic_halt as _;</code>. This crate provides a <code>panic_handler</code> that defines the panicking behavior of the program. We will cover this in more detail in the <a href="#ææ…Œè™•ç†">Panicking</a> chapter of the book.</p>
<p><a href="https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.entry.html"><code>#[entry]</code></a> is an attribute provided by the <a href="https://crates.io/crates/cortex-m-rt"><code>cortex-m-rt</code></a> crate thatâ€™s used to mark the entry point of the program. As we are not using the standard <code>main</code> interface we need another way to indicate the entry point of the program and thatâ€™d be <code>#[entry]</code>.</p>
<p><code>fn main() -&gt; !</code>. Our program will be the <em>only</em> process running on the target hardware so we donâ€™t want it to end! We use a <a href="https://doc.rust-lang.org/rust-by-example/fn/diverging.html">divergent function</a> (the <code>-&gt; !</code> bit in the function signature) to ensure at compile time thatâ€™ll be the case.</p>
<h2 id="äº¤å‰ç·¨è­¯"><a class="header" href="#äº¤å‰ç·¨è­¯">äº¤å‰ç·¨è­¯</a></h2>
<p>The next step is to <em>cross</em> compile the program for the Cortex-M3 architecture. Thatâ€™s as simple as running <code>cargo build --target $TRIPLE</code> if you know what the compilation target (<code>$TRIPLE</code>) should be. Luckily, the <code>.cargo/config.toml</code> in the template has the answer:</p>
<pre><code class="language-console">tail -n6 .cargo/config.toml
</code></pre>
<pre><code class="language-toml">[build]
# Pick ONE of these compilation targets
# target = "thumbv6m-none-eabi"    # Cortex-M0 and Cortex-M0+
target = "thumbv7m-none-eabi"    # Cortex-M3
# target = "thumbv7em-none-eabi"   # Cortex-M4 and Cortex-M7 (no FPU)
# target = "thumbv7em-none-eabihf" # Cortex-M4F and Cortex-M7F (with FPU)
</code></pre>
<p>To cross compile for the Cortex-M3 architecture we have to use <code>thumbv7m-none-eabi</code>. That target is not automatically installed when installing the Rust toolchain, it would now be a good time to add that target to the toolchain, if you havenâ€™t done it yet:</p>
<pre><code class="language-console">rustup target add thumbv7m-none-eabi
</code></pre>
<p>Since the <code>thumbv7m-none-eabi</code> compilation target has been set as the default in your <code>.cargo/config.toml</code> file, the two commands below do the same:</p>
<pre><code class="language-console">cargo build --target thumbv7m-none-eabi
cargo build
</code></pre>
<h2 id="inspecting"><a class="header" href="#inspecting">Inspecting</a></h2>
<p>Now we have a non-native ELF binary in <code>target/thumbv7m-none-eabi/debug/app</code>. We can inspect it using <code>cargo-binutils</code>.</p>
<p>With <code>cargo-readobj</code> we can print the ELF headers to confirm that this is an ARM binary.</p>
<pre><code class="language-console">cargo readobj --bin app -- --file-headers
</code></pre>
<p>Note that:</p>
<ul>
<li><code>--bin app</code> is sugar for inspect the binary at <code>target/$TRIPLE/debug/app</code></li>
<li><code>--bin app</code> will also (re)compile the binary, if necessary</li>
</ul>
<pre><code class="language-text">ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0x0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x405
  Start of program headers:          52 (bytes into file)
  Start of section headers:          153204 (bytes into file)
  Flags:                             0x5000200
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         19
  Section header string table index: 18
</code></pre>
<p><code>cargo-size</code> can print the size of the linker sections of the binary.</p>
<pre><code class="language-console">cargo size --bin app --release -- -A
</code></pre>
<p>we use <code>--release</code> to inspect the optimized version</p>
<pre><code class="language-text">app  :
section             size        addr
.vector_table       1024         0x0
.text                 92       0x400
.rodata                0       0x45c
.data                  0  0x20000000
.bss                   0  0x20000000
.debug_str          2958         0x0
.debug_loc            19         0x0
.debug_abbrev        567         0x0
.debug_info         4929         0x0
.debug_ranges         40         0x0
.debug_macinfo         1         0x0
.debug_pubnames     2035         0x0
.debug_pubtypes     1892         0x0
.ARM.attributes       46         0x0
.debug_frame         100         0x0
.debug_line          867         0x0
Total              14570
</code></pre>
<blockquote>
<p>A refresher on ELF linker sections</p>
<ul>
<li><code>.text</code> contains the program instructions</li>
<li><code>.rodata</code> contains constant values like strings</li>
<li><code>.data</code> contains statically allocated variables whose initial values are <em>not</em> zero</li>
<li><code>.bss</code> also contains statically allocated variables whose initial values <em>are</em> zero</li>
<li><code>.vector_table</code> is a <em>non</em>-standard section that we use to store the vector (interrupt) table</li>
<li><code>.ARM.attributes</code> and the <code>.debug_*</code> sections contain metadata and will <em>not</em> be loaded onto the target when flashing the binary.</li>
</ul>
</blockquote>
<p><strong>IMPORTANT</strong>: ELF files contain metadata like debug information so their <em>size on disk</em> does <em>not</em> accurately reflect the space the program will occupy when flashed on a device. <em>Always</em> use <code>cargo-size</code> to check how big a binary really is.</p>
<p><code>cargo-objdump</code> can be used to disassemble the binary.</p>
<pre><code class="language-console">cargo objdump --bin app --release -- --disassemble --no-show-raw-insn --print-imm-hex
</code></pre>
<blockquote>
<p><strong>NOTE</strong> if the above command complains about <code>Unknown command line argument</code> see the following bug report: https://github.com/rust-embedded/book/issues/269</p>
</blockquote>
<blockquote>
<p><strong>NOTE</strong> this output can differ on your system. New versions of rustc, LLVM and libraries can generate different assembly. We truncated some of the instructions to keep the snippet small.</p>
</blockquote>
<pre><code class="language-text">app:  file format ELF32-arm-little

Disassembly of section .text:
main:
     400: bl  #0x256
     404: b #-0x4 &lt;main+0x4&gt;

Reset:
     406: bl  #0x24e
     40a: movw  r0, #0x0
     &lt; .. truncated any more instructions .. &gt;

DefaultHandler_:
     656: b #-0x4 &lt;DefaultHandler_&gt;

UsageFault:
     657: strb  r7, [r4, #0x3]

DefaultPreInit:
     658: bx  lr

__pre_init:
     659: strb  r7, [r0, #0x1]

__nop:
     65a: bx  lr

HardFaultTrampoline:
     65c: mrs r0, msp
     660: b #-0x2 &lt;HardFault_&gt;

HardFault_:
     662: b #-0x4 &lt;HardFault_&gt;

HardFault:
     663: &lt;unknown&gt;
</code></pre>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<p>Next, letâ€™s see how to run an embedded program on QEMU! This time weâ€™ll use the <code>hello</code> example which actually does something.</p>
<p>For convenience hereâ€™s the source code of <code>examples/hello.rs</code>:</p>
<pre><code class="language-rust ignore">//! Prints "Hello, world!" on the host console using semihosting

#![no_main]
#![no_std]

use panic_halt as _;

use cortex_m_rt::entry;
use cortex_m_semihosting::{debug, hprintln};

#[entry]
fn main() -&gt; ! {
    hprintln!("Hello, world!").unwrap();

    // exit QEMU
    // NOTE do not run this on hardware; it can corrupt OpenOCD state
    debug::exit(debug::EXIT_SUCCESS);

    loop {}
}</code></pre>
<p>This program uses something called semihosting to print text to the <em>host</em> console. When using real hardware this requires a debug session but when using QEMU this Just Works.</p>
<p>Letâ€™s start by compiling the example:</p>
<pre><code class="language-console">cargo build --example hello
</code></pre>
<p>The output binary will be located at <code>target/thumbv7m-none-eabi/debug/examples/hello</code>.</p>
<p>To run this binary on QEMU run the following command:</p>
<pre><code class="language-console">qemu-system-arm \
  -cpu cortex-m3 \
  -machine lm3s6965evb \
  -nographic \
  -semihosting-config enable=on,target=native \
  -kernel target/thumbv7m-none-eabi/debug/examples/hello
</code></pre>
<pre><code class="language-text">Hello, world!
</code></pre>
<p>The command should successfully exit (exit code = 0) after printing the text. On *nix you can check that with the following command:</p>
<pre><code class="language-console">echo $?
</code></pre>
<pre><code class="language-text">0
</code></pre>
<p>Letâ€™s break down that QEMU command:</p>
<ul>
<li>
<p><code>qemu-system-arm</code>. This is the QEMU emulator. There are a few variants of these QEMU binaries; this one does full <em>system</em> emulation of <em>ARM</em> machines hence the name.</p>
</li>
<li>
<p><code>-cpu cortex-m3</code>. This tells QEMU to emulate a Cortex-M3 CPU. Specifying the CPU model lets us catch some miscompilation errors: for example, running a program compiled for the Cortex-M4F, which has a hardware FPU, will make QEMU error during its execution.</p>
</li>
<li>
<p><code>-machine lm3s6965evb</code>. This tells QEMU to emulate the LM3S6965EVB, an evaluation board that contains a LM3S6965 microcontroller.</p>
</li>
<li>
<p><code>-nographic</code>. This tells QEMU to not launch its GUI.</p>
</li>
<li>
<p><code>-semihosting-config (..)</code>. This tells QEMU to enable semihosting. Semihosting lets the emulated device, among other things, use the host stdout, stderr and stdin and create files on the host.</p>
</li>
<li>
<p><code>-kernel $file</code>. This tells QEMU which binary to load and run on the emulated machine.</p>
</li>
</ul>
<p>Typing out that long QEMU command is too much work! We can set a custom runner to simplify the process. <code>.cargo/config.toml</code> has a commented out runner that invokes QEMU; letâ€™s uncomment it:</p>
<pre><code class="language-console">head -n3 .cargo/config.toml
</code></pre>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
# uncomment this to make `cargo run` execute programs on QEMU
runner = "qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel"
</code></pre>
<p>This runner only applies to the <code>thumbv7m-none-eabi</code> target, which is our default compilation target. Now <code>cargo run</code> will compile the program and run it on QEMU:</p>
<pre><code class="language-console">cargo run --example hello --release
</code></pre>
<pre><code class="language-text">   Compiling app v0.1.0 (file:///tmp/app)
    Finished release [optimized + debuginfo] target(s) in 0.26s
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel target/thumbv7m-none-eabi/release/examples/hello`
Hello, world!
</code></pre>
<h2 id="é™¤éŒ¯"><a class="header" href="#é™¤éŒ¯">é™¤éŒ¯</a></h2>
<p>Debugging is critical to embedded development. Letâ€™s see how itâ€™s done.</p>
<p>Debugging an embedded device involves <em>remote</em> debugging as the program that we want to debug wonâ€™t be running on the machine thatâ€™s running the debugger program (GDB or LLDB).</p>
<p>Remote debugging involves a client and a server. In a QEMU setup, the client will be a GDB (or LLDB) process and the server will be the QEMU process thatâ€™s also running the embedded program.</p>
<p>In this section weâ€™ll use the <code>hello</code> example we already compiled.</p>
<p>The first debugging step is to launch QEMU in debugging mode:</p>
<pre><code class="language-console">qemu-system-arm \
  -cpu cortex-m3 \
  -machine lm3s6965evb \
  -nographic \
  -semihosting-config enable=on,target=native \
  -gdb tcp::3333 \
  -S \
  -kernel target/thumbv7m-none-eabi/debug/examples/hello
</code></pre>
<p>This command wonâ€™t print anything to the console and will block the terminal. We have passed two extra flags this time:</p>
<ul>
<li>
<p><code>-gdb tcp::3333</code>. This tells QEMU to wait for a GDB connection on TCP port 3333.</p>
</li>
<li>
<p><code>-S</code>. This tells QEMU to freeze the machine at startup. Without this the program would have reached the end of main before we had a chance to launch the debugger!</p>
</li>
</ul>
<p>Next we launch GDB in another terminal and tell it to load the debug symbols of the example:</p>
<pre><code class="language-console">gdb-multiarch -q target/thumbv7m-none-eabi/debug/examples/hello
</code></pre>
<p><strong>NOTE</strong>: you might need another version of gdb instead of <code>gdb-multiarch</code> depending on which one you installed in the installation chapter. This could also be <code>arm-none-eabi-gdb</code> or just <code>gdb</code>.</p>
<p>Then within the GDB shell we connect to QEMU, which is waiting for a connection on TCP port 3333.</p>
<pre><code class="language-console">target remote :3333
</code></pre>
<pre><code class="language-text">Remote debugging using :3333
Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473
473     pub unsafe extern "C" fn Reset() -&gt; ! {
</code></pre>
<p>Youâ€™ll see that the process is halted and that the program counter is pointing to a function named <code>Reset</code>. That is the reset handler: what Cortex-M cores execute upon booting.</p>
<blockquote>
<p>Note that on some setup, instead of displaying the line <code>Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473</code> as shown above, gdb may print some warnings like :</p>
<p><code>core::num::bignum::Big32x40::mul_small () at src/libcore/num/bignum.rs:254</code> <code>    src/libcore/num/bignum.rs: No such file or directory.</code></p>
<p>Thatâ€™s a known glitch. You can safely ignore those warnings, youâ€™re most likely at Reset().</p>
</blockquote>
<p>This reset handler will eventually call our main function. Letâ€™s skip all the way there using a breakpoint and the <code>continue</code> command. To set the breakpoint, letâ€™s first take a look where we would like to break in our code, with the <code>list</code> command.</p>
<pre><code class="language-console">list main
</code></pre>
<p>This will show the source code, from the file examples/hello.rs.</p>
<pre><code class="language-text">6       use panic_halt as _;
7
8       use cortex_m_rt::entry;
9       use cortex_m_semihosting::{debug, hprintln};
10
11      #[entry]
12      fn main() -&gt; ! {
13          hprintln!("Hello, world!").unwrap();
14
15          // exit QEMU
</code></pre>
<p>We would like to add a breakpoint just before the â€œHello, world!â€, which is on line 13. We do that with the <code>break</code> command:</p>
<pre><code class="language-console">break 13
</code></pre>
<p>We can now instruct gdb to run up to our main function, with the <code>continue</code> command:</p>
<pre><code class="language-console">continue
</code></pre>
<pre><code class="language-text">Continuing.

Breakpoint 1, hello::__cortex_m_rt_main () at examples\hello.rs:13
13          hprintln!("Hello, world!").unwrap();
</code></pre>
<p>We are now close to the code that prints â€œHello, world!â€. Letâ€™s move forward using the <code>next</code> command.</p>
<pre><code class="language-console">next
</code></pre>
<pre><code class="language-text">16          debug::exit(debug::EXIT_SUCCESS);
</code></pre>
<p>At this point you should see â€œHello, world!â€ printed on the terminal thatâ€™s running <code>qemu-system-arm</code>.</p>
<pre><code class="language-text">$ qemu-system-arm (..)
Hello, world!
</code></pre>
<p>Calling <code>next</code> again will terminate the QEMU process.</p>
<pre><code class="language-console">next
</code></pre>
<pre><code class="language-text">[Inferior 1 (Remote target) exited normally]
</code></pre>
<p>You can now exit the GDB session.</p>
<pre><code class="language-console">quit
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ç¡¬é«”"><a class="header" href="#ç¡¬é«”">ç¡¬é«”</a></h1>
<p>By now you should be somewhat familiar with the tooling and the development process. In this section weâ€™ll switch to real hardware; the process will remain largely the same. Letâ€™s dive in.</p>
<h2 id="know-your-hardware"><a class="header" href="#know-your-hardware">Know your hardware</a></h2>
<p>Before we begin you need to identify some characteristics of the target device as these will be used to configure the project:</p>
<ul>
<li>
<p>The ARM core. e.g. Cortex-M3.</p>
</li>
<li>
<p>Does the ARM core include an FPU? Cortex-M4<strong>F</strong> and Cortex-M7<strong>F</strong> cores do.</p>
</li>
<li>
<p>How much Flash memory and RAM does the target device have? e.g. 256 KiB of Flash and 32 KiB of RAM.</p>
</li>
<li>
<p>Where are Flash memory and RAM mapped in the address space? e.g. RAM is commonly located at address <code>0x2000_0000</code>.</p>
</li>
</ul>
<p>You can find this information in the data sheet or the reference manual of your device.</p>
<p>In this section weâ€™ll be using our reference hardware, the STM32F3DISCOVERY. This board contains an STM32F303VCT6 microcontroller. This microcontroller has:</p>
<ul>
<li>
<p>A Cortex-M4F core that includes a single precision FPU</p>
</li>
<li>
<p>256 KiB of Flash located at address 0x0800_0000.</p>
</li>
<li>
<p>40 KiB of RAM located at address 0x2000_0000. (Thereâ€™s another RAM region but for simplicity weâ€™ll ignore it).</p>
</li>
</ul>
<h2 id="configuring"><a class="header" href="#configuring">Configuring</a></h2>
<p>Weâ€™ll start from scratch with a fresh template instance. Refer to the <a href="#qemu-1">previous section on QEMU</a> for a refresher on how to do this without <code>cargo-generate</code>.</p>
<pre><code class="language-text">$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart
 Project Name: app
 Creating project called `app`...
 Done! New project created /tmp/app

$ cd app
</code></pre>
<p>Step number one is to set a default compilation target in <code>.cargo/config.toml</code>.</p>
<pre><code class="language-console">tail -n5 .cargo/config.toml
</code></pre>
<pre><code class="language-toml"># Pick ONE of these compilation targets
# target = "thumbv6m-none-eabi"    # Cortex-M0 and Cortex-M0+
# target = "thumbv7m-none-eabi"    # Cortex-M3
# target = "thumbv7em-none-eabi"   # Cortex-M4 and Cortex-M7 (no FPU)
target = "thumbv7em-none-eabihf" # Cortex-M4F and Cortex-M7F (with FPU)
</code></pre>
<p>Weâ€™ll use <code>thumbv7em-none-eabihf</code> as that covers the Cortex-M4F core.</p>
<blockquote>
<p><strong>NOTE</strong>: As you may remember from the previous chapter, we have to install all targets and this is a new one. So donâ€™t forget to run the installation process <code>rustup target add thumbv7em-none-eabihf</code> for this target.</p>
</blockquote>
<p>The second step is to enter the memory region information into the <code>memory.x</code> file.</p>
<pre><code class="language-text">$ cat memory.x
/* Linker script for the STM32F303VCT6 */
MEMORY
{
  /* NOTE 1 K = 1 KiBi = 1024 bytes */
  FLASH : ORIGIN = 0x08000000, LENGTH = 256K
  RAM : ORIGIN = 0x20000000, LENGTH = 40K
}
</code></pre>
<blockquote>
<p><strong>NOTE</strong>: If you for some reason changed the <code>memory.x</code> file after you had made the first build of a specific build target, then do <code>cargo clean</code> before <code>cargo build</code>, because <code>cargo build</code> may not track updates of <code>memory.x</code>.</p>
</blockquote>
<p>Weâ€™ll start with the hello example again, but first we have to make a small change.</p>
<p>In <code>examples/hello.rs</code>, make sure the <code>debug::exit()</code> call is commented out or removed. It is used only for running in QEMU.</p>
<pre><code class="language-rust ignore">#[entry]
fn main() -&gt; ! {
    hprintln!("Hello, world!").unwrap();

    // exit QEMU
    // NOTE do not run this on hardware; it can corrupt OpenOCD state
    // debug::exit(debug::EXIT_SUCCESS);

    loop {}
}</code></pre>
<p>You can now cross compile programs using <code>cargo build</code> and inspect the binaries using <code>cargo-binutils</code> as you did before. The <code>cortex-m-rt</code> crate handles all the magic required to get your chip running, as helpfully, pretty much all Cortex-M CPUs boot in the same fashion.</p>
<pre><code class="language-console">cargo build --example hello
</code></pre>
<h2 id="é™¤éŒ¯-1"><a class="header" href="#é™¤éŒ¯-1">é™¤éŒ¯</a></h2>
<p>Debugging will look a bit different. In fact, the first steps can look different depending on the target device. In this section weâ€™ll show the steps required to debug a program running on the STM32F3DISCOVERY. This is meant to serve as a reference; for device specific information about debugging check out <a href="https://github.com/rust-embedded/debugonomicon">the Debugonomicon</a>.</p>
<p>As before weâ€™ll do remote debugging and the client will be a GDB process. This time, however, the server will be OpenOCD.</p>
<p>As done during the <a href="#é©—è­‰å®‰è£">verify</a> section connect the discovery board to your laptop / PC and check that the ST-LINK header is populated.</p>
<p>On a terminal run <code>openocd</code> to connect to the ST-LINK on the discovery board. Run this command from the root of the template; <code>openocd</code> will pick up the <code>openocd.cfg</code> file which indicates which interface file and target file to use.</p>
<pre><code class="language-console">cat openocd.cfg
</code></pre>
<pre><code class="language-text"># Sample OpenOCD configuration for the STM32F3DISCOVERY development board

# Depending on the hardware revision you got you'll have to pick ONE of these
# interfaces. At any time only one interface should be commented out.

# Revision C (newer revision)
source [find interface/stlink.cfg]

# Revision A and B (older revisions)
# source [find interface/stlink-v2.cfg]

source [find target/stm32f3x.cfg]
</code></pre>
<blockquote>
<p><strong>NOTE</strong> If you found out that you have an older revision of the discovery board during the <a href="#é©—è­‰å®‰è£">verify</a> section then you should modify the <code>openocd.cfg</code> file at this point to use <code>interface/stlink-v2.cfg</code>.</p>
</blockquote>
<pre><code class="language-text">$ openocd
Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport "hla_swd". To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.913879
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<p>On another terminal run GDB, also from the root of the template.</p>
<pre><code class="language-text">gdb-multiarch -q target/thumbv7em-none-eabihf/debug/examples/hello
</code></pre>
<p><strong>NOTE</strong>: like before you might need another version of gdb instead of <code>gdb-multiarch</code> depending on which one you installed in the installation chapter. This could also be <code>arm-none-eabi-gdb</code> or just <code>gdb</code>.</p>
<p>Next connect GDB to OpenOCD, which is waiting for a TCP connection on port 3333.</p>
<pre><code class="language-console">(gdb) target remote :3333
Remote debugging using :3333
0x00000000 in ?? ()
</code></pre>
<p>Now proceed to <em>flash</em> (load) the program onto the microcontroller using the <code>load</code> command.</p>
<pre><code class="language-console">(gdb) load
Loading section .vector_table, size 0x400 lma 0x8000000
Loading section .text, size 0x1518 lma 0x8000400
Loading section .rodata, size 0x414 lma 0x8001918
Start address 0x08000400, load size 7468
Transfer rate: 13 KB/sec, 2489 bytes/write.
</code></pre>
<p>The program is now loaded. This program uses semihosting so before we do any semihosting call we have to tell OpenOCD to enable semihosting. You can send commands to OpenOCD using the <code>monitor</code> command.</p>
<pre><code class="language-console">(gdb) monitor arm semihosting enable
semihosting is enabled
</code></pre>
<blockquote>
<p>You can see all the OpenOCD commands by invoking the <code>monitor help</code> command.</p>
</blockquote>
<p>Like before we can skip all the way to <code>main</code> using a breakpoint and the <code>continue</code> command.</p>
<pre><code class="language-console">(gdb) break main
Breakpoint 1 at 0x8000490: file examples/hello.rs, line 11.
Note: automatically using hardware breakpoints for read-only addresses.

(gdb) continue
Continuing.

Breakpoint 1, hello::__cortex_m_rt_main_trampoline () at examples/hello.rs:11
11      #[entry]
</code></pre>
<blockquote>
<p><strong>NOTE</strong> If GDB blocks the terminal instead of hitting the breakpoint after you issue the <code>continue</code> command above, you might want to double check that the memory region information in the <code>memory.x</code> file is correctly set up for your device (both the starts <em>and</em> lengths).</p>
</blockquote>
<p>Step into the main function with <code>step</code>.</p>
<pre><code class="language-console">(gdb) step
halted: PC: 0x08000496
hello::__cortex_m_rt_main () at examples/hello.rs:13
13          hprintln!("Hello, world!").unwrap();
</code></pre>
<p>After advancing the program with <code>next</code> you should see â€œHello, world!â€ printed on the OpenOCD console, among other stuff.</p>
<pre><code class="language-console">$ openocd
(..)
Info : halted: PC: 0x08000502
Hello, world!
Info : halted: PC: 0x080004ac
Info : halted: PC: 0x080004ae
Info : halted: PC: 0x080004b0
Info : halted: PC: 0x080004b4
Info : halted: PC: 0x080004b8
Info : halted: PC: 0x080004bc
</code></pre>
<p>The message is only displayed once as the program is about to enter the infinite loop defined in line 19: <code>loop {}</code></p>
<p>æ‚¨ç¾åœ¨å¯ä»¥ä½¿ç”¨ <code>quit</code> å‘½ä»¤é€€å‡º GDBã€‚</p>
<pre><code class="language-console">(gdb) quit
A debugging session is active.

        Inferior 1 [Remote target] will be detached.

Quit anyway? (y or n)
</code></pre>
<p>Debugging now requires a few more steps so we have packed all those steps into a single GDB script named <code>openocd.gdb</code>. The file was created during the <code>cargo generate</code> step, and should work without any modifications. Letâ€™s have a peek:</p>
<pre><code class="language-console">cat openocd.gdb
</code></pre>
<pre><code class="language-text">target extended-remote :3333

# print demangled symbols
set print asm-demangle on

# detect unhandled exceptions, hard faults and panics
break DefaultHandler
break HardFault
break rust_begin_unwind

monitor arm semihosting enable

load

# start the process but immediately halt the processor
stepi
</code></pre>
<p>Now running <code>&lt;gdb&gt; -x openocd.gdb target/thumbv7em-none-eabihf/debug/examples/hello</code> will immediately connect GDB to OpenOCD, enable semihosting, load the program and start the process.</p>
<p>Alternatively, you can turn <code>&lt;gdb&gt; -x openocd.gdb</code> into a custom runner to make <code>cargo run</code> build a program <em>and</em> start a GDB session. This runner is included in <code>.cargo/config.toml</code> but itâ€™s commented out.</p>
<pre><code class="language-console">head -n10 .cargo/config.toml
</code></pre>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
# uncomment this to make `cargo run` execute programs on QEMU
# runner = "qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel"

[target.'cfg(all(target_arch = "arm", target_os = "none"))']
# uncomment ONE of these three option to make `cargo run` start a GDB session
# which option to pick depends on your system
runner = "arm-none-eabi-gdb -x openocd.gdb"
# runner = "gdb-multiarch -x openocd.gdb"
# runner = "gdb -x openocd.gdb"
</code></pre>
<pre><code class="language-text">$ cargo run --example hello
(..)
Loading section .vector_table, size 0x400 lma 0x8000000
Loading section .text, size 0x1e70 lma 0x8000400
Loading section .rodata, size 0x61c lma 0x8002270
Start address 0x800144e, load size 10380
Transfer rate: 17 KB/sec, 3460 bytes/write.
(gdb)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="memory-mapped-registers"><a class="header" href="#memory-mapped-registers">Memory Mapped Registers</a></h1>
<p>Embedded systems can only get so far by executing normal Rust code and moving data around in RAM. If we want to get any information into or out of our system (be that blinking an LED, detecting a button press or communicating with an off-chip peripheral on some sort of bus) weâ€™re going to have to dip into the world of Peripherals and their â€˜memory mapped registersâ€™.</p>
<p>You may well find that the code you need to access the peripherals in your micro-controller has already been written, at one of the following levels:</p>
<p align="center">
<img title="Common crates" src="assets/crates.png">
</p>

<ul>
<li>Micro-architecture Crate - This sort of crate handles any useful routines common to the processor core your microcontroller is using, as well as any peripherals that are common to all micro-controllers that use that particular type of processor core. For example the <a href="https://crates.io/crates/cortex-m">cortex-m</a> crate gives you functions to enable and disable interrupts, which are the same for all Cortex-M based micro-controllers. It also gives you access to the â€˜SysTickâ€™ peripheral included with all Cortex-M based micro-controllers.</li>
<li>Peripheral Access Crate (PAC) - This sort of crate is a thin wrapper over the various memory-wrapper registers defined for your particular part-number of micro-controller you are using. For example, <a href="https://crates.io/crates/tm4c123x">tm4c123x</a> for the Texas Instruments Tiva-C TM4C123 series, or <a href="https://crates.io/crates/stm32f30x">stm32f30x</a> for the ST-Micro STM32F30x series. Here, youâ€™ll be interacting with the registers directly, following each peripheralâ€™s operating instructions given in your micro-controllerâ€™s Technical Reference Manual.</li>
<li>HAL Crate - These crates offer a more user-friendly API for your particular processor, often by implementing some common traits defined in <a href="https://crates.io/crates/embedded-hal">embedded-hal</a>. For example, this crate might offer a <code>Serial</code> struct, with a constructor that takes an appropriate set of GPIO pins and a baud rate, and offers some sort of <code>write_byte</code> function for sending data. See the chapter on <a href="#å¯æ”œæ€§">Portability</a> for more information on <a href="https://crates.io/crates/embedded-hal">embedded-hal</a>.</li>
<li>Board Crate - These crates go one step further than a HAL Crate by pre-configuring various peripherals and GPIO pins to suit the specific developer kit or board you are using, such as <a href="https://crates.io/crates/stm32f3-discovery">stm32f3-discovery</a> for the STM32F3DISCOVERY board.</li>
</ul>
<h2 id="board-crate"><a class="header" href="#board-crate">Board Crate</a></h2>
<p>A board crate is the perfect starting point, if youâ€™re new to embedded Rust. They nicely abstract the HW details that might be overwhelming when starting studying this subject, and makes standard tasks easy, like turning a LED on or off. The functionality it exposes varies a lot between boards. Since this book aims at staying hardware agnostic, the board crates wonâ€™t be covered by this book.</p>
<p>If you want to experiment with the STM32F3DISCOVERY board, it is highly recommended to take a look at the <a href="https://crates.io/crates/stm32f3-discovery">stm32f3-discovery</a> board crate, which provides functionality to blink the board LEDs, access its compass, bluetooth and more. The <a href="https://rust-embedded.github.io/discovery/">Discovery</a> book offers a great introduction to the use of a board crate.</p>
<p>But if youâ€™re working on a system that doesnâ€™t yet have dedicated board crate, or you need functionality not provided by existing crates, read on as we start from the bottom, with the micro-architecture crates.</p>
<h2 id="micro-architecture-crate"><a class="header" href="#micro-architecture-crate">Micro-architecture crate</a></h2>
<p>Letâ€™s look at the SysTick peripheral thatâ€™s common to all Cortex-M based micro-controllers. We can find a pretty low-level API in the <a href="https://crates.io/crates/cortex-m">cortex-m</a> crate, and we can use it like this:</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]
use cortex_m::peripheral::{syst, Peripherals};
use cortex_m_rt::entry;
use panic_halt as _;

#[entry]
fn main() -&gt; ! {
    let peripherals = Peripherals::take().unwrap();
    let mut systick = peripherals.SYST;
    systick.set_clock_source(syst::SystClkSource::Core);
    systick.set_reload(1_000);
    systick.clear_current();
    systick.enable_counter();
    while !systick.has_wrapped() {
        // Loop
    }

    loop {}
}</code></pre>
<p>The functions on the <code>SYST</code> struct map pretty closely to the functionality defined by the ARM Technical Reference Manual for this peripheral. Thereâ€™s nothing in this API about â€˜delaying for X millisecondsâ€™ - we have to crudely implement that ourselves using a <code>while</code> loop. Note that we canâ€™t access our <code>SYST</code> struct until we have called <code>Peripherals::take()</code> - this is a special routine that guarantees that there is only one <code>SYST</code> structure in our entire program. For more on that, see the <a href="#å‘¨é‚Š">Peripherals</a> section.</p>
<h2 id="using-a-peripheral-access-crate-pac"><a class="header" href="#using-a-peripheral-access-crate-pac">Using a Peripheral Access Crate (PAC)</a></h2>
<p>We wonâ€™t get very far with our embedded software development if we restrict ourselves to only the basic peripherals included with every Cortex-M. At some point, weâ€™re going to need to write some code thatâ€™s specific to the particular micro-controller weâ€™re using. In this example, letâ€™s assume we have an Texas Instruments TM4C123 - a middling 80MHz Cortex-M4 with 256 KiB of Flash. Weâ€™re going to pull in the <a href="https://crates.io/crates/tm4c123x">tm4c123x</a> crate to make use of this chip.</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

use panic_halt as _; // panic handler

use cortex_m_rt::entry;
use tm4c123x;

#[entry]
pub fn init() -&gt; (Delay, Leds) {
    let cp = cortex_m::Peripherals::take().unwrap();
    let p = tm4c123x::Peripherals::take().unwrap();

    let pwm = p.PWM0;
    pwm.ctl.write(|w| w.globalsync0().clear_bit());
    // Mode = 1 =&gt; Count up/down mode
    pwm._2_ctl.write(|w| w.enable().set_bit().mode().set_bit());
    pwm._2_gena.write(|w| w.actcmpau().zero().actcmpad().one());
    // 528 cycles (264 up and down) = 4 loops per video line (2112 cycles)
    pwm._2_load.write(|w| unsafe { w.load().bits(263) });
    pwm._2_cmpa.write(|w| unsafe { w.compa().bits(64) });
    pwm.enable.write(|w| w.pwm4en().set_bit());
}
</code></pre>
<p>Weâ€™ve accessed the <code>PWM0</code> peripheral in exactly the same way as we accessed the <code>SYST</code> peripheral earlier, except we called <code>tm4c123x::Peripherals::take()</code>. As this crate was auto-generated using <a href="https://crates.io/crates/svd2rust">svd2rust</a>, the access functions for our register fields take a closure, rather than a numeric argument. While this looks like a lot of code, the Rust compiler can use it to perform a bunch of checks for us, but then generate machine-code which is pretty close to hand-written assembler! Where the auto-generated code isnâ€™t able to determine that all possible arguments to a particular accessor function are valid (for example, if the SVD defines the register as 32-bit but doesnâ€™t say if some of those 32-bit values have a special meaning), then the function is marked as <code>unsafe</code>. We can see this in the example above when setting the <code>load</code> and <code>compa</code> sub-fields using the <code>bits()</code> function.</p>
<h3 id="reading"><a class="header" href="#reading">Reading</a></h3>
<p>The <code>read()</code> function returns an object which gives read-only access to the various sub-fields within this register, as defined by the manufacturerâ€™s SVD file for this chip. You can find all the functions available on special <code>R</code> return type for this particular register, in this particular peripheral, on this particular chip, in the <a href="https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html">tm4c123x documentation</a>.</p>
<pre><code class="language-rust ignore">if pwm.ctl.read().globalsync0().is_set() {
    // Do a thing
}</code></pre>
<h3 id="writing"><a class="header" href="#writing">Writing</a></h3>
<p>The <code>write()</code> function takes a closure with a single argument. Typically we call this <code>w</code>. This argument then gives read-write access to the various sub-fields within this register, as defined by the manufacturerâ€™s SVD file for this chip. Again, you can find all the functions available on the â€˜wâ€™ for this particular register, in this particular peripheral, on this particular chip, in the <a href="https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.W.html">tm4c123x documentation</a>. Note that all of the sub-fields that we do not set will be set to a default value for us - any existing content in the register will be lost.</p>
<pre><code class="language-rust ignore">pwm.ctl.write(|w| w.globalsync0().clear_bit());</code></pre>
<h3 id="modifying"><a class="header" href="#modifying">Modifying</a></h3>
<p>If we wish to change only one particular sub-field in this register and leave the other sub-fields unchanged, we can use the <code>modify</code> function. This function takes a closure with two arguments - one for reading and one for writing. Typically we call these <code>r</code> and <code>w</code> respectively. The <code>r</code> argument can be used to inspect the current contents of the register, and the <code>w</code> argument can be used to modify the register contents.</p>
<pre><code class="language-rust ignore">pwm.ctl.modify(|r, w| w.globalsync0().clear_bit());</code></pre>
<p>The <code>modify</code> function really shows the power of closures here. In C, weâ€™d have to read into some temporary value, modify the correct bits and then write the value back. This means thereâ€™s considerable scope for error:</p>
<pre><code class="language-C">uint32_t temp = pwm0.ctl.read();
temp |= PWM0_CTL_GLOBALSYNC0;
pwm0.ctl.write(temp);
uint32_t temp2 = pwm0.enable.read();
temp2 |= PWM0_ENABLE_PWM4EN;
pwm0.enable.write(temp); // Uh oh! Wrong variable!
</code></pre>
<h2 id="using-a-hal-crate"><a class="header" href="#using-a-hal-crate">Using a HAL crate</a></h2>
<p>The HAL crate for a chip typically works by implementing a custom Trait for the raw structures exposed by the PAC. Often this trait will define a function called <code>constrain()</code> for single peripherals or <code>split()</code> for things like GPIO ports with multiple pins. This function will consume the underlying raw peripheral structure and return a new object with a higher-level API. This API may also do things like have the Serial port <code>new</code> function require a borrow on some <code>Clock</code> structure, which can only be generated by calling the function which configures the PLLs and sets up all the clock frequencies. In this way, it is statically impossible to create a Serial port object without first having configured the clock rates, or for the Serial port object to misconvert the baud rate into clock ticks. Some crates even define special traits for the states each GPIO pin can be in, requiring the user to put a pin into the correct state (say, by selecting the appropriate Alternate Function Mode) before passing the pin into Peripheral. All with no run-time cost!</p>
<p>Letâ€™s see an example:</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

use panic_halt as _; // panic handler

use cortex_m_rt::entry;
use tm4c123x_hal as hal;
use tm4c123x_hal::prelude::*;
use tm4c123x_hal::serial::{NewlineMode, Serial};
use tm4c123x_hal::sysctl;

#[entry]
fn main() -&gt; ! {
    let p = hal::Peripherals::take().unwrap();
    let cp = hal::CorePeripherals::take().unwrap();

    // Wrap up the SYSCTL struct into an object with a higher-layer API
    let mut sc = p.SYSCTL.constrain();
    // Pick our oscillation settings
    sc.clock_setup.oscillator = sysctl::Oscillator::Main(
        sysctl::CrystalFrequency::_16mhz,
        sysctl::SystemClock::UsePll(sysctl::PllOutputFrequency::_80_00mhz),
    );
    // Configure the PLL with those settings
    let clocks = sc.clock_setup.freeze();

    // Wrap up the GPIO_PORTA struct into an object with a higher-layer API.
    // Note it needs to borrow `sc.power_control` so it can power up the GPIO
    // peripheral automatically.
    let mut porta = p.GPIO_PORTA.split(&amp;sc.power_control);

    // Activate the UART.
    let uart = Serial::uart0(
        p.UART0,
        // The transmit pin
        porta
            .pa1
            .into_af_push_pull::&lt;hal::gpio::AF1&gt;(&amp;mut porta.control),
        // The receive pin
        porta
            .pa0
            .into_af_push_pull::&lt;hal::gpio::AF1&gt;(&amp;mut porta.control),
        // No RTS or CTS required
        (),
        (),
        // The baud rate
        115200_u32.bps(),
        // Output handling
        NewlineMode::SwapLFtoCRLF,
        // We need the clock rates to calculate the baud rate divisors
        &amp;clocks,
        // We need this to power up the UART peripheral
        &amp;sc.power_control,
    );

    loop {
        writeln!(uart, "Hello, World!\r\n").unwrap();
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="åŠä¸»æ©Ÿ"><a class="header" href="#åŠä¸»æ©Ÿ">åŠä¸»æ©Ÿ</a></h1>
<p>Semihosting is a mechanism that lets embedded devices do I/O on the host and is mainly used to log messages to the host console. Semihosting requires a debug session and pretty much nothing else (no extra wires!) so itâ€™s super convenient to use. The downside is that itâ€™s super slow: each write operation can take several milliseconds depending on the hardware debugger (e.g. ST-Link) you use.</p>
<p>The <a href="https://crates.io/crates/cortex-m-semihosting"><code>cortex-m-semihosting</code></a> crate provides an API to do semihosting operations on Cortex-M devices. The program below is the semihosting version of â€œHello, world!â€:</p>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

use panic_halt as _;

use cortex_m_rt::entry;
use cortex_m_semihosting::hprintln;

#[entry]
fn main() -&gt; ! {
    hprintln!("Hello, world!").unwrap();

    loop {}
}</code></pre>
<p>If you run this program on hardware youâ€™ll see the â€œHello, world!â€ message within the OpenOCD logs.</p>
<pre><code class="language-text">$ openocd
(..)
Hello, world!
(..)
</code></pre>
<p>You do need to enable semihosting in OpenOCD from GDB first:</p>
<pre><code class="language-console">(gdb) monitor arm semihosting enable
semihosting is enabled
</code></pre>
<p>QEMU understands semihosting operations so the above program will also work with <code>qemu-system-arm</code> without having to start a debug session. Note that youâ€™ll need to pass the <code>-semihosting-config</code> flag to QEMU to enable semihosting support; these flags are already included in the <code>.cargo/config.toml</code> file of the template.</p>
<pre><code class="language-text">$ # this program will block the terminal
$ cargo run
     Running `qemu-system-arm (..)
Hello, world!
</code></pre>
<p>Thereâ€™s also an <code>exit</code> semihosting operation that can be used to terminate the QEMU process. Important: do <strong>not</strong> use <code>debug::exit</code> on hardware; this function can corrupt your OpenOCD session and you will not be able to debug more programs until you restart it.</p>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

use panic_halt as _;

use cortex_m_rt::entry;
use cortex_m_semihosting::debug;

#[entry]
fn main() -&gt; ! {
    let roses = "blue";

    if roses == "red" {
        debug::exit(debug::EXIT_SUCCESS);
    } else {
        debug::exit(debug::EXIT_FAILURE);
    }

    loop {}
}</code></pre>
<pre><code class="language-text">$ cargo run
     Running `qemu-system-arm (..)

$ echo $?
1
</code></pre>
<p>One last tip: you can set the panicking behavior to <code>exit(EXIT_FAILURE)</code>. This will let you write <code>no_std</code> run-pass tests that you can run on QEMU.</p>
<p>For convenience, the <code>panic-semihosting</code> crate has an â€œexitâ€ feature that when enabled invokes <code>exit(EXIT_FAILURE)</code> after logging the panic message to the host stderr.</p>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

use panic_semihosting as _; // features = ["exit"]

use cortex_m_rt::entry;
use cortex_m_semihosting::debug;

#[entry]
fn main() -&gt; ! {
    let roses = "blue";

    assert_eq!(roses, "red");

    loop {}
}</code></pre>
<pre><code class="language-text">$ cargo run
     Running `qemu-system-arm (..)
panicked at 'assertion failed: `(left == right)`
  left: `"blue"`,
 right: `"red"`', examples/hello.rs:15:5

$ echo $?
1
</code></pre>
<p><strong>NOTE</strong>: To enable this feature on <code>panic-semihosting</code>, edit your <code>Cargo.toml</code> dependencies section where <code>panic-semihosting</code> is specified with:</p>
<pre><code class="language-toml">panic-semihosting = { version = "VERSION", features = ["exit"] }
</code></pre>
<p>where <code>VERSION</code> is the version desired. For more information on dependencies features check the <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html"><code>specifying dependencies</code></a> section of the Cargo book.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ææ…Œè™•ç†"><a class="header" href="#ææ…Œè™•ç†">ææ…Œè™•ç†</a></h1>
<p>Panicking is a core part of the Rust language. Built-in operations like indexing are runtime checked for memory safety. When out of bounds indexing is attempted this results in a panic.</p>
<p>In the standard library panicking has a defined behavior: it unwinds the stack of the panicking thread, unless the user opted for aborting the program on panics.</p>
<p>In programs without standard library, however, the panicking behavior is left undefined. A behavior can be chosen by declaring a <code>#[panic_handler]</code> function. This function must appear exactly <em>once</em> in the dependency graph of a program, and must have the following signature: <code>fn(&amp;PanicInfo) -&gt; !</code>, where <a href="https://doc.rust-lang.org/core/panic/struct.PanicInfo.html"><code>PanicInfo</code></a> is a struct containing information about the location of the panic.</p>
<p>Given that embedded systems range from user facing to safety critical (cannot crash) thereâ€™s no one size fits all panicking behavior but there are plenty of commonly used behaviors. These common behaviors have been packaged into crates that define the <code>#[panic_handler]</code> function. Some examples include:</p>
<ul>
<li><a href="https://crates.io/crates/panic-abort"><code>panic-abort</code></a>. A panic causes the abort instruction to be executed.</li>
<li><a href="https://crates.io/crates/panic-halt"><code>panic-halt</code></a>. A panic causes the program, or the current thread, to halt by entering an infinite loop.</li>
<li><a href="https://crates.io/crates/panic-itm"><code>panic-itm</code></a>. The panicking message is logged using the ITM, an ARM Cortex-M specific peripheral.</li>
<li><a href="https://crates.io/crates/panic-semihosting"><code>panic-semihosting</code></a>. The panicking message is logged to the host using the semihosting technique.</li>
</ul>
<p>You may be able to find even more crates searching for the <a href="https://crates.io/keywords/panic-handler"><code>panic-handler</code></a> keyword on crates.io.</p>
<p>A program can pick one of these behaviors simply by linking to the corresponding crate. The fact that the panicking behavior is expressed in the source of an application as a single line of code is not only useful as documentation but can also be used to change the panicking behavior according to the compilation profile. For example:</p>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

// dev profile: easier to debug panics; can put a breakpoint on `rust_begin_unwind`
#[cfg(debug_assertions)]
use panic_halt as _;

// release profile: minimize the binary size of the application
#[cfg(not(debug_assertions))]
use panic_abort as _;

// ..</code></pre>
<p>In this example the crate links to the <code>panic-halt</code> crate when built with the dev profile (<code>cargo build</code>), but links to the <code>panic-abort</code> crate when built with the release profile (<code>cargo build --release</code>).</p>
<blockquote>
<p>The <code>use panic_abort as _;</code> form of the <code>use</code> statement is used to ensure the <code>panic_abort</code> panic handler is included in our final executable while making it clear to the compiler that we wonâ€™t explicitly use anything from the crate. Without the <code>as _</code> rename, the compiler would warn that we have an unused import. Sometimes you might see <code>extern crate panic_abort</code> instead, which is an older style used before the 2018 edition of Rust, and should now only be used for â€œsysrootâ€ crates (those distributed with Rust itself) such as <code>proc_macro</code>, <code>alloc</code>, <code>std</code>, and <code>test</code>.</p>
</blockquote>
<h2 id="an-example"><a class="header" href="#an-example">An example</a></h2>
<p>Hereâ€™s an example that tries to index an array beyond its length. The operation results in a panic.</p>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

use panic_semihosting as _;

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    let xs = [0, 1, 2];
    let i = xs.len();
    let _y = xs[i]; // out of bounds access

    loop {}
}</code></pre>
<p>This example chose the <code>panic-semihosting</code> behavior which prints the panic message to the host console using semihosting.</p>
<pre><code class="language-text">$ cargo run
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb (..)
panicked at 'index out of bounds: the len is 3 but the index is 4', src/main.rs:12:13
</code></pre>
<p>You can try changing the behavior to <code>panic-halt</code> and confirm that no message is printed in that case.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ä¾‹å¤–"><a class="header" href="#ä¾‹å¤–">ä¾‹å¤–</a></h1>
<p>Exceptions, and interrupts, are a hardware mechanism by which the processor handles asynchronous events and fatal errors (e.g. executing an invalid instruction). Exceptions imply preemption and involve exception handlers, subroutines executed in response to the signal that triggered the event.</p>
<p>The <code>cortex-m-rt</code> crate provides an <a href="https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.exception.html"><code>exception</code></a> attribute to declare exception handlers.</p>
<pre><code class="language-rust ignore">// Exception handler for the SysTick (System Timer) exception
#[exception]
fn SysTick() {
    // ..
}</code></pre>
<p>Other than the <code>exception</code> attribute exception handlers look like plain functions but thereâ€™s one more difference: <code>exception</code> handlers can <em>not</em> be called by software. Following the previous example, the statement <code>SysTick();</code> would result in a compilation error.</p>
<p>This behavior is pretty much intended and itâ€™s required to provide a feature: <code>static mut</code> variables declared <em>inside</em> <code>exception</code> handlers are <em>safe</em> to use.</p>
<pre><code class="language-rust ignore">#[exception]
fn SysTick() {
    static mut COUNT: u32 = 0;

    // `COUNT` has transformed to type `&amp;mut u32` and it's safe to use
    *COUNT += 1;
}</code></pre>
<p>As you may know, using <code>static mut</code> variables in a function makes it <a href="https://en.wikipedia.org/wiki/Reentrancy_(computing)"><em>non-reentrant</em></a>. Itâ€™s undefined behavior to call a non-reentrant function, directly or indirectly, from more than one exception / interrupt handler or from <code>main</code> and one or more exception / interrupt handlers.</p>
<p>Safe Rust must never result in undefined behavior so non-reentrant functions must be marked as <code>unsafe</code>. Yet I just told that <code>exception</code> handlers can safely use <code>static mut</code> variables. How is this possible? This is possible because <code>exception</code> handlers can <em>not</em> be called by software thus reentrancy is not possible. These handlers are called by the hardware itself which is assumed to be physically non-concurrent.</p>
<p>As a result, in the context of exception handlers in embedded systems, the absence of concurrent invocations of the same handler ensures that there are no reentrancy issues, even if the handler uses static mutable variables.</p>
<p>In a multicore system, where multiple processor cores are executing code concurrently, the potential for reentrancy issues becomes relevant again, even within exception handlers. While each core may have its own set of exception handlers, there can still be scenarios where multiple cores attempt to execute the same exception handler simultaneously.<br>To address this concern in a multicore environment, proper synchronization mechanisms need to be employed within the exception handlers to ensure that access to shared resources is properly coordinated among the cores. This typically involves the use of techniques such as locks, semaphores, or atomic operations to prevent data races and maintain data integrity</p>
<blockquote>
<p>Note that the <code>exception</code> attribute transforms definitions of static variables inside the function by wrapping them into <code>unsafe</code> blocks and providing us with new appropriate variables of type <code>&amp;mut</code> of the same name. Thus we can dereference the reference via <code>*</code> to access the values of the variables without needing to wrap them in an <code>unsafe</code> block.</p>
</blockquote>
<h2 id="a-complete-example"><a class="header" href="#a-complete-example">A complete example</a></h2>
<p>Hereâ€™s an example that uses the system timer to raise a <code>SysTick</code> exception roughly every second. The <code>SysTick</code> exception handler keeps track of how many times it has been called in the <code>COUNT</code> variable and then prints the value of <code>COUNT</code> to the host console using semihosting.</p>
<blockquote>
<p><strong>NOTE</strong>: You can run this example on any Cortex-M device; you can also run it on QEMU</p>
</blockquote>
<pre><code class="language-rust ignore">#![deny(unsafe_code)]
#![no_main]
#![no_std]

use panic_halt as _;

use core::fmt::Write;

use cortex_m::peripheral::syst::SystClkSource;
use cortex_m_rt::{entry, exception};
use cortex_m_semihosting::{
    debug,
    hio::{self, HostStream},
};

#[entry]
fn main() -&gt; ! {
    let p = cortex_m::Peripherals::take().unwrap();
    let mut syst = p.SYST;

    // configures the system timer to trigger a SysTick exception every second
    syst.set_clock_source(SystClkSource::Core);
    // this is configured for the LM3S6965 which has a default CPU clock of 12 MHz
    syst.set_reload(12_000_000);
    syst.clear_current();
    syst.enable_counter();
    syst.enable_interrupt();

    loop {}
}

#[exception]
fn SysTick() {
    static mut COUNT: u32 = 0;
    static mut STDOUT: Option&lt;HostStream&gt; = None;

    *COUNT += 1;

    // Lazy initialization
    if STDOUT.is_none() {
        *STDOUT = hio::hstdout().ok();
    }

    if let Some(hstdout) = STDOUT.as_mut() {
        write!(hstdout, "{}", *COUNT).ok();
    }

    // IMPORTANT omit this `if` block if running on real hardware or your
    // debugger will end in an inconsistent state
    if *COUNT == 9 {
        // This will terminate the QEMU process
        debug::exit(debug::EXIT_SUCCESS);
    }
}</code></pre>
<pre><code class="language-console">tail -n5 Cargo.toml
</code></pre>
<pre><code class="language-toml">[dependencies]
cortex-m = "0.5.7"
cortex-m-rt = "0.6.3"
panic-halt = "0.2.0"
cortex-m-semihosting = "0.3.1"
</code></pre>
<pre><code class="language-text">$ cargo run --release
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb (..)
123456789
</code></pre>
<p>If you run this on the Discovery board youâ€™ll see the output on the OpenOCD console. Also, the program will <em>not</em> stop when the count reaches 9.</p>
<h2 id="the-default-exception-handler"><a class="header" href="#the-default-exception-handler">The default exception handler</a></h2>
<p>What the <code>exception</code> attribute actually does is <em>override</em> the default exception handler for a specific exception. If you donâ€™t override the handler for a particular exception it will be handled by the <code>DefaultHandler</code> function, which defaults to:</p>
<pre><code class="language-rust ignore">fn DefaultHandler() {
    loop {}
}</code></pre>
<p>This function is provided by the <code>cortex-m-rt</code> crate and marked as <code>#[no_mangle]</code> so you can put a breakpoint on â€œDefaultHandlerâ€ and catch <em>unhandled</em> exceptions.</p>
<p>Itâ€™s possible to override this <code>DefaultHandler</code> using the <code>exception</code> attribute:</p>
<pre><code class="language-rust ignore">#[exception]
fn DefaultHandler(irqn: i16) {
    // custom default handler
}</code></pre>
<p>The <code>irqn</code> argument indicates which exception is being serviced. A negative value indicates that a Cortex-M exception is being serviced; and zero or a positive value indicate that a device specific exception, AKA interrupt, is being serviced.</p>
<h2 id="the-hard-fault-handler"><a class="header" href="#the-hard-fault-handler">The hard fault handler</a></h2>
<p>The <code>HardFault</code> exception is a bit special. This exception is fired when the program enters an invalid state so its handler can <em>not</em> return as that could result in undefined behavior. Also, the runtime crate does a bit of work before the user defined <code>HardFault</code> handler is invoked to improve debuggability.</p>
<p>The result is that the <code>HardFault</code> handler must have the following signature: <code>fn(&amp;ExceptionFrame) -&gt; !</code>. The argument of the handler is a pointer to registers that were pushed into the stack by the exception. These registers are a snapshot of the processor state at the moment the exception was triggered and are useful to diagnose a hard fault.</p>
<p>Hereâ€™s an example that performs an illegal operation: a read to a nonexistent memory location.</p>
<blockquote>
<p><strong>NOTE</strong>: This program wonâ€™t work, i.e. it wonâ€™t crash, on QEMU because <code>qemu-system-arm -machine lm3s6965evb</code> doesnâ€™t check memory loads and will happily return <code>0 </code>on reads to invalid memory.</p>
</blockquote>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

use panic_halt as _;

use core::fmt::Write;
use core::ptr;

use cortex_m_rt::{entry, exception, ExceptionFrame};
use cortex_m_semihosting::hio;

#[entry]
fn main() -&gt; ! {
    // read a nonexistent memory location
    unsafe {
        ptr::read_volatile(0x3FFF_0000 as *const u32);
    }

    loop {}
}

#[exception]
fn HardFault(ef: &amp;ExceptionFrame) -&gt; ! {
    if let Ok(mut hstdout) = hio::hstdout() {
        writeln!(hstdout, "{:#?}", ef).ok();
    }

    loop {}
}</code></pre>
<p>The <code>HardFault</code> handler prints the <code>ExceptionFrame</code> value. If you run this youâ€™ll see something like this on the OpenOCD console.</p>
<pre><code class="language-text">$ openocd
(..)
ExceptionFrame {
    r0: 0x3fff0000,
    r1: 0x00000003,
    r2: 0x080032e8,
    r3: 0x00000000,
    r12: 0x00000000,
    lr: 0x080016df,
    pc: 0x080016e2,
    xpsr: 0x61000000,
}
</code></pre>
<p>The <code>pc</code> value is the value of the Program Counter at the time of the exception and it points to the instruction that triggered the exception.</p>
<p>If you look at the disassembly of the program:</p>
<pre><code class="language-text">$ cargo objdump --bin app --release -- -d --no-show-raw-insn --print-imm-hex
(..)
ResetTrampoline:
 8000942:       movw    r0, #0xfffe
 8000946:       movt    r0, #0x3fff
 800094a:       ldr     r0, [r0]
 800094c:       b       #-0x4 &lt;ResetTrampoline+0xa&gt;
</code></pre>
<p>You can lookup the value of the program counter <code>0x0800094a</code> in the disassembly. Youâ€™ll see that a load operation (<code>ldr r0, [r0]</code> ) caused the exception. The <code>r0</code> field of <code>ExceptionFrame</code> will tell you the value of register <code>r0</code> was <code>0x3fff_fffe</code> at that time.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ä¸­æ–·"><a class="header" href="#ä¸­æ–·">ä¸­æ–·</a></h1>
<p>Interrupts differ from exceptions in a variety of ways but their operation and use is largely similar and they are also handled by the same interrupt controller. Whereas exceptions are defined by the Cortex-M architecture, interrupts are always vendor (and often even chip) specific implementations, both in naming and functionality.</p>
<p>Interrupts do allow for a lot of flexibility which needs to be accounted for when attempting to use them in an advanced way. We will not cover those uses in this book, however it is a good idea to keep the following in mind:</p>
<ul>
<li>Interrupts have programmable priorities which determine their handlersâ€™ execution order</li>
<li>Interrupts can nest and preempt, i.e. execution of an interrupt handler might be interrupted by another higher-priority interrupt</li>
<li>In general the reason causing the interrupt to trigger needs to be cleared to prevent re-entering the interrupt handler endlessly</li>
</ul>
<p>The general initialization steps at runtime are always the same:</p>
<ul>
<li>Setup the peripheral(s) to generate interrupts requests at the desired occasions</li>
<li>Set the desired priority of the interrupt handler in the interrupt controller</li>
<li>Enable the interrupt handler in the interrupt controller</li>
</ul>
<p>Similarly to exceptions, the cortex-m-rt crate exposes an <a href="https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/attr.interrupt.html"><code>interrupt</code></a> attribute for declaring interrupt handlers. However, this attribute is only available when the device feature is enabled. That said, this attribute is not intended to be used directlyâ€”doing so will result in a compilation error.</p>
<p>Instead, you should use the re-exported version of the interrupt attribute provided by the device crate (usually generated using svd2rust). This ensures that the compiler can verify that the interrupt actually exists on the target device. The list of available interruptsâ€”and their position in the interrupt vector tableâ€”is typically auto-generated from an SVD file by svd2rust.</p>
<pre><code class="language-rust ignore">use lm3s6965::interrupt; // Re-exported attribute from the device crate

// Interrupt handler for the Timer2 interrupt
#[interrupt]
fn TIMER2A() {
    // ..
    // Clear reason for the generated interrupt request
}</code></pre>
<p>Interrupt handlers look like plain functions (except for the lack of arguments) similar to exception handlers. However they can not be called directly by other parts of the firmware due to the special calling conventions. It is however possible to generate interrupt requests in software to trigger a diversion to the interrupt handler.</p>
<p>Similar to exception handlers it is also possible to declare <code>static mut</code> variables inside the interrupt handlers for <em>safe</em> state keeping.</p>
<pre><code class="language-rust ignore">#[interrupt]
fn TIMER2A() {
    static mut COUNT: u32 = 0;

    // `COUNT` has type `&amp;mut u32` and it's safe to use
    *COUNT += 1;
}</code></pre>
<p>For a more detailed description about the mechanisms demonstrated here please refer to the <a href="#ä¾‹å¤–">exceptions section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="io"><a class="header" href="#io">I/O</a></h1>
<blockquote>
<p><strong>TODO</strong> Cover memory mapped I/O using registers.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="å‘¨é‚Š"><a class="header" href="#å‘¨é‚Š">å‘¨é‚Š</a></h1>
<h2 id="ä»€éº¼æ˜¯å‘¨é‚Š"><a class="header" href="#ä»€éº¼æ˜¯å‘¨é‚Š">ä»€éº¼æ˜¯å‘¨é‚Šï¼Ÿ</a></h2>
<p>å¤šæ•¸å¾®æ§åˆ¶å™¨ä¸åªæœ‰ CPUã€RAM æˆ–å¿«é–ƒè¨˜æ†¶é«”ï¼Œé‚„åŒ…å«ç”¨æ–¼èˆ‡å¾®æ§åˆ¶å™¨å¤–éƒ¨ç³»çµ±äº’å‹•çš„çŸ½å€å¡Šï¼Œä¹Ÿæœƒé€éæ„Ÿæ¸¬å™¨ã€é¦¬é”æ§åˆ¶å™¨æˆ–é¡¯ç¤ºå™¨ã€éµç›¤ç­‰äººæ©Ÿä»‹é¢ï¼Œç›´æ¥æˆ–é–“æ¥åœ°èˆ‡å‘¨é­ç’°å¢ƒäº’å‹•ã€‚é€™äº›å…ƒä»¶çµ±ç¨±ç‚ºå‘¨é‚Šã€‚</p>
<p>é€™äº›å‘¨é‚Šä¹‹æ‰€ä»¥æœ‰ç”¨ï¼Œæ˜¯å› ç‚ºå®ƒå€‘è®“é–‹ç™¼è€…å¯ä»¥æŠŠè™•ç†å·¥ä½œå¸è¼‰çµ¦å‘¨é‚Šï¼Œé¿å…æ‰€æœ‰äº‹éƒ½ç”±è»Ÿé«”è™•ç†ã€‚å°±åƒæ¡Œé¢é–‹ç™¼è€…æœƒæŠŠåœ–å½¢è™•ç†äº¤çµ¦é¡¯ç¤ºå¡ä¸€æ¨£ï¼ŒåµŒå…¥å¼é–‹ç™¼è€…å¯æŠŠæŸäº›å·¥ä½œäº¤çµ¦å‘¨é‚Šï¼Œè®“ CPU å¯ä»¥å»åšæ›´é‡è¦çš„äº‹ï¼Œæˆ–ä¸åšäº‹ä»¥ç¯€çœåŠŸè€—ã€‚</p>
<p>å¦‚æœä½ çœ‹çœ‹ 1970 æˆ– 1980 å¹´ä»£è€å¼å®¶ç”¨é›»è…¦çš„ä¸»æ©Ÿæ¿ï¼ˆå…¶å¯¦æ˜¨æ—¥çš„æ¡Œæ©Ÿèˆ‡ä»Šæ—¥çš„åµŒå…¥å¼ç³»çµ±ä¸¦æ²’æœ‰å¤ªå¤§å·®åˆ¥ï¼‰ï¼Œä½ å¤§æ¦‚æœƒçœ‹åˆ°ï¼š</p>
<ul>
<li>è™•ç†å™¨</li>
<li>RAM æ™¶ç‰‡</li>
<li>ROM æ™¶ç‰‡</li>
<li>I/O æ§åˆ¶å™¨</li>
</ul>
<p>RAM æ™¶ç‰‡ã€ROM æ™¶ç‰‡èˆ‡ I/O æ§åˆ¶å™¨ï¼ˆæ­¤ç³»çµ±ä¸­çš„å‘¨é‚Šï¼‰æœƒé€éä¸€çµ„ç¨±ç‚ºã€ŒåŒ¯æµæ’ã€çš„å¹³è¡Œç·šè·¯é€£æ¥åˆ°è™•ç†å™¨ã€‚åŒ¯æµæ’è² è²¬æ”œå¸¶ä½å€è³‡è¨Šï¼Œç”¨ä»¥é¸æ“‡è™•ç†å™¨æƒ³è¦æºé€šçš„è£ç½®ï¼›ä»¥åŠè³‡æ–™åŒ¯æµæ’ï¼Œç”¨ä»¥å‚³è¼¸å¯¦éš›è³‡æ–™ã€‚åœ¨åµŒå…¥å¼å¾®æ§åˆ¶å™¨ä¸­ï¼ŒåŒæ¨£çš„åŸç†é©ç”¨â€”â€”åªæ˜¯æ‰€æœ‰æ±è¥¿éƒ½è¢«å°è£åœ¨åŒä¸€å¡ŠçŸ½æ™¶ç‰‡ä¸Šã€‚</p>
<p>ç„¶è€Œï¼Œä¸åŒæ–¼é€šå¸¸æœ‰ Vulkanã€Metal æˆ– OpenGL ç­‰è»Ÿé«” API çš„é¡¯ç¤ºå¡ï¼Œå‘¨é‚Šæœƒä»¥ç¡¬é«”ä»‹é¢å‘ˆç¾çµ¦å¾®æ§åˆ¶å™¨ï¼Œä¸¦å°æ˜ åˆ°ä¸€æ®µè¨˜æ†¶é«”ã€‚</p>
<h2 id="ç·šæ€§èˆ‡å¯¦é«”è¨˜æ†¶é«”ç©ºé–“"><a class="header" href="#ç·šæ€§èˆ‡å¯¦é«”è¨˜æ†¶é«”ç©ºé–“">ç·šæ€§èˆ‡å¯¦é«”è¨˜æ†¶é«”ç©ºé–“</a></h2>
<p>åœ¨å¾®æ§åˆ¶å™¨ä¸Šï¼Œå°‡è³‡æ–™å¯«å…¥å…¶ä»–ä»»æ„ä½å€ï¼ˆå¦‚ <code>0x4000_0000</code> æˆ– <code>0x0000_0000</code>ï¼‰å¯èƒ½ä¹Ÿæ˜¯å®Œå…¨åˆæ³•çš„å‹•ä½œã€‚</p>
<p>åœ¨æ¡Œé¢ç³»çµ±ä¸Šï¼Œè¨˜æ†¶é«”å­˜å–ç”± MMUï¼ˆMemory Management Unitï¼‰åš´æ ¼æ§åˆ¶ã€‚æ­¤å…ƒä»¶æœ‰å…©é …ä¸»è¦è²¬ä»»ï¼šå¼·åˆ¶è¨˜æ†¶é«”å€æ®µçš„å­˜å–æ¬Šé™ï¼ˆé˜²æ­¢æŸè¡Œç¨‹è®€å–æˆ–ä¿®æ”¹å¦ä¸€è¡Œç¨‹çš„è¨˜æ†¶é«”ï¼‰ï¼›ä»¥åŠå°‡å¯¦é«”è¨˜æ†¶é«”å€æ®µé‡æ–°å°æ˜ åˆ°è»Ÿé«”ä½¿ç”¨çš„è™›æ“¬è¨˜æ†¶é«”ç¯„åœã€‚å¾®æ§åˆ¶å™¨é€šå¸¸æ²’æœ‰ MMUï¼Œè€Œæ˜¯åªåœ¨è»Ÿé«”ä¸­ä½¿ç”¨å¯¦é«”ä½å€ã€‚</p>
<p>é›–ç„¶ 32 ä½å…ƒå¾®æ§åˆ¶å™¨æ“æœ‰å¾ <code>0x0000_0000</code> åˆ° <code>0xFFFF_FFFF</code> çš„å¯¦é«”ç·šæ€§ä½å€ç©ºé–“ï¼Œä½†å¯¦éš›è¨˜æ†¶é«”é€šå¸¸åªä½¿ç”¨å…¶ä¸­å¹¾ç™¾ KBï¼Œç•™ä¸‹å¤§é‡ä½å€ç©ºé–“ã€‚å‰é¢ç« ç¯€æåˆ° RAM ä½æ–¼ <code>0x2000_0000</code>ã€‚è‹¥ RAM ç‚º 64 KiBï¼ˆæœ€å¤§ä½å€ 0xFFFFï¼‰ï¼Œé‚£éº¼ <code>0x2000_0000</code> åˆ° <code>0x2000_FFFF</code> å°±å°æ‡‰åˆ° RAMã€‚ç•¶æˆ‘å€‘å¯«å…¥ä½æ–¼ <code>0x2000_1234</code> çš„è®Šæ•¸æ™‚ï¼Œå…§éƒ¨æœƒæœ‰é‚è¼¯åµæ¸¬ä½å€é«˜ä½ï¼ˆæ­¤ä¾‹ç‚º 0x2000ï¼‰ï¼Œä¸¦å•Ÿç”¨ RAM ä»¥è™•ç†ä½ä½å€éƒ¨åˆ†ï¼ˆæ­¤ä¾‹ç‚º 0x1234ï¼‰ã€‚åœ¨ Cortex-M ä¸Šï¼ŒFlash ROM ä¹Ÿæœƒå°æ˜ åœ¨ <code>0x0000_0000</code> åˆ°ä¾‹å¦‚ <code>0x0007_FFFF</code>ï¼ˆè‹¥æœ‰ 512 KiB Flash ROMï¼‰ã€‚å¾®æ§åˆ¶å™¨è¨­è¨ˆè€…ä¸æœƒå¿½ç•¥é€™å…©å€‹å€åŸŸä¹‹é–“çš„ç©ºé–“ï¼Œè€Œæ˜¯æŠŠå‘¨é‚Šçš„ä»‹é¢å°æ˜ åˆ°ç‰¹å®šä½å€ï¼Œçµæœçœ‹èµ·ä¾†åƒé€™æ¨£ï¼š</p>
<p><img src="assets/nrf52-memory-map.png" alt=""></p>
<p><a href="http://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.1.pdf">Nordic nRF52832 è¦æ ¼æ›¸ï¼ˆpdfï¼‰</a></p>
<h2 id="è¨˜æ†¶é«”å°æ˜ å‘¨é‚Š"><a class="header" href="#è¨˜æ†¶é«”å°æ˜ å‘¨é‚Š">è¨˜æ†¶é«”å°æ˜ å‘¨é‚Š</a></h2>
<p>ä¹çœ‹ä¹‹ä¸‹ï¼Œèˆ‡é€™äº›å‘¨é‚Šäº’å‹•å¾ˆç°¡å–®â€”â€”æŠŠæ­£ç¢ºè³‡æ–™å¯«åˆ°æ­£ç¢ºä½å€ã€‚ä¾‹å¦‚ï¼Œé€éåºåˆ—åŸ é€å‡ºä¸€å€‹ 32 ä½å…ƒå­—ï¼Œå¯èƒ½å°±åªæ˜¯å°‡è©² 32 ä½å…ƒå­—å¯«å…¥æŸå€‹è¨˜æ†¶é«”ä½å€ã€‚åºåˆ—åŸ å‘¨é‚Šæœƒæ¥æ‰‹ä¸¦è‡ªå‹•é€å‡ºè³‡æ–™ã€‚</p>
<p>å‘¨é‚Šçš„è¨­å®šæ–¹å¼ä¹Ÿé¡ä¼¼ã€‚ä¸æ˜¯å‘¼å«å‡½å¼ä¾†è¨­å®šå‘¨é‚Šï¼Œè€Œæ˜¯æœ‰ä¸€å¡Šè¨˜æ†¶é«”ä½œç‚ºç¡¬é«” APIã€‚æŠŠ <code>0x8000_0000</code> å¯«åˆ° SPI é »ç‡è¨­å®šæš«å­˜å™¨ï¼ŒSPI å°±æœƒä»¥ 8 Mbps å‚³è¼¸ï¼›æŠŠ <code>0x0200_0000</code> å¯«åˆ°åŒä¸€ä½å€ï¼ŒSPI å°±æœƒä»¥ 125 Kbps å‚³è¼¸ã€‚é€™äº›è¨­å®šæš«å­˜å™¨çœ‹èµ·ä¾†åƒé€™æ¨£ï¼š</p>
<p><img src="assets/nrf52-spi-frequency-register.png" alt=""></p>
<p><a href="http://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.1.pdf">Nordic nRF52832 è¦æ ¼æ›¸ï¼ˆpdfï¼‰</a></p>
<p>ä¸è«–ä½¿ç”¨ä½•ç¨®èªè¨€ï¼ˆçµ„åˆèªè¨€ã€C æˆ– Rustï¼‰ï¼Œéƒ½å¿…é ˆé€éæ­¤ä»‹é¢èˆ‡ç¡¬é«”äº’å‹•ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="a-first-attempt"><a class="header" href="#a-first-attempt">A First Attempt</a></h1>
<h2 id="the-registers"><a class="header" href="#the-registers">The Registers</a></h2>
<p>Letâ€™s look at the â€˜SysTickâ€™ peripheral - a simple timer which comes with every Cortex-M processor core. Typically youâ€™ll be looking these up in the chip manufacturerâ€™s data sheet or <em>Technical Reference Manual</em>, but this example is common to all ARM Cortex-M cores, letâ€™s look in the <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/Babieigh.html">ARM reference manual</a>. We see there are four registers:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Offset</th><th>Name</th><th>æè¿°</th><th>Width</th></tr>
</thead>
<tbody>
<tr><td>0x00</td><td>SYST_CSR</td><td>Control and Status Register</td><td>32 bits</td></tr>
<tr><td>0x04</td><td>SYST_RVR</td><td>Reload Value Register</td><td>32 bits</td></tr>
<tr><td>0x08</td><td>SYST_CVR</td><td>Current Value Register</td><td>32 bits</td></tr>
<tr><td>0x0C</td><td>SYST_CALIB</td><td>Calibration Value Register</td><td>32 bits</td></tr>
</tbody>
</table>
</div>
<h2 id="the-c-approach"><a class="header" href="#the-c-approach">The C Approach</a></h2>
<p>In Rust, we can represent a collection of registers in exactly the same way as we do in C - with a <code>struct</code>.</p>
<pre><code class="language-rust ignore">#[repr(C)]
struct SysTick {
    pub csr: u32,
    pub rvr: u32,
    pub cvr: u32,
    pub calib: u32,
}</code></pre>
<p>The qualifier <code>#[repr(C)]</code> tells the Rust compiler to lay this structure out like a C compiler would. Thatâ€™s very important, as Rust allows structure fields to be re-ordered, while C does not. You can imagine the debugging weâ€™d have to do if these fields were silently re-arranged by the compiler! With this qualifier in place, we have our four 32-bit fields which correspond to the table above. But of course, this <code>struct</code> is of no use by itself - we need a variable.</p>
<pre><code class="language-rust ignore">let systick = 0xE000_E010 as *mut SysTick;
let time = unsafe { (*systick).cvr };</code></pre>
<h2 id="volatile-accesses"><a class="header" href="#volatile-accesses">Volatile Accesses</a></h2>
<p>Now, there are a couple of problems with the approach above.</p>
<ol>
<li>We have to use unsafe every time we want to access our Peripheral.</li>
<li>Weâ€™ve got no way of specifying which registers are read-only or read-write.</li>
<li>Any piece of code anywhere in your program could access the hardware through this structure.</li>
<li>Most importantly, it doesnâ€™t actually workâ€¦</li>
</ol>
<p>Now, the problem is that compilers are clever. If you make two writes to the same piece of RAM, one after the other, the compiler can notice this and just skip the first write entirely. In C, we can mark variables as <code>volatile</code> to ensure that every read or write occurs as intended. In Rust, we instead mark the <em>accesses</em> as volatile, not the variable.</p>
<pre><code class="language-rust ignore">let systick = unsafe { &amp;mut *(0xE000_E010 as *mut SysTick) };
let time = unsafe { core::ptr::read_volatile(&amp;mut systick.cvr) };</code></pre>
<p>So, weâ€™ve fixed one of our four problems, but now we have even more <code>unsafe</code> code! Fortunately, thereâ€™s a third party crate which can help - <a href="https://crates.io/crates/volatile_register"><code>volatile_register</code></a>.</p>
<pre><code class="language-rust ignore">use volatile_register::{RW, RO};

#[repr(C)]
struct SysTick {
    pub csr: RW&lt;u32&gt;,
    pub rvr: RW&lt;u32&gt;,
    pub cvr: RW&lt;u32&gt;,
    pub calib: RO&lt;u32&gt;,
}

fn get_systick() -&gt; &amp;'static mut SysTick {
    unsafe { &amp;mut *(0xE000_E010 as *mut SysTick) }
}

fn get_time() -&gt; u32 {
    let systick = get_systick();
    systick.cvr.read()
}</code></pre>
<p>Now, the volatile accesses are performed automatically through the <code>read</code> and <code>write</code> methods. Itâ€™s still <code>unsafe</code> to perform writes, but to be fair, hardware is a bunch of mutable state and thereâ€™s no way for the compiler to know whether these writes are actually safe, so this is a good default position.</p>
<h2 id="the-rusty-wrapper"><a class="header" href="#the-rusty-wrapper">The Rusty Wrapper</a></h2>
<p>We need to wrap this <code>struct</code> up into a higher-layer API that is safe for our users to call. As the driver author, we manually verify the unsafe code is correct, and then present a safe API for our users so they donâ€™t have to worry about it (provided they trust us to get it right!).</p>
<p>One example might be:</p>
<pre><code class="language-rust ignore">use volatile_register::{RW, RO};

pub struct SystemTimer {
    p: &amp;'static mut RegisterBlock
}

#[repr(C)]
struct RegisterBlock {
    pub csr: RW&lt;u32&gt;,
    pub rvr: RW&lt;u32&gt;,
    pub cvr: RW&lt;u32&gt;,
    pub calib: RO&lt;u32&gt;,
}

impl SystemTimer {
    pub fn new() -&gt; SystemTimer {
        SystemTimer {
            p: unsafe { &amp;mut *(0xE000_E010 as *mut RegisterBlock) }
        }
    }

    pub fn get_time(&amp;self) -&gt; u32 {
        self.p.cvr.read()
    }

    pub fn set_reload(&amp;mut self, reload_value: u32) {
        unsafe { self.p.rvr.write(reload_value) }
    }
}

pub fn example_usage() -&gt; String {
    let mut st = SystemTimer::new();
    st.set_reload(0x00FF_FFFF);
    format!("Time is now 0x{:08x}", st.get_time())
}</code></pre>
<p>Now, the problem with this approach is that the following code is perfectly acceptable to the compiler:</p>
<pre><code class="language-rust ignore">fn thread1() {
    let mut st = SystemTimer::new();
    st.set_reload(2000);
}

fn thread2() {
    let mut st = SystemTimer::new();
    st.set_reload(1000);
}</code></pre>
<p>Our <code>&amp;mut self</code> argument to the <code>set_reload</code> function checks that there are no other references to <em>that</em> particular <code>SystemTimer</code> struct, but they donâ€™t stop the user creating a second <code>SystemTimer</code> which points to the exact same peripheral! Code written in this fashion will work if the author is diligent enough to spot all of these â€˜duplicateâ€™ driver instances, but once the code is spread out over multiple modules, drivers, developers, and days, it gets easier and easier to make these kinds of mistakes.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="å€Ÿç”¨æª¢æŸ¥å™¨-1"><a href="#å€Ÿç”¨æª¢æŸ¥å™¨-1" class="header">å€Ÿç”¨æª¢æŸ¥å™¨</a></h1>
<h2 id="mutable-global-state"><a class="header" href="#mutable-global-state">Mutable Global State</a></h2>
<p>Unfortunately, hardware is basically nothing but mutable global state, which can feel very frightening for a Rust developer. Hardware exists independently from the structures of the code we write, and can be modified at any time by the real world.</p>
<h2 id="what-should-our-rules-be"><a class="header" href="#what-should-our-rules-be">What should our rules be?</a></h2>
<p>How can we reliably interact with these peripherals?</p>
<ol>
<li>Always use <code>volatile</code> methods to read or write to peripheral memory, as it can change at any time</li>
<li>In software, we should be able to share any number of read-only accesses to these peripherals</li>
<li>If some software should have read-write access to a peripheral, it should hold the only reference to that peripheral</li>
</ol>
<h2 id="å€Ÿç”¨æª¢æŸ¥å™¨"><a class="header" href="#å€Ÿç”¨æª¢æŸ¥å™¨">å€Ÿç”¨æª¢æŸ¥å™¨</a></h2>
<p>The last two of these rules sound suspiciously similar to what the Borrow Checker does already!</p>
<p>Imagine if we could pass around ownership of these peripherals, or offer immutable or mutable references to them?</p>
<p>Well, we can, but for the Borrow Checker, we need to have exactly one instance of each peripheral, so Rust can handle this correctly. Well, luckily in the hardware, there is only one instance of any given peripheral, but how can we expose that in the structure of our code?</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="å–®ä¾‹"><a class="header" href="#å–®ä¾‹">å–®ä¾‹</a></h1>
<blockquote>
<p>In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one object.</p>
<p><em>Wikipedia: <a href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton Pattern</a></em></p>
</blockquote>
<h2 id="but-why-cant-we-just-use-global-variables"><a class="header" href="#but-why-cant-we-just-use-global-variables">But why canâ€™t we just use global variable(s)?</a></h2>
<p>We could make everything a public static, like this</p>
<pre><code class="language-rust ignore">static mut THE_SERIAL_PORT: SerialPort = SerialPort;

fn main() {
    let _ = unsafe {
        THE_SERIAL_PORT.read_speed();
    };
}</code></pre>
<p>But this has a few problems. It is a mutable global variable, and in Rust, these are always unsafe to interact with. These variables are also visible across your whole program, which means the borrow checker is unable to help you track references and ownership of these variables.</p>
<h2 id="how-do-we-do-this-in-rust"><a class="header" href="#how-do-we-do-this-in-rust">How do we do this in Rust?</a></h2>
<p>Instead of just making our peripheral a global variable, we might instead decide to make a structure, in this case called <code>PERIPHERALS</code>, which contains an <code>Option&lt;T&gt;</code> for each of our peripherals.</p>
<pre><code class="language-rust ignore">struct Peripherals {
    serial: Option&lt;SerialPort&gt;,
}
impl Peripherals {
    fn take_serial(&amp;mut self) -&gt; SerialPort {
        let p = replace(&amp;mut self.serial, None);
        p.unwrap()
    }
}
static mut PERIPHERALS: Peripherals = Peripherals {
    serial: Some(SerialPort),
};</code></pre>
<p>This structure allows us to obtain a single instance of our peripheral. If we try to call <code>take_serial()</code> more than once, our code will panic!</p>
<pre><code class="language-rust ignore">fn main() {
    let serial_1 = unsafe { PERIPHERALS.take_serial() };
    // This panics!
    // let serial_2 = unsafe { PERIPHERALS.take_serial() };
}</code></pre>
<p>Although interacting with this structure is <code>unsafe</code>, once we have the <code>SerialPort</code> it contained, we no longer need to use <code>unsafe</code>, or the <code>PERIPHERALS</code> structure at all.</p>
<p>This has a small runtime overhead because we must wrap the <code>SerialPort</code> structure in an option, and weâ€™ll need to call <code>take_serial()</code> once, however this small up-front cost allows us to leverage the borrow checker throughout the rest of our program.</p>
<h2 id="existing-library-support"><a class="header" href="#existing-library-support">Existing library support</a></h2>
<p>Although we created our own <code>Peripherals</code> structure above, it is not necessary to do this for your code. the <code>cortex_m</code> crate contains a macro called <code>singleton!()</code> that will perform this action for you.</p>
<pre><code class="language-rust ignore">use cortex_m::singleton;

fn main() {
    // OK if `main` is executed only once
    let x: &amp;'static mut bool =
        singleton!(: bool = false).unwrap();
}</code></pre>
<p><a href="https://docs.rs/cortex-m/latest/cortex_m/macro.singleton.html">cortex_m docs</a></p>
<p>Additionally, if you use <a href="https://github.com/rtic-rs/cortex-m-rtic"><code>cortex-m-rtic</code></a>, the entire process of defining and obtaining these peripherals are abstracted for you, and you are instead handed a <code>Peripherals</code> structure that contains a non-<code>Option&lt;T&gt;</code> version of all of the items you define.</p>
<pre><code class="language-rust ignore">// cortex-m-rtic v0.5.x
#[rtic::app(device = lm3s6965, peripherals = true)]
const APP: () = {
    #[init]
    fn init(cx: init::Context) {
        static mut X: u32 = 0;
         
        // Cortex-M peripherals
        let core: cortex_m::Peripherals = cx.core;
        
        // Device specific peripherals
        let device: lm3s6965::Peripherals = cx.device;
    }
}</code></pre>
<h2 id="but-why"><a class="header" href="#but-why">But why?</a></h2>
<p>But how do these Singletons make a noticeable difference in how our Rust code works?</p>
<pre><code class="language-rust ignore">impl SerialPort {
    const SER_PORT_SPEED_REG: *mut u32 = 0x4000_1000 as _;

    fn read_speed(
        &amp;self // &lt;------ This is really, really important
    ) -&gt; u32 {
        unsafe {
            ptr::read_volatile(Self::SER_PORT_SPEED_REG)
        }
    }
}</code></pre>
<p>There are two important factors in play here:</p>
<ul>
<li>Because we are using a singleton, there is only one way or place to obtain a <code>SerialPort</code> structure</li>
<li>To call the <code>read_speed()</code> method, we must have ownership or a reference to a <code>SerialPort</code> structure</li>
</ul>
<p>These two factors put together means that it is only possible to access the hardware if we have appropriately satisfied the borrow checker, meaning that at no point do we have multiple mutable references to the same hardware!</p>
<pre><code class="language-rust ignore">fn main() {
    // missing reference to `self`! Won't work.
    // SerialPort::read_speed();

    let serial_1 = unsafe { PERIPHERALS.take_serial() };

    // you can only read what you have access to
    let _ = serial_1.read_speed();
}</code></pre>
<h2 id="treat-your-hardware-like-data"><a class="header" href="#treat-your-hardware-like-data">Treat your hardware like data</a></h2>
<p>Additionally, because some references are mutable, and some are immutable, it becomes possible to see whether a function or method could potentially modify the state of the hardware. For example,</p>
<p>This is allowed to change hardware settings:</p>
<pre><code class="language-rust ignore">fn setup_spi_port(
    spi: &amp;mut SpiPort,
    cs_pin: &amp;mut GpioPin
) -&gt; Result&lt;()&gt; {
    // ...
}</code></pre>
<p>This isnâ€™t:</p>
<pre><code class="language-rust ignore">fn read_button(gpio: &amp;GpioPin) -&gt; bool {
    // ...
}</code></pre>
<p>This allows us to enforce whether code should or should not make changes to hardware at <strong>compile time</strong>, rather than at runtime. As a note, this generally only works across one application, but for bare metal systems, our software will be compiled into a single application, so this is not usually a restriction.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="éœæ…‹ä¿è­‰"><a class="header" href="#éœæ…‹ä¿è­‰">éœæ…‹ä¿è­‰</a></h1>
<p>Rust çš„å‹åˆ¥ç³»çµ±å¯åœ¨ç·¨è­¯æœŸé˜²æ­¢è³‡æ–™ç«¶çˆ­ï¼ˆè¦‹ <a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code>Send</code></a> èˆ‡ <a href="https://doc.rust-lang.org/core/marker/trait.Sync.html"><code>Sync</code></a> traitsï¼‰ã€‚å‹åˆ¥ç³»çµ±ä¹Ÿå¯ç”¨ä¾†åœ¨ç·¨è­¯æœŸæª¢æŸ¥å…¶ä»–æ€§è³ªï¼Œåœ¨æŸäº›æƒ…æ³ä¸‹æ¸›å°‘åŸ·è¡ŒæœŸæª¢æŸ¥çš„éœ€æ±‚ã€‚</p>
<p>å°‡é€™äº›_éœæ…‹æª¢æŸ¥_æ‡‰ç”¨åœ¨åµŒå…¥å¼ç¨‹å¼æ™‚ï¼Œå¯ç”¨ä¾†å¼·åˆ¶ I/O ä»‹é¢æ­£ç¢ºè¨­å®šã€‚ä¾‹å¦‚ï¼Œå¯ä»¥è¨­è¨ˆä¸€å€‹ APIï¼Œä½¿å¾—å¿…é ˆå…ˆè¨­å®šå°‡è¦ä½¿ç”¨çš„è…³ä½ï¼Œæ‰èƒ½åˆå§‹åŒ–åºåˆ—ä»‹é¢ã€‚</p>
<p>ä¹Ÿå¯åœ¨ç·¨è­¯æœŸæª¢æŸ¥åƒæ˜¯å°‡è…³ä½è¨­ç‚ºä½é›»ä½ç­‰æ“ä½œï¼Œæ˜¯å¦åªèƒ½å°å·²æ­£ç¢ºè¨­å®šçš„å‘¨é‚ŠåŸ·è¡Œã€‚ä¾‹å¦‚ï¼Œå˜—è©¦è®Šæ›´è¢«è¨­å®šç‚ºæµ®å‹•è¼¸å…¥æ¨¡å¼çš„è…³ä½è¼¸å‡ºç‹€æ…‹ï¼Œæœƒç”¢ç”Ÿç·¨è­¯éŒ¯èª¤ã€‚</p>
<p>æ­¤å¤–ï¼Œå¦‚å‰ç« æ‰€ç¤ºï¼Œæ‰€æœ‰æ¬Šæ¦‚å¿µå¯æ‡‰ç”¨æ–¼å‘¨é‚Šï¼Œä»¥ç¢ºä¿åªæœ‰ç¨‹å¼çš„ç‰¹å®šéƒ¨åˆ†èƒ½ä¿®æ”¹å‘¨é‚Šã€‚é€™ç¨®_å­˜å–æ§åˆ¶_ç›¸è¼ƒæ–¼æŠŠå‘¨é‚Šè¦–ç‚ºå…¨åŸŸå¯è®Šç‹€æ…‹ï¼Œæ›´å®¹æ˜“æ¨ç†è»Ÿé«”è¡Œç‚ºã€‚</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="å‹åˆ¥ç‹€æ…‹ç¨‹å¼è¨­è¨ˆ"><a class="header" href="#å‹åˆ¥ç‹€æ…‹ç¨‹å¼è¨­è¨ˆ">å‹åˆ¥ç‹€æ…‹ç¨‹å¼è¨­è¨ˆ</a></h1>
<p>The concept of <a href="https://en.wikipedia.org/wiki/Typestate_analysis">typestates</a> describes the encoding of information about the current state of an object into the type of that object. Although this can sound a little arcane, if you have used the <a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">Builder Pattern</a> in Rust, you have already started using Typestate Programming!</p>
<pre class="playground"><code class="language-rust">pub mod foo_module {
    #[derive(Debug)]
    pub struct Foo {
        inner: u32,
    }

    pub struct FooBuilder {
        a: u32,
        b: u32,
    }

    impl FooBuilder {
        pub fn new(starter: u32) -&gt; Self {
            Self {
                a: starter,
                b: starter,
            }
        }

        pub fn double_a(self) -&gt; Self {
            Self {
                a: self.a * 2,
                b: self.b,
            }
        }

        pub fn into_foo(self) -&gt; Foo {
            Foo {
                inner: self.a + self.b,
            }
        }
    }
}

fn main() {
    let x = foo_module::FooBuilder::new(10)
        .double_a()
        .into_foo();

    println!("{:#?}", x);
}</code></pre>
<p>In this example, there is no direct way to create a <code>Foo</code> object. We must create a <code>FooBuilder</code>, and properly initialize it before we can obtain the <code>Foo</code> object we want.</p>
<p>This minimal example encodes two states:</p>
<ul>
<li><code>FooBuilder</code>, which represents an â€œunconfiguredâ€, or â€œconfiguration in processâ€ state</li>
<li><code>Foo</code>, which represents a â€œconfiguredâ€, or â€œready to useâ€ state.</li>
</ul>
<h2 id="å¼·å‹åˆ¥"><a class="header" href="#å¼·å‹åˆ¥">å¼·å‹åˆ¥</a></h2>
<p>Because Rust has a <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing">Strong Type System</a>, there is no easy way to magically create an instance of <code>Foo</code>, or to turn a <code>FooBuilder</code> into a <code>Foo</code> without calling the <code>into_foo()</code> method. Additionally, calling the <code>into_foo()</code> method consumes the original <code>FooBuilder</code> structure, meaning it can not be reused without the creation of a new instance.</p>
<p>This allows us to represent the states of our system as types, and to include the necessary actions for state transitions into the methods that exchange one type for another. By creating a <code>FooBuilder</code>, and exchanging it for a <code>Foo</code> object, we have walked through the steps of a basic state machine.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="å°‡å‘¨é‚Šè¦–ç‚ºç‹€æ…‹æ©Ÿ"><a class="header" href="#å°‡å‘¨é‚Šè¦–ç‚ºç‹€æ…‹æ©Ÿ">å°‡å‘¨é‚Šè¦–ç‚ºç‹€æ…‹æ©Ÿ</a></h1>
<p>The peripherals of a microcontroller can be thought of as set of state machines. For example, the configuration of a simplified <a href="https://en.wikipedia.org/wiki/General-purpose_input/output">GPIO pin</a> could be represented as the following tree of states:</p>
<ul>
<li>Disabled</li>
<li>Enabled
<ul>
<li>Configured as Output
<ul>
<li>Output: High</li>
<li>Output: Low</li>
</ul>
</li>
<li>Configured as Input
<ul>
<li>Input: High Resistance</li>
<li>Input: Pulled Low</li>
<li>Input: Pulled High</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>If the peripheral starts in the <code>Disabled</code> mode, to move to the <code>Input: High Resistance</code> mode, we must perform the following steps:</p>
<ol>
<li>Disabled</li>
<li>Enabled</li>
<li>Configured as Input</li>
<li>Input: High Resistance</li>
</ol>
<p>If we wanted to move from <code>Input: High Resistance</code> to <code>Input: Pulled Low</code>, we must perform the following steps:</p>
<ol>
<li>Input: High Resistance</li>
<li>Input: Pulled Low</li>
</ol>
<p>Similarly, if we want to move a GPIO pin from configured as <code>Input: Pulled Low</code> to <code>Output: High</code>, we must perform the following steps:</p>
<ol>
<li>Input: Pulled Low</li>
<li>Configured as Input</li>
<li>Configured as Output</li>
<li>Output: High</li>
</ol>
<h2 id="hardware-representation"><a class="header" href="#hardware-representation">Hardware Representation</a></h2>
<p>Typically the states listed above are set by writing values to given registers mapped to a GPIO peripheral. Letâ€™s define an imaginary GPIO Configuration Register to illustrate this:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: right">Name</th><th style="text-align: right">Bit Number(s)</th><th style="text-align: right">Value</th><th style="text-align: right">Meaning</th><th style="text-align: right">Notes</th></tr>
</thead>
<tbody>
<tr><td style="text-align: right">enable</td><td style="text-align: right">0</td><td style="text-align: right">0</td><td style="text-align: right">disabled</td><td style="text-align: right">åœç”¨ GPIO</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">1</td><td style="text-align: right">enabled</td><td style="text-align: right">å•Ÿç”¨ GPIO</td></tr>
<tr><td style="text-align: right">direction</td><td style="text-align: right">1</td><td style="text-align: right">0</td><td style="text-align: right">input</td><td style="text-align: right">è¨­å®šè¼¸å…¥çš„æ–¹å‘</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">1</td><td style="text-align: right">output</td><td style="text-align: right">è¨­å®šè¼¸å‡ºçš„æ–¹å‘</td></tr>
<tr><td style="text-align: right">input_mode</td><td style="text-align: right">2..3</td><td style="text-align: right">00</td><td style="text-align: right">hi-z</td><td style="text-align: right">Sets the input as high resistance</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">01</td><td style="text-align: right">pull-low</td><td style="text-align: right">Input pin is pulled low</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">10</td><td style="text-align: right">pull-high</td><td style="text-align: right">Input pin is pulled high</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">11</td><td style="text-align: right">n/a</td><td style="text-align: right">Invalid state. Do not set</td></tr>
<tr><td style="text-align: right">output_mode</td><td style="text-align: right">4</td><td style="text-align: right">0</td><td style="text-align: right">set-low</td><td style="text-align: right">Output pin is driven low</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">1</td><td style="text-align: right">set-high</td><td style="text-align: right">Output pin is driven high</td></tr>
<tr><td style="text-align: right">input_status</td><td style="text-align: right">5</td><td style="text-align: right">x</td><td style="text-align: right">in-val</td><td style="text-align: right">0 if input is &lt; 1.5v, 1 if input &gt;= 1.5v</td></tr>
</tbody>
</table>
</div>
<p>We <em>could</em> expose the following structure in Rust to control this GPIO:</p>
<pre><code class="language-rust ignore">/// GPIO interface
struct GpioConfig {
    /// GPIO Configuration structure generated by svd2rust
    periph: GPIO_CONFIG,
}

impl GpioConfig {
    pub fn set_enable(&amp;mut self, is_enabled: bool) {
        self.periph.modify(|_r, w| {
            w.enable().set_bit(is_enabled)
        });
    }

    pub fn set_direction(&amp;mut self, is_output: bool) {
        self.periph.modify(|_r, w| {
            w.direction().set_bit(is_output)
        });
    }

    pub fn set_input_mode(&amp;mut self, variant: InputMode) {
        self.periph.modify(|_r, w| {
            w.input_mode().variant(variant)
        });
    }

    pub fn set_output_mode(&amp;mut self, is_high: bool) {
        self.periph.modify(|_r, w| {
            w.output_mode.set_bit(is_high)
        });
    }

    pub fn get_input_status(&amp;self) -&gt; bool {
        self.periph.read().input_status().bit_is_set()
    }
}</code></pre>
<p>However, this would allow us to modify certain registers that do not make sense. For example, what happens if we set the <code>output_mode</code> field when our GPIO is configured as an input?</p>
<p>In general, use of this structure would allow us to reach states not defined by our state machine above: e.g. an output that is pulled low, or an input that is set high. For some hardware, this may not matter. On other hardware, it could cause unexpected or undefined behavior!</p>
<p>Although this interface is convenient to write, it doesnâ€™t enforce the design contracts set out by our hardware implementation.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="è¨­è¨ˆå¥‘ç´„"><a class="header" href="#è¨­è¨ˆå¥‘ç´„">è¨­è¨ˆå¥‘ç´„</a></h1>
<p>In our last chapter, we wrote an interface that <em>didnâ€™t</em> enforce design contracts. Letâ€™s take another look at our imaginary GPIO configuration register:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th style="text-align: right">Name</th><th style="text-align: right">Bit Number(s)</th><th style="text-align: right">Value</th><th style="text-align: right">Meaning</th><th style="text-align: right">Notes</th></tr>
</thead>
<tbody>
<tr><td style="text-align: right">enable</td><td style="text-align: right">0</td><td style="text-align: right">0</td><td style="text-align: right">disabled</td><td style="text-align: right">åœç”¨ GPIO</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">1</td><td style="text-align: right">enabled</td><td style="text-align: right">å•Ÿç”¨ GPIO</td></tr>
<tr><td style="text-align: right">direction</td><td style="text-align: right">1</td><td style="text-align: right">0</td><td style="text-align: right">input</td><td style="text-align: right">è¨­å®šè¼¸å…¥çš„æ–¹å‘</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">1</td><td style="text-align: right">output</td><td style="text-align: right">è¨­å®šè¼¸å‡ºçš„æ–¹å‘</td></tr>
<tr><td style="text-align: right">input_mode</td><td style="text-align: right">2..3</td><td style="text-align: right">00</td><td style="text-align: right">hi-z</td><td style="text-align: right">Sets the input as high resistance</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">01</td><td style="text-align: right">pull-low</td><td style="text-align: right">Input pin is pulled low</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">10</td><td style="text-align: right">pull-high</td><td style="text-align: right">Input pin is pulled high</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">11</td><td style="text-align: right">n/a</td><td style="text-align: right">Invalid state. Do not set</td></tr>
<tr><td style="text-align: right">output_mode</td><td style="text-align: right">4</td><td style="text-align: right">0</td><td style="text-align: right">set-low</td><td style="text-align: right">Output pin is driven low</td></tr>
<tr><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right">1</td><td style="text-align: right">set-high</td><td style="text-align: right">Output pin is driven high</td></tr>
<tr><td style="text-align: right">input_status</td><td style="text-align: right">5</td><td style="text-align: right">x</td><td style="text-align: right">in-val</td><td style="text-align: right">0 if input is &lt; 1.5v, 1 if input &gt;= 1.5v</td></tr>
</tbody>
</table>
</div>
<p>If we instead checked the state before making use of the underlying hardware, enforcing our design contracts at runtime, we might write code that looks like this instead:</p>
<pre><code class="language-rust ignore">/// GPIO interface
struct GpioConfig {
    /// GPIO Configuration structure generated by svd2rust
    periph: GPIO_CONFIG,
}

impl GpioConfig {
    pub fn set_enable(&amp;mut self, is_enabled: bool) {
        self.periph.modify(|_r, w| {
            w.enable().set_bit(is_enabled)
        });
    }

    pub fn set_direction(&amp;mut self, is_output: bool) -&gt; Result&lt;(), ()&gt; {
        if self.periph.read().enable().bit_is_clear() {
            // Must be enabled to set direction
            return Err(());
        }

        self.periph.modify(|r, w| {
            w.direction().set_bit(is_output)
        });

        Ok(())
    }

    pub fn set_input_mode(&amp;mut self, variant: InputMode) -&gt; Result&lt;(), ()&gt; {
        if self.periph.read().enable().bit_is_clear() {
            // Must be enabled to set input mode
            return Err(());
        }

        if self.periph.read().direction().bit_is_set() {
            // Direction must be input
            return Err(());
        }

        self.periph.modify(|_r, w| {
            w.input_mode().variant(variant)
        });

        Ok(())
    }

    pub fn set_output_status(&amp;mut self, is_high: bool) -&gt; Result&lt;(), ()&gt; {
        if self.periph.read().enable().bit_is_clear() {
            // Must be enabled to set output status
            return Err(());
        }

        if self.periph.read().direction().bit_is_clear() {
            // Direction must be output
            return Err(());
        }

        self.periph.modify(|_r, w| {
            w.output_mode.set_bit(is_high)
        });

        Ok(())
    }

    pub fn get_input_status(&amp;self) -&gt; Result&lt;bool, ()&gt; {
        if self.periph.read().enable().bit_is_clear() {
            // Must be enabled to get status
            return Err(());
        }

        if self.periph.read().direction().bit_is_set() {
            // Direction must be input
            return Err(());
        }

        Ok(self.periph.read().input_status().bit_is_set())
    }
}</code></pre>
<p>Because we need to enforce the restrictions on the hardware, we end up doing a lot of runtime checking which wastes time and resources, and this code will be much less pleasant for the developer to use.</p>
<h2 id="type-states"><a class="header" href="#type-states">Type States</a></h2>
<p>But what if instead, we used Rustâ€™s type system to enforce the state transition rules? Take this example:</p>
<pre><code class="language-rust ignore">/// GPIO interface
struct GpioConfig&lt;ENABLED, DIRECTION, MODE&gt; {
    /// GPIO Configuration structure generated by svd2rust
    periph: GPIO_CONFIG,
    enabled: ENABLED,
    direction: DIRECTION,
    mode: MODE,
}

// Type states for MODE in GpioConfig
struct Disabled;
struct Enabled;
struct Output;
struct Input;
struct PulledLow;
struct PulledHigh;
struct HighZ;
struct DontCare;

/// These functions may be used on any GPIO Pin
impl&lt;EN, DIR, IN_MODE&gt; GpioConfig&lt;EN, DIR, IN_MODE&gt; {
    pub fn into_disabled(self) -&gt; GpioConfig&lt;Disabled, DontCare, DontCare&gt; {
        self.periph.modify(|_r, w| w.enable.disabled());
        GpioConfig {
            periph: self.periph,
            enabled: Disabled,
            direction: DontCare,
            mode: DontCare,
        }
    }

    pub fn into_enabled_input(self) -&gt; GpioConfig&lt;Enabled, Input, HighZ&gt; {
        self.periph.modify(|_r, w| {
            w.enable.enabled()
             .direction.input()
             .input_mode.high_z()
        });
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: HighZ,
        }
    }

    pub fn into_enabled_output(self) -&gt; GpioConfig&lt;Enabled, Output, DontCare&gt; {
        self.periph.modify(|_r, w| {
            w.enable.enabled()
             .direction.output()
             .input_mode.set_high()
        });
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Output,
            mode: DontCare,
        }
    }
}

/// This function may be used on an Output Pin
impl GpioConfig&lt;Enabled, Output, DontCare&gt; {
    pub fn set_bit(&amp;mut self, set_high: bool) {
        self.periph.modify(|_r, w| w.output_mode.set_bit(set_high));
    }
}

/// These methods may be used on any enabled input GPIO
impl&lt;IN_MODE&gt; GpioConfig&lt;Enabled, Input, IN_MODE&gt; {
    pub fn bit_is_set(&amp;self) -&gt; bool {
        self.periph.read().input_status.bit_is_set()
    }

    pub fn into_input_high_z(self) -&gt; GpioConfig&lt;Enabled, Input, HighZ&gt; {
        self.periph.modify(|_r, w| w.input_mode().high_z());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: HighZ,
        }
    }

    pub fn into_input_pull_down(self) -&gt; GpioConfig&lt;Enabled, Input, PulledLow&gt; {
        self.periph.modify(|_r, w| w.input_mode().pull_low());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: PulledLow,
        }
    }

    pub fn into_input_pull_up(self) -&gt; GpioConfig&lt;Enabled, Input, PulledHigh&gt; {
        self.periph.modify(|_r, w| w.input_mode().pull_high());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: PulledHigh,
        }
    }
}</code></pre>
<p>Now letâ€™s see what the code using this would look like:</p>
<pre><code class="language-rust ignore">/*
 * Example 1: Unconfigured to High-Z input
 */
let pin: GpioConfig&lt;Disabled, _, _&gt; = get_gpio();

// Can't do this, pin isn't enabled!
// pin.into_input_pull_down();

// Now turn the pin from unconfigured to a high-z input
let input_pin = pin.into_enabled_input();

// Read from the pin
let pin_state = input_pin.bit_is_set();

// Can't do this, input pins don't have this interface!
// input_pin.set_bit(true);

/*
 * Example 2: High-Z input to Pulled Low input
 */
let pulled_low = input_pin.into_input_pull_down();
let pin_state = pulled_low.bit_is_set();

/*
 * Example 3: Pulled Low input to Output, set high
 */
let output_pin = pulled_low.into_enabled_output();
output_pin.set_bit(true);

// Can't do this, output pins don't have this interface!
// output_pin.into_input_pull_down();</code></pre>
<p>This is definitely a convenient way to store the state of the pin, but why do it this way? Why is this better than storing the state as an <code>enum</code> inside of our <code>GpioConfig</code> structure?</p>
<h2 id="compile-time-functional-safety"><a class="header" href="#compile-time-functional-safety">Compile Time Functional Safety</a></h2>
<p>Because we are enforcing our design constraints entirely at compile time, this incurs no runtime cost. It is impossible to set an output mode when you have a pin in an input mode. Instead, you must walk through the states by converting it to an output pin, and then setting the output mode. Because of this, there is no runtime penalty due to checking the current state before executing a function.</p>
<p>Also, because these states are enforced by the type system, there is no longer room for errors by consumers of this interface. If they try to perform an illegal state transition, the code will not compile!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="é›¶æˆæœ¬æŠ½è±¡"><a class="header" href="#é›¶æˆæœ¬æŠ½è±¡">é›¶æˆæœ¬æŠ½è±¡</a></h1>
<p>Type states are also an excellent example of Zero Cost Abstractions - the ability to move certain behaviors to compile time execution or analysis. These type states contain no actual data, and are instead used as markers. Since they contain no data, they have no actual representation in memory at runtime:</p>
<pre><code class="language-rust ignore">use core::mem::size_of;

let _ = size_of::&lt;Enabled&gt;();    // == 0
let _ = size_of::&lt;Input&gt;();      // == 0
let _ = size_of::&lt;PulledHigh&gt;(); // == 0
let _ = size_of::&lt;GpioConfig&lt;Enabled, Input, PulledHigh&gt;&gt;(); // == 0</code></pre>
<h2 id="zero-sized-types"><a class="header" href="#zero-sized-types">Zero Sized Types</a></h2>
<pre><code class="language-rust ignore">struct Enabled;</code></pre>
<p>Structures defined like this are called Zero Sized Types, as they contain no actual data. Although these types act â€œrealâ€ at compile time - you can copy them, move them, take references to them, etc., however the optimizer will completely strip them away.</p>
<p>In this snippet of code:</p>
<pre><code class="language-rust ignore">pub fn into_input_high_z(self) -&gt; GpioConfig&lt;Enabled, Input, HighZ&gt; {
    self.periph.modify(|_r, w| w.input_mode().high_z());
    GpioConfig {
        periph: self.periph,
        enabled: Enabled,
        direction: Input,
        mode: HighZ,
    }
}</code></pre>
<p>The GpioConfig we return never exists at runtime. Calling this function will generally boil down to a single assembly instruction - storing a constant register value to a register location. This means that the type state interface weâ€™ve developed is a zero cost abstraction - it uses no more CPU, RAM, or code space tracking the state of <code>GpioConfig</code>, and renders to the same machine code as a direct register access.</p>
<h2 id="nesting"><a class="header" href="#nesting">Nesting</a></h2>
<p>In general, these abstractions may be nested as deeply as you would like. As long as all components used are zero sized types, the whole structure will not exist at runtime.</p>
<p>For complex or deeply nested structures, it may be tedious to define all possible combinations of state. In these cases, macros may be used to generate all implementations.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="å¯æ”œæ€§"><a class="header" href="#å¯æ”œæ€§">å¯æ”œæ€§</a></h1>
<p>åœ¨åµŒå…¥å¼ç’°å¢ƒä¸­ï¼Œå¯æ”œæ€§æ˜¯éå¸¸é‡è¦çš„ä¸»é¡Œï¼šæ¯å€‹å» å•†ï¼Œç”šè‡³åŒä¸€å» å•†çš„ä¸åŒå®¶æ—ï¼Œéƒ½æä¾›ä¸åŒçš„å‘¨é‚Šèˆ‡èƒ½åŠ›ï¼Œèˆ‡å‘¨é‚Šäº’å‹•çš„æ–¹å¼ä¹Ÿæœƒæœ‰æ‰€å·®ç•°ã€‚</p>
<p>å¹³è¡¡é€™äº›å·®ç•°çš„ä¸€å€‹å¸¸è¦‹æ–¹å¼æ˜¯é€éç¨±ç‚ºç¡¬é«”æŠ½è±¡å±¤ï¼ˆHardware Abstraction Layerï¼Œ<strong>HAL</strong>ï¼‰çš„å±¤æ¬¡ã€‚</p>
<blockquote>
<p>ç¡¬é«”æŠ½è±¡æ˜¯åœ¨è»Ÿé«”ä¸­æ¨¡æ“¬éƒ¨åˆ†å¹³å°ç‰¹æœ‰ç´°ç¯€çš„ä¸€çµ„ç¨‹å¼ä¾‹ç¨‹ï¼Œè®“ç¨‹å¼èƒ½ç›´æ¥å­˜å–ç¡¬é«”è³‡æºã€‚</p>
<p>å®ƒå€‘é€šå¸¸é€éå‘ç¡¬é«”æä¾›æ¨™æº–ä½œæ¥­ç³»çµ±ï¼ˆOSï¼‰å‘¼å«ï¼Œè®“ç¨‹å¼è¨­è¨ˆè€…èƒ½æ’°å¯«èˆ‡è£ç½®ç„¡é—œã€é«˜æ•ˆèƒ½çš„æ‡‰ç”¨ç¨‹å¼ã€‚</p>
<p><em>Wikipediaï¼š<a href="https://en.wikipedia.org/wiki/Hardware_abstraction">Hardware Abstraction Layer</a></em></p>
</blockquote>
<p>åµŒå…¥å¼ç³»çµ±åœ¨é€™æ–¹é¢æœ‰äº›ç‰¹æ®Šï¼Œå› ç‚ºæˆ‘å€‘é€šå¸¸æ²’æœ‰ä½œæ¥­ç³»çµ±èˆ‡å¯ç”±ä½¿ç”¨è€…å®‰è£çš„è»Ÿé«”ï¼Œè€Œæ˜¯æ•´é«”ç·¨è­¯çš„éŸŒé«”æ˜ åƒï¼Œä»¥åŠè¨±å¤šå…¶ä»–é™åˆ¶ã€‚å› æ­¤ï¼Œé›–ç„¶ Wikipedia æ‰€å®šç¾©çš„å‚³çµ±ä½œæ³•å¯èƒ½å¯è¡Œï¼Œä½†å¯èƒ½ä¸æ˜¯æœ€æœ‰æ•ˆç‡çš„å¯æ”œæ€§ç¢ºä¿æ–¹å¼ã€‚</p>
<p>åœ¨ Rust ä¸­å¦‚ä½•åšåˆ°ï¼Ÿç­”æ¡ˆæ˜¯ <strong><a href="https://crates.io/crates/embedded-hal">embedded-hal</a></strong>â€¦</p>
<h2 id="ä»€éº¼æ˜¯-embedded-hal"><a class="header" href="#ä»€éº¼æ˜¯-embedded-hal">ä»€éº¼æ˜¯ <a href="https://crates.io/crates/embedded-hal">embedded-hal</a>ï¼Ÿ</a></h2>
<p>ç°¡è€Œè¨€ä¹‹ï¼Œå®ƒæ˜¯ä¸€çµ„ traitsï¼Œç”¨æ–¼å®šç¾© <strong>HAL å¯¦ä½œ</strong>ã€<strong>é©…å‹•ç¨‹å¼</strong> èˆ‡ <strong>æ‡‰ç”¨ç¨‹å¼ï¼ˆæˆ–éŸŒé«”ï¼‰</strong> ä¹‹é–“çš„å¯¦ä½œå¥‘ç´„ã€‚é€™äº›å¥‘ç´„åŒæ™‚åŒ…å«èƒ½åŠ›ï¼ˆä¾‹å¦‚æŸå€‹å‹åˆ¥å¯¦ä½œäº†æŸ traitï¼Œè¡¨ç¤º <strong>HAL å¯¦ä½œ</strong>æä¾›äº†æŸç¨®èƒ½åŠ›ï¼‰èˆ‡æ–¹æ³•ï¼ˆä¾‹å¦‚ä½ èƒ½å»ºç«‹ä¸€å€‹å¯¦ä½œ trait çš„å‹åˆ¥ï¼Œå°±ä¿è­‰æ“æœ‰ trait æ‰€æŒ‡å®šçš„æ–¹æ³•ï¼‰ã€‚</p>
<p>å…¸å‹çš„åˆ†å±¤å¯èƒ½å¦‚ä¸‹ï¼š</p>
<p><img src="assets/rust_layers.svg" alt=""></p>
<p><strong><a href="https://crates.io/crates/embedded-hal">embedded-hal</a></strong> ä¸­å®šç¾©çš„ä¸€äº› trait åŒ…å«ï¼š</p>
<ul>
<li>GPIOï¼ˆè¼¸å…¥èˆ‡è¼¸å‡ºè…³ä½ï¼‰</li>
<li>åºåˆ—é€šè¨Š</li>
<li>I2C</li>
<li>SPI</li>
<li>è¨ˆæ™‚å™¨ï¼å€’æ•¸è¨ˆæ™‚</li>
<li>é¡æ¯”è¨Šè™Ÿè½‰æ›</li>
</ul>
<p>æ“æœ‰ <strong>embedded-hal</strong> traits ä»¥åŠå¯¦ä½œä¸¦ä½¿ç”¨å®ƒå€‘çš„å¥—ä»¶ï¼Œä¸»è¦æ˜¯ç‚ºäº†æ§åˆ¶è¤‡é›œåº¦ã€‚è‹¥ä¸€å€‹æ‡‰ç”¨ç¨‹å¼åŒæ™‚è¦å¯¦ä½œç¡¬é«”å‘¨é‚Šçš„ä½¿ç”¨ã€æ‡‰ç”¨ç¨‹å¼æœ¬èº«ï¼Œä»¥åŠå¯èƒ½çš„é¡å¤–ç¡¬é«”é©…å‹•ï¼Œå¾ˆå®¹æ˜“çœ‹å‡ºå¯é‡ç”¨æ€§æœƒéå¸¸æœ‰é™ã€‚ç”¨æ•¸å­¸è¡¨ç¤ºï¼Œè‹¥ <strong>M</strong> æ˜¯å‘¨é‚Š HAL å¯¦ä½œæ•¸é‡ï¼Œ<strong>N</strong> æ˜¯é©…å‹•æ•¸é‡ï¼Œè‹¥æ¯å€‹æ‡‰ç”¨éƒ½é‡é€ è¼ªå­ï¼Œæœ€çµ‚æœƒæœ‰ <strong>M*N</strong> ç¨®å¯¦ä½œï¼›è€Œä½¿ç”¨ <strong><a href="https://crates.io/crates/embedded-hal">embedded-hal</a></strong> traits æä¾›çš„ <em>API</em>ï¼Œå¯¦ä½œè¤‡é›œåº¦æœƒè¶¨è¿‘ <strong>M+N</strong>ã€‚ç•¶ç„¶é‚„æœ‰å…¶ä»–å¥½è™•ï¼Œä¾‹å¦‚å› ç‚º API å®šç¾©æ¸…æ¥šä¸”å¯ç›´æ¥ä½¿ç”¨ï¼Œèƒ½æ¸›å°‘è©¦éŒ¯ã€‚</p>
<h2 id="embedded-hal-çš„ä½¿ç”¨è€…"><a class="header" href="#embedded-hal-çš„ä½¿ç”¨è€…"><a href="https://crates.io/crates/embedded-hal">embedded-hal</a> çš„ä½¿ç”¨è€…</a></h2>
<p>å¦‚ä¸Šæ‰€è¿°ï¼ŒHAL æœ‰ä¸‰ç¨®ä¸»è¦ä½¿ç”¨è€…ï¼š</p>
<h3 id="hal-å¯¦ä½œ"><a class="header" href="#hal-å¯¦ä½œ">HAL å¯¦ä½œ</a></h3>
<p>HAL å¯¦ä½œæä¾›ç¡¬é«”èˆ‡ HAL traits ä½¿ç”¨è€…ä¹‹é–“çš„ä»‹é¢ã€‚å…¸å‹å¯¦ä½œåŒ…å«ä¸‰éƒ¨åˆ†ï¼š</p>
<ul>
<li>ä¸€æˆ–å¤šå€‹ç¡¬é«”ç‰¹å®šå‹åˆ¥</li>
<li>ç”¨ä¾†å»ºç«‹ä¸¦åˆå§‹åŒ–è©²å‹åˆ¥çš„å‡½å¼ï¼Œé€šå¸¸æä¾›å„ç¨®è¨­å®šé¸é …ï¼ˆé€Ÿåº¦ã€æ“ä½œæ¨¡å¼ã€ä½¿ç”¨è…³ä½ç­‰ï¼‰</li>
<li>è©²å‹åˆ¥çš„ä¸€æˆ–å¤šå€‹ <strong><a href="https://crates.io/crates/embedded-hal">embedded-hal</a></strong> traits çš„ <code>trait</code> <code>impl</code></li>
</ul>
<p>é€™æ¨£çš„ <strong>HAL å¯¦ä½œ</strong> å¯æœ‰ä¸åŒå½¢å¼ï¼š</p>
<ul>
<li>é€éä½éšç¡¬é«”å­˜å–ï¼Œä¾‹å¦‚æš«å­˜å™¨</li>
<li>é€éä½œæ¥­ç³»çµ±ï¼Œä¾‹å¦‚åœ¨ Linux ä½¿ç”¨ <code>sysfs</code></li>
<li>é€éè½‰æ¥å±¤ï¼Œä¾‹å¦‚ç”¨æ–¼å–®å…ƒæ¸¬è©¦çš„å‹åˆ¥ mock</li>
<li>é€éç¡¬é«”è½‰æ¥å™¨çš„é©…å‹•ç¨‹å¼ï¼Œä¾‹å¦‚ I2C å¤šå·¥å™¨æˆ– GPIO æ“´å……å™¨</li>
</ul>
<h3 id="é©…å‹•ç¨‹å¼"><a class="header" href="#é©…å‹•ç¨‹å¼">é©…å‹•ç¨‹å¼</a></h3>
<p>é©…å‹•ç¨‹å¼ç‚ºå…§éƒ¨æˆ–å¤–éƒ¨å…ƒä»¶æä¾›ä¸€çµ„è‡ªè¨‚åŠŸèƒ½ï¼Œè©²å…ƒä»¶é€£æ¥åˆ°å¯¦ä½œ <a href="https://crates.io/crates/embedded-hal">embedded-hal</a> traits çš„å‘¨é‚Šã€‚å…¸å‹ä¾‹å­åŒ…æ‹¬å„ç¨®æ„Ÿæ¸¬å™¨ï¼ˆæº«åº¦ã€ç£åŠ›è¨ˆã€åŠ é€Ÿåº¦è¨ˆã€å…‰ï¼‰ã€é¡¯ç¤ºè£ç½®ï¼ˆLED é™£åˆ—ã€LCD é¡¯ç¤ºå™¨ï¼‰èˆ‡è‡´å‹•å™¨ï¼ˆé¦¬é”ã€ç™¼å°„å™¨ï¼‰ã€‚</p>
<p>é©…å‹•ç¨‹å¼å¿…é ˆä»¥å¯¦ä½œ <a href="https://crates.io/crates/embedded-hal">embedded-hal</a> æŸå€‹ <code>trait</code> çš„å‹åˆ¥å¯¦ä¾‹åˆå§‹åŒ–ï¼Œé€™ç”± trait bound ä¿è­‰ï¼Œä¸¦æä¾›å…¶è‡ªæœ‰å‹åˆ¥å¯¦ä¾‹èˆ‡è‡ªè¨‚æ–¹æ³•é›†åˆï¼Œç”¨ä¾†èˆ‡æ‰€é©…å‹•çš„è£ç½®äº’å‹•ã€‚</p>
<h3 id="æ‡‰ç”¨ç¨‹å¼"><a class="header" href="#æ‡‰ç”¨ç¨‹å¼">æ‡‰ç”¨ç¨‹å¼</a></h3>
<p>æ‡‰ç”¨ç¨‹å¼æŠŠå„éƒ¨åˆ†çµ„åˆèµ·ä¾†ï¼Œç¢ºä¿é”æˆæ‰€éœ€åŠŸèƒ½ã€‚åœ¨ä¸åŒç³»çµ±é–“ç§»æ¤æ™‚ï¼Œé€™éƒ¨åˆ†éœ€è¦æœ€å¤šçš„èª¿æ•´åŠªåŠ›ï¼Œå› ç‚ºæ‡‰ç”¨ç¨‹å¼å¿…é ˆé€é HAL å¯¦ä½œæ­£ç¢ºåˆå§‹åŒ–å¯¦é«”ç¡¬é«”ï¼Œè€Œä¸åŒç¡¬é«”çš„åˆå§‹åŒ–æ–¹å¼å¯èƒ½å·®ç•°å¾ˆå¤§ã€‚æ­¤å¤–ï¼Œä½¿ç”¨è€…é¸æ“‡ä¹Ÿå¸¸æ‰®æ¼”é‡è¦è§’è‰²ï¼Œå› ç‚ºå…ƒä»¶å¯èƒ½å¯¦é«”é€£æ¥åˆ°ä¸åŒç«¯å­ï¼Œç¡¬é«”åŒ¯æµæ’æœ‰æ™‚éœ€è¦å¤–éƒ¨ç¡¬é«”é…åˆè¨­å®šï¼Œæˆ–æ˜¯å…§éƒ¨å‘¨é‚Šçš„ä½¿ç”¨éœ€è¦ä¸åŒå–æ¨ï¼ˆä¾‹å¦‚å­˜åœ¨å¤šå€‹èƒ½åŠ›ä¸åŒçš„è¨ˆæ™‚å™¨æˆ–å‘¨é‚Šå½¼æ­¤è¡çªï¼‰ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ä¸¦è¡Œ"><a class="header" href="#ä¸¦è¡Œ">ä¸¦è¡Œ</a></h1>
<p>ä¸¦è¡Œæœƒåœ¨ç¨‹å¼çš„ä¸åŒéƒ¨åˆ†å¯èƒ½æ–¼ä¸åŒæ™‚é–“æˆ–ä¸åŒé †åºåŸ·è¡Œæ™‚ç™¼ç”Ÿã€‚åœ¨åµŒå…¥å¼æƒ…å¢ƒä¸­ï¼Œé€™åŒ…æ‹¬ï¼š</p>
<ul>
<li>ä¸­æ–·è™•ç†å™¨ï¼šåœ¨ç›¸é—œä¸­æ–·ç™¼ç”Ÿæ™‚åŸ·è¡Œï¼Œ</li>
<li>å„ç¨®å½¢å¼çš„å¤šåŸ·è¡Œç·’ï¼šå¾®è™•ç†å™¨æœƒå®šæœŸåœ¨ç¨‹å¼çš„ä¸åŒéƒ¨åˆ†ä¹‹é–“åˆ‡æ›ï¼Œ</li>
<li>ä»¥åŠåœ¨æŸäº›ç³»çµ±ä¸­ï¼Œå¤šæ ¸å¿ƒå¾®è™•ç†å™¨ï¼šæ¯å€‹æ ¸å¿ƒéƒ½èƒ½åœ¨åŒä¸€æ™‚é–“ç¨ç«‹åŸ·è¡Œç¨‹å¼çš„ä¸åŒéƒ¨åˆ†ã€‚</li>
</ul>
<p>ç”±æ–¼è¨±å¤šåµŒå…¥å¼ç¨‹å¼éœ€è¦è™•ç†ä¸­æ–·ï¼Œä¸¦è¡Œé²æ—©æœƒå‡ºç¾ï¼Œä¹Ÿæ­£æ˜¯è¨±å¤šç´°å¾®ä¸”é›£è§£çš„éŒ¯èª¤å‡ºç¾ä¹‹è™•ã€‚å¹¸é‹çš„æ˜¯ï¼ŒRust æä¾›å¤šç¨®æŠ½è±¡èˆ‡å®‰å…¨ä¿è­‰ï¼Œå”åŠ©æˆ‘å€‘å¯«å‡ºæ­£ç¢ºçš„ç¨‹å¼ç¢¼ã€‚</p>
<h2 id="ç„¡ä¸¦è¡Œ"><a class="header" href="#ç„¡ä¸¦è¡Œ">ç„¡ä¸¦è¡Œ</a></h2>
<p>åµŒå…¥å¼ç¨‹å¼æœ€ç°¡å–®çš„ä¸¦è¡Œå°±æ˜¯æ²’æœ‰ä¸¦è¡Œï¼šè»Ÿé«”ç”±å–®ä¸€ä¸»è¿´åœˆæ§‹æˆï¼ŒæŒçºŒé‹è¡Œï¼Œä¸”å®Œå…¨æ²’æœ‰ä¸­æ–·ã€‚æœ‰æ™‚é€™éå¸¸é©åˆæ‰‹é‚Šçš„å•é¡Œï¼é€šå¸¸ä½ çš„è¿´åœˆæœƒè®€å–ä¸€äº›è¼¸å…¥ã€åšä¸€äº›è™•ç†ï¼Œå†è¼¸å‡ºä¸€äº›çµæœã€‚</p>
<pre><code class="language-rust ignore">#[entry]
fn main() {
    let peripherals = setup_peripherals();
    loop {
        let inputs = read_inputs(&amp;peripherals);
        let outputs = process(inputs);
        write_outputs(&amp;peripherals, outputs);
    }
}</code></pre>
<p>ç”±æ–¼æ²’æœ‰ä¸¦è¡Œï¼Œå°±ä¸éœ€è¦æ“”å¿ƒç¨‹å¼å„éƒ¨åˆ†ä¹‹é–“çš„è³‡æ–™å…±äº«æˆ–å‘¨é‚Šå­˜å–åŒæ­¥ã€‚å¦‚æœä½ å¯ä»¥æ¡ç”¨é€™éº¼ç°¡å–®çš„æ–¹æ³•ï¼Œé€™æœƒæ˜¯å¾ˆæ£’çš„è§£æ±ºæ–¹æ¡ˆã€‚</p>
<h2 id="å…¨åŸŸå¯è®Šè³‡æ–™"><a class="header" href="#å…¨åŸŸå¯è®Šè³‡æ–™">å…¨åŸŸå¯è®Šè³‡æ–™</a></h2>
<p>èˆ‡éåµŒå…¥å¼ Rust ä¸åŒï¼Œæˆ‘å€‘é€šå¸¸ç„¡æ³•å¥¢æœ›å»ºç«‹å †ç©é…ç½®ä¸¦æŠŠå°è©²è³‡æ–™çš„åƒè€ƒå‚³çµ¦æ–°å»ºåŸ·è¡Œç·’ã€‚ç›¸ååœ°ï¼Œæˆ‘å€‘çš„ä¸­æ–·è™•ç†å™¨å¯èƒ½åœ¨ä»»ä½•æ™‚å€™è¢«å‘¼å«ï¼Œå¿…é ˆçŸ¥é“å¦‚ä½•å­˜å–æˆ‘å€‘æ­£åœ¨ä½¿ç”¨çš„å…±äº«è¨˜æ†¶é«”ã€‚åœ¨æœ€ä½å±¤ï¼Œé€™ä»£è¡¨æˆ‘å€‘å¿…é ˆæ“æœ‰_éœæ…‹é…ç½®_çš„å¯è®Šè¨˜æ†¶é«”ï¼Œè®“ä¸­æ–·è™•ç†å™¨èˆ‡ä¸»ç¨‹å¼ç¢¼éƒ½èƒ½åƒè€ƒã€‚</p>
<p>åœ¨ Rust ä¸­ï¼Œé€™é¡ <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable"><code>static mut</code></a> è®Šæ•¸çš„è®€å¯«æ°¸é æ˜¯ä¸å®‰å…¨çš„ï¼Œå› ç‚ºè‹¥ä¸ç‰¹åˆ¥å°å¿ƒï¼Œä½ å¯èƒ½è§¸ç™¼è³‡æ–™ç«¶çˆ­ï¼šå°è®Šæ•¸çš„å­˜å–é€”ä¸­è¢«åŒæ¨£æœƒå­˜å–è©²è®Šæ•¸çš„ä¸­æ–·æ‰“æ–·ã€‚</p>
<p>ç‚ºäº†ç¤ºç¯„æ­¤è¡Œç‚ºå¦‚ä½•é€ æˆç¨‹å¼ä¸­çš„ç´°å¾®éŒ¯èª¤ï¼Œæƒ³åƒä¸€å€‹åµŒå…¥å¼ç¨‹å¼æœƒåœ¨æ¯ä¸€ç§’å…§è¨ˆç®—æŸå€‹è¼¸å…¥è¨Šè™Ÿçš„ä¸Šå‡æ²¿ï¼ˆé »ç‡è¨ˆæ•¸å™¨ï¼‰ï¼š</p>
<pre><code class="language-rust ignore">static mut COUNTER: u32 = 0;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // å±éšª - ä¸¦ä¸å®‰å…¨ï¼å¯èƒ½é€ æˆè³‡æ–™ç«¶çˆ­ã€‚
            unsafe { COUNTER += 1 };
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}</code></pre>
<p>æ¯ä¸€ç§’ï¼Œè¨ˆæ™‚å™¨ä¸­æ–·æœƒæŠŠè¨ˆæ•¸å™¨è¨­å› 0ã€‚åŒæ™‚ï¼Œä¸»è¿´åœˆæœƒæŒçºŒé‡æ¸¬è¨Šè™Ÿï¼Œä¸¦åœ¨çœ‹åˆ°ä½è½‰é«˜æ™‚éå¢è¨ˆæ•¸å™¨ã€‚æˆ‘å€‘å¿…é ˆç”¨ <code>unsafe</code> å­˜å– <code>COUNTER</code>ï¼Œå› ç‚ºå®ƒæ˜¯ <code>static mut</code>ï¼Œé€™ä»£è¡¨æˆ‘å€‘å‘ç·¨è­¯å™¨ä¿è­‰ä¸æœƒé€ æˆæœªå®šç¾©è¡Œç‚ºã€‚ä½ èƒ½æ‰¾å‡ºè³‡æ–™ç«¶çˆ­å—ï¼Ÿ<code>COUNTER</code> çš„éå¢_ä¸_ä¿è­‰æ˜¯åŸå­æ“ä½œâ€”â€”äº‹å¯¦ä¸Šï¼Œåœ¨å¤šæ•¸åµŒå…¥å¼å¹³å°ä¸Šï¼Œå®ƒæœƒè¢«æ‹†æˆè¼‰å…¥ã€éå¢ã€å„²å­˜ä¸‰æ­¥é©Ÿã€‚å¦‚æœä¸­æ–·åœ¨è¼‰å…¥ä¹‹å¾Œã€å„²å­˜ä¹‹å‰è§¸ç™¼ï¼Œå›åˆ°ä¸­æ–·å¾Œæœƒå¿½ç•¥é‡è¨­ç‚º 0 çš„çµæœâ€”â€”å› æ­¤è©²æœŸé–“çš„è½‰æ›æ¬¡æ•¸æœƒè¢«è¨ˆå…©æ¬¡ã€‚</p>
<h2 id="è‡¨ç•Œå€"><a class="header" href="#è‡¨ç•Œå€">è‡¨ç•Œå€</a></h2>
<p>é‚£éº¼ï¼Œæˆ‘å€‘èƒ½å¦‚ä½•è™•ç†è³‡æ–™ç«¶çˆ­ï¼Ÿä¸€å€‹ç°¡å–®çš„ä½œæ³•æ˜¯ä½¿ç”¨_è‡¨ç•Œå€_ï¼Œä¹Ÿå°±æ˜¯åœç”¨ä¸­æ–·çš„æƒ…å¢ƒã€‚æŠŠ <code>main</code> ä¸­å° <code>COUNTER</code> çš„å­˜å–åŒ…åœ¨è‡¨ç•Œå€å…§ï¼Œæˆ‘å€‘å°±èƒ½ç¢ºå®šåœ¨å®Œæˆéå¢<code>COUNTER</code> ä¹‹å‰è¨ˆæ™‚å™¨ä¸­æ–·ä¸æœƒè§¸ç™¼ï¼š</p>
<pre><code class="language-rust ignore">static mut COUNTER: u32 = 0;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // æ–°çš„è‡¨ç•Œå€ç¢ºä¿å° COUNTER çš„åŒæ­¥å­˜å–
            cortex_m::interrupt::free(|_| {
                unsafe { COUNTER += 1 };
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}</code></pre>
<p>åœ¨æ­¤ä¾‹ä¸­ï¼Œæˆ‘å€‘ä½¿ç”¨ <code>cortex_m::interrupt::free</code>ï¼Œä½†å…¶ä»–å¹³å°ä¹Ÿæœƒæœ‰é¡ä¼¼æ©Ÿåˆ¶å¯åœ¨è‡¨ç•Œå€ä¸­åŸ·è¡Œç¨‹å¼ç¢¼ã€‚é€™ç­‰åŒæ–¼åœç”¨ä¸­æ–·ã€åŸ·è¡ŒæŸæ®µç¨‹å¼ç¢¼ï¼Œç„¶å¾Œå†é‡æ–°å•Ÿç”¨ä¸­æ–·ã€‚</p>
<p>æ³¨æ„ï¼Œæˆ‘å€‘ä¸éœ€è¦åœ¨è¨ˆæ™‚å™¨ä¸­æ–·å…§åŠ å…¥è‡¨ç•Œå€ï¼ŒåŸå› æœ‰äºŒï¼š</p>
<ul>
<li>å°‡ 0 å¯«å…¥ <code>COUNTER</code> ä¸æœƒå—ç«¶çˆ­å½±éŸ¿ï¼Œå› ç‚ºæˆ‘å€‘æ²’æœ‰è®€å–å®ƒ</li>
<li>åæ­£ä¹Ÿä¸æœƒè¢« <code>main</code> åŸ·è¡Œç·’æ‰“æ–·</li>
</ul>
<p>è‹¥ <code>COUNTER</code> ç”±å¤šå€‹å¯èƒ½äº’ç›¸_æ¶å _çš„ä¸­æ–·è™•ç†å™¨å…±äº«ï¼Œå‰‡æ¯ä¸€å€‹ä¹Ÿå¯èƒ½éƒ½éœ€è¦è‡¨ç•Œå€ã€‚</p>
<p>é€™è§£æ±ºäº†ç•¶ä¸‹å•é¡Œï¼Œä½†æˆ‘å€‘ä»éœ€æ’°å¯«å¤§é‡ <code>unsafe</code> ç¨‹å¼ç¢¼ä¸¦å°å¿ƒæ¨ç†ï¼Œè€Œä¸”å¯èƒ½æœƒä¸å¿…è¦åœ°ä½¿ç”¨è‡¨ç•Œå€ã€‚ç”±æ–¼æ¯å€‹è‡¨ç•Œå€æœƒæš«åœä¸­æ–·è™•ç†ï¼Œå› æ­¤æœƒå¸¶ä¾†é¡å¤–çš„ç¨‹å¼ç¢¼å¤§å°æˆæœ¬ï¼Œä»¥åŠæ›´é«˜çš„ä¸­æ–·å»¶é²èˆ‡æŠ–å‹•ï¼ˆä¸­æ–·å¯èƒ½éœ€è¦æ›´ä¹…æ‰è¢«è™•ç†ï¼Œä¸”ç­‰å¾…æ™‚é–“æ›´ä¸ç©©å®šï¼‰ã€‚é€™æ˜¯å¦æ˜¯å•é¡Œå–æ±ºæ–¼ä½ çš„ç³»çµ±ï¼Œä½†ä¸€èˆ¬è€Œè¨€æˆ‘å€‘å¸Œæœ›é¿å…å®ƒã€‚</p>
<p>å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè‡¨ç•Œå€é›–ç„¶ä¿è­‰ä¸æœƒæœ‰ä¸­æ–·è§¸ç™¼ï¼Œä½†åœ¨å¤šæ ¸å¿ƒç³»çµ±ä¸Šä¸¦ä¸æä¾›äº’æ–¥ä¿è­‰ï¼å³ä½¿æ²’æœ‰ä¸­æ–·ï¼Œå…¶ä»–æ ¸å¿ƒä¹Ÿå¯èƒ½åŒæ™‚å­˜å–ç›¸åŒè¨˜æ†¶é«”ã€‚å¦‚æœä½ ä½¿ç”¨å¤šæ ¸å¿ƒï¼Œå°±éœ€è¦æ›´å¼·çš„åŒæ­¥åŸèªã€‚</p>
<h2 id="åŸå­å­˜å–"><a class="header" href="#åŸå­å­˜å–">åŸå­å­˜å–</a></h2>
<p>åœ¨æŸäº›å¹³å°ä¸Šï¼Œæœ‰ç‰¹æ®Šçš„åŸå­æŒ‡ä»¤ï¼Œå¯ç‚ºè®€-æ”¹-å¯«æ“ä½œæä¾›ä¿è­‰ã€‚ä»¥ Cortex-M ç‚ºä¾‹ï¼š<code>thumbv6</code>ï¼ˆCortex-M0ã€Cortex-M0+ï¼‰åƒ…æä¾›åŸå­è¼‰å…¥èˆ‡å„²å­˜æŒ‡ä»¤ï¼Œè€Œ <code>thumbv7</code>ï¼ˆCortex-M3 åŠä»¥ä¸Šï¼‰æä¾›å®Œæ•´çš„ Compare and Swapï¼ˆCASï¼‰æŒ‡ä»¤ã€‚é€™äº› CAS æŒ‡ä»¤å¯ä½œç‚ºç²—æš´åœç”¨æ‰€æœ‰ä¸­æ–·çš„æ›¿ä»£æ–¹æ¡ˆï¼šæˆ‘å€‘å¯å˜—è©¦éå¢ï¼Œå¤§å¤šæ™‚å€™æœƒæˆåŠŸï¼›è‹¥è¢«ä¸­æ–·ï¼Œå®ƒæœƒè‡ªå‹•é‡è©¦æ•´å€‹éå¢æ“ä½œã€‚é€™äº›åŸå­æ“ä½œå³ä½¿è·¨å¤šæ ¸å¿ƒä¹Ÿå®‰å…¨ã€‚</p>
<pre><code class="language-rust ignore">use core::sync::atomic::{AtomicUsize, Ordering};

static COUNTER: AtomicUsize = AtomicUsize::new(0);

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // ä½¿ç”¨ `fetch_add` ä»¥åŸå­æ–¹å¼å°‡ COUNTER åŠ  1
            COUNTER.fetch_add(1, Ordering::Relaxed);
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // ä½¿ç”¨ `store` ç›´æ¥å°‡ 0 å¯«å…¥ COUNTER
    COUNTER.store(0, Ordering::Relaxed)
}</code></pre>
<p>æ­¤æ™‚ <code>COUNTER</code> æ˜¯å®‰å…¨çš„ <code>static</code> è®Šæ•¸ã€‚å¤šè™§ <code>AtomicUsize</code> å‹åˆ¥ï¼Œ<code>COUNTER</code>å¯åœ¨ä¸ä¸­æ–·çš„æƒ…æ³ä¸‹ç”±ä¸­æ–·è™•ç†å™¨èˆ‡ä¸»åŸ·è¡Œç·’å®‰å…¨åœ°ä¿®æ”¹ã€‚è‹¥å¯è¡Œï¼Œé€™æ˜¯æ›´å¥½çš„è§£æ±ºæ–¹æ¡ˆâ€”â€”ä½†ä½ çš„å¹³å°å¯èƒ½ä¸æ”¯æ´ã€‚</p>
<p>é—œæ–¼ <a href="https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html"><code>Ordering</code></a>ï¼šå®ƒæœƒå½±éŸ¿ç·¨è­¯å™¨èˆ‡ç¡¬é«”å¯èƒ½é‡æ’åºæŒ‡ä»¤çš„æ–¹å¼ï¼Œä¸¦ä¸”æœƒå½±éŸ¿å¿«å–å¯è¦‹æ€§ã€‚å‡è¨­ç›®æ¨™æ˜¯å–®æ ¸å¿ƒå¹³å°ï¼Œåœ¨æ­¤æƒ…æ³ä¸‹ <code>Relaxed</code> è¶³å¤ ä¸”æœ€æœ‰æ•ˆç‡ã€‚æ›´åš´æ ¼çš„æ’åºæœƒè®“ç·¨è­¯å™¨åœ¨åŸå­æ“ä½œå‘¨åœæ’å…¥è¨˜æ†¶é«”å±éšœï¼›è¦–ä½ ä½¿ç”¨åŸå­çš„ç›®çš„è€Œå®šï¼Œå¯èƒ½éœ€è¦ä¹Ÿå¯èƒ½ä¸éœ€è¦ã€‚åŸå­æ¨¡å‹çš„ç²¾ç¢ºç´°ç¯€ç›¸ç•¶è¤‡é›œï¼Œæœ€å¥½åƒè€ƒå…¶ä»–è³‡æ–™ã€‚</p>
<p>æ›´å¤šé—œæ–¼åŸå­æ“ä½œèˆ‡æ’åºçš„ç´°ç¯€ï¼Œè«‹åƒè€ƒ <a href="https://doc.rust-lang.org/nomicon/atomics.html">nomicon</a>ã€‚</p>
<h2 id="æŠ½è±¡send-èˆ‡-sync"><a class="header" href="#æŠ½è±¡send-èˆ‡-sync">æŠ½è±¡ã€Send èˆ‡ Sync</a></h2>
<p>ä¸Šè¿°è§£æ³•éƒ½ä¸ç®—ç†æƒ³ã€‚å®ƒå€‘éœ€è¦ <code>unsafe</code> å€å¡Šï¼Œå¿…é ˆéå¸¸ä»”ç´°åœ°æª¢æŸ¥ï¼Œä¸”ä¸å¤ æ˜“ç”¨ã€‚æˆ‘å€‘åœ¨ Rust ä¸­ä¸€å®šèƒ½åšå¾—æ›´å¥½ï¼</p>
<p>æˆ‘å€‘å¯ä»¥æŠŠè¨ˆæ•¸å™¨æŠ½è±¡æˆå®‰å…¨çš„ä»‹é¢ï¼Œè®“ç¨‹å¼å…¶ä»–åœ°æ–¹éƒ½èƒ½å®‰å…¨ä½¿ç”¨ã€‚æ­¤ä¾‹ä¸­æˆ‘å€‘æœƒä½¿ç”¨è‡¨ç•Œå€è¨ˆæ•¸å™¨ï¼Œä½†ç”¨åŸå­æ“ä½œä¹Ÿèƒ½åšå‡ºå¾ˆç›¸ä¼¼çš„ä½œæ³•ã€‚</p>
<pre><code class="language-rust ignore">use core::cell::UnsafeCell;
use cortex_m::interrupt;

// æˆ‘å€‘çš„è¨ˆæ•¸å™¨åªæ˜¯å° UnsafeCell&lt;u32&gt; çš„åŒ…è£ï¼Œé€™æ˜¯ Rust å…§éƒ¨å¯è®Šæ€§çš„æ ¸å¿ƒ
// é€éå…§éƒ¨å¯è®Šæ€§ï¼Œæˆ‘å€‘å¯ä»¥è®“ COUNTER æˆç‚º `static` è€Œä¸æ˜¯ `static mut`ï¼Œä½†
// ä»å¯è®Šæ›´å…¶è¨ˆæ•¸å€¼ã€‚
struct CSCounter(UnsafeCell&lt;u32&gt;);

const CS_COUNTER_INIT: CSCounter = CSCounter(UnsafeCell::new(0));

impl CSCounter {
    pub fn reset(&amp;self, _cs: &amp;interrupt::CriticalSection) {
        // é€éè¦æ±‚å‚³å…¥ CriticalSectionï¼Œæˆ‘å€‘çŸ¥é“å¿…é ˆ
        // åœ¨è‡¨ç•Œå€å…§æ“ä½œï¼Œå› æ­¤å¯ä»¥æ”¾å¿ƒä½¿ç”¨é€™å€‹ unsafe å€å¡Šï¼ˆå‘¼å«
        // UnsafeCell::get æ‰€å¿…éœ€ï¼‰ã€‚
        unsafe { *self.0.get() = 0 };
    }

    pub fn increment(&amp;self, _cs: &amp;interrupt::CriticalSection) {
        unsafe { *self.0.get() += 1 };
    }
}

// å…è¨± static CSCounter æ‰€éœ€ï¼Œè©³è¦‹ä¸‹æ–¹èªªæ˜ã€‚
unsafe impl Sync for CSCounter {}

// COUNTER å› ä½¿ç”¨å…§éƒ¨å¯è®Šæ€§è€Œä¸å†æ˜¯ `mut`ï¼›
// å› æ­¤å­˜å–å®ƒä¹Ÿä¸å†éœ€è¦ unsafe å€å¡Šã€‚
static COUNTER: CSCounter = CS_COUNTER_INIT;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            // é€™è£¡æ²’æœ‰ unsafeï¼
            interrupt::free(|cs| COUNTER.increment(cs));
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // æˆ‘å€‘ä»éœ€é€²å…¥è‡¨ç•Œå€æ‰èƒ½å–å¾—æœ‰æ•ˆçš„ cs tokenï¼Œ
    // å³ä¾¿æˆ‘å€‘çŸ¥é“æ²’æœ‰å…¶ä»–ä¸­æ–·èƒ½æ¶å é€™å€‹ä¸­æ–·ã€‚
    interrupt::free(|cs| COUNTER.reset(cs));

    // å¦‚æœçœŸçš„æƒ³é¿å…é–‹éŠ·ï¼Œæˆ‘å€‘å¯ä»¥ç”¨ unsafe ç”¢ç”Ÿå‡çš„ CriticalSectionï¼š
    // let cs = unsafe { interrupt::CriticalSection::new() };
}</code></pre>
<p>æˆ‘å€‘æŠŠ <code>unsafe</code> ç¨‹å¼ç¢¼ç§»åˆ°ç²¾å¿ƒè¨­è¨ˆçš„æŠ½è±¡å…§éƒ¨ï¼Œç¾åœ¨æ‡‰ç”¨ç¨‹å¼ç¢¼ä¸å†å«æœ‰ä»»ä½• <code>unsafe</code> å€å¡Šã€‚</p>
<p>This design requires that the application pass a <code>CriticalSection</code> token in: these tokens are only safely generated by <code>interrupt::free</code>, so by requiring one be passed in, we ensure we are operating inside a critical section, without having to actually do the lock ourselves. This guarantee is provided statically by the compiler: there wonâ€™t be any runtime overhead associated with <code>cs</code>. If we had multiple counters, they could all be given the same <code>cs</code>, without requiring multiple nested critical sections.</p>
<p>This also brings up an important topic for concurrency in Rust: the <a href="https://doc.rust-lang.org/nomicon/send-and-sync.html"><code>Send</code> and <code>Sync</code></a> traits. To summarise the Rust book, a type is Send when it can safely be moved to another thread, while it is Sync when it can be safely shared between multiple threads. In an embedded context, we consider interrupts to be executing in a separate thread to the application code, so variables accessed by both an interrupt and the main code must be Sync.</p>
<p>For most types in Rust, both of these traits are automatically derived for you by the compiler. However, because <code>CSCounter</code> contains an <a href="https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>, it is not Sync, and therefore we could not make a <code>static CSCounter</code>: <code>static</code> variables <em>must</em> be Sync, since they can be accessed by multiple threads.</p>
<p>To tell the compiler we have taken care that the <code>CSCounter</code> is in fact safe to share between threads, we implement the Sync trait explicitly. As with the previous use of critical sections, this is only safe on single-core platforms: with multiple cores, you would need to go to greater lengths to ensure safety.</p>
<h2 id="mutexes"><a class="header" href="#mutexes">Mutexes</a></h2>
<p>Weâ€™ve created a useful abstraction specific to our counter problem, but there are many common abstractions used for concurrency.</p>
<p>One such <em>synchronisation primitive</em> is a mutex, short for mutual exclusion. These constructs ensure exclusive access to a variable, such as our counter. A thread can attempt to <em>lock</em> (or <em>acquire</em>) the mutex, and either succeeds immediately, or blocks waiting for the lock to be acquired, or returns an error that the mutex could not be locked. While that thread holds the lock, it is granted access to the protected data. When the thread is done, it <em>unlocks</em> (or <em>releases</em>) the mutex, allowing another thread to lock it. In Rust, we would usually implement the unlock using the <a href="https://doc.rust-lang.org/core/ops/trait.Drop.html"><code>Drop</code></a> trait to ensure it is always released when the mutex goes out of scope.</p>
<p>Using a mutex with interrupt handlers can be tricky: it is not normally acceptable for the interrupt handler to block, and it would be especially disastrous for it to block waiting for the main thread to release a lock, since we would then <em>deadlock</em> (the main thread will never release the lock because execution stays in the interrupt handler). Deadlocking is not considered unsafe: it is possible even in safe Rust.</p>
<p>To avoid this behaviour entirely, we could implement a mutex which requires a critical section to lock, just like our counter example. So long as the critical section must last as long as the lock, we can be sure we have exclusive access to the wrapped variable without even needing to track the lock/unlock state of the mutex.</p>
<p>This is in fact done for us in the <code>cortex_m</code> crate! We could have written our counter using it:</p>
<pre><code class="language-rust ignore">use core::cell::Cell;
use cortex_m::interrupt::Mutex;

static COUNTER: Mutex&lt;Cell&lt;u32&gt;&gt; = Mutex::new(Cell::new(0));

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            interrupt::free(|cs|
                COUNTER.borrow(cs).set(COUNTER.borrow(cs).get() + 1));
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // We still need to enter a critical section here to satisfy the Mutex.
    interrupt::free(|cs| COUNTER.borrow(cs).set(0));
}</code></pre>
<p>Weâ€™re now using <a href="https://doc.rust-lang.org/core/cell/struct.Cell.html"><code>Cell</code></a>, which along with its sibling <code>RefCell</code> is used to provide safe interior mutability. Weâ€™ve already seen <code>UnsafeCell</code> which is the bottom layer of interior mutability in Rust: it allows you to obtain multiple mutable references to its value, but only with unsafe code. A <code>Cell</code> is like an <code>UnsafeCell</code> but it provides a safe interface: it only permits taking a copy of the current value or replacing it, not taking a reference, and since it is not Sync, it cannot be shared between threads. These constraints mean itâ€™s safe to use, but we couldnâ€™t use it directly in a <code>static</code> variable as a <code>static</code> must be Sync.</p>
<p>So why does the example above work? The <code>Mutex&lt;T&gt;</code> implements Sync for any <code>T</code> which is Send â€” such as a <code>Cell</code>. It can do this safely because it only gives access to its contents during a critical section. Weâ€™re therefore able to get a safe counter with no unsafe code at all!</p>
<p>This is great for simple types like the <code>u32</code> of our counter, but what about more complex types which are not Copy? An extremely common example in an embedded context is a peripheral struct, which generally is not Copy. For that, we can turn to <code>RefCell</code>.</p>
<h2 id="sharing-peripherals"><a class="header" href="#sharing-peripherals">Sharing Peripherals</a></h2>
<p>Device crates generated using <code>svd2rust</code> and similar abstractions provide safe access to peripherals by enforcing that only one instance of the peripheral struct can exist at a time. This ensures safety, but makes it difficult to access a peripheral from both the main thread and an interrupt handler.</p>
<p>To safely share peripheral access, we can use the <code>Mutex</code> we saw before. Weâ€™ll also need to use <a href="https://doc.rust-lang.org/core/cell/struct.RefCell.html"><code>RefCell</code></a>, which uses a runtime check to ensure only one reference to a peripheral is given out at a time. This has more overhead than the plain <code>Cell</code>, but since we are giving out references rather than copies, we must be sure only one exists at a time.</p>
<p>Finally, weâ€™ll also have to account for somehow moving the peripheral into the shared variable after it has been initialised in the main code. To do this we can use the <code>Option</code> type, initialised to <code>None</code> and later set to the instance of the peripheral.</p>
<pre><code class="language-rust ignore">use core::cell::RefCell;
use cortex_m::interrupt::{self, Mutex};
use stm32f4::stm32f405;

static MY_GPIO: Mutex&lt;RefCell&lt;Option&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(None));

#[entry]
fn main() -&gt; ! {
    // Obtain the peripheral singletons and configure it.
    // This example is from an svd2rust-generated crate, but
    // most embedded device crates will be similar.
    let dp = stm32f405::Peripherals::take().unwrap();
    let gpioa = &amp;dp.GPIOA;

    // Some sort of configuration function.
    // Assume it sets PA0 to an input and PA1 to an output.
    configure_gpio(gpioa);

    // Store the GPIOA in the mutex, moving it.
    interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));
    // We can no longer use `gpioa` or `dp.GPIOA`, and instead have to
    // access it via the mutex.

    // Be careful to enable the interrupt only after setting MY_GPIO:
    // otherwise the interrupt might fire while it still contains None,
    // and as-written (with `unwrap()`), it would panic.
    set_timer_1hz();
    let mut last_state = false;
    loop {
        // We'll now read state as a digital input, via the mutex
        let state = interrupt::free(|cs| {
            let gpioa = MY_GPIO.borrow(cs).borrow();
            gpioa.as_ref().unwrap().idr.read().idr0().bit_is_set()
        });

        if state &amp;&amp; !last_state {
            // Set PA1 high if we've seen a rising edge on PA0.
            interrupt::free(|cs| {
                let gpioa = MY_GPIO.borrow(cs).borrow();
                gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    // This time in the interrupt we'll just clear PA0.
    interrupt::free(|cs| {
        // We can use `unwrap()` because we know the interrupt wasn't enabled
        // until after MY_GPIO was set; otherwise we should handle the potential
        // for a None value.
        let gpioa = MY_GPIO.borrow(cs).borrow();
        gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().clear_bit());
    });
}</code></pre>
<p>Thatâ€™s quite a lot to take in, so letâ€™s break down the important lines.</p>
<pre><code class="language-rust ignore">static MY_GPIO: Mutex&lt;RefCell&lt;Option&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(None));</code></pre>
<p>Our shared variable is now a <code>Mutex</code> around a <code>RefCell</code> which contains an <code>Option</code>. The <code>Mutex</code> ensures we only have access during a critical section, and therefore makes the variable Sync, even though a plain <code>RefCell</code> would not be Sync. The <code>RefCell</code> gives us interior mutability with references, which weâ€™ll need to use our <code>GPIOA</code>. The <code>Option</code> lets us initialise this variable to something empty, and only later actually move the variable in. We cannot access the peripheral singleton statically, only at runtime, so this is required.</p>
<pre><code class="language-rust ignore">interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));</code></pre>
<p>Inside a critical section we can call <code>borrow()</code> on the mutex, which gives us a reference to the <code>RefCell</code>. We then call <code>replace()</code> to move our new value into the <code>RefCell</code>.</p>
<pre><code class="language-rust ignore">interrupt::free(|cs| {
    let gpioa = MY_GPIO.borrow(cs).borrow();
    gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
});</code></pre>
<p>Finally, we use <code>MY_GPIO</code> in a safe and concurrent fashion. The critical section prevents the interrupt firing as usual, and lets us borrow the mutex.  The <code>RefCell</code> then gives us an <code>&amp;Option&lt;GPIOA&gt;</code>, and tracks how long it remains borrowed - once that reference goes out of scope, the <code>RefCell</code> will be updated to indicate it is no longer borrowed.</p>
<p>Since we canâ€™t move the <code>GPIOA</code> out of the <code>&amp;Option</code>, we need to convert it to an <code>&amp;Option&lt;&amp;GPIOA&gt;</code> with <code>as_ref()</code>, which we can finally <code>unwrap()</code> to obtain the <code>&amp;GPIOA</code> which lets us modify the peripheral.</p>
<p>If we need a mutable reference to a shared resource, then <code>borrow_mut</code> and <code>deref_mut</code> should be used instead. The following code shows an example using the TIM2 timer.</p>
<pre><code class="language-rust ignore">use core::cell::RefCell;
use core::ops::DerefMut;
use cortex_m::interrupt::{self, Mutex};
use cortex_m::asm::wfi;
use stm32f4::stm32f405;

static G_TIM: Mutex&lt;RefCell&lt;Option&lt;Timer&lt;stm32::TIM2&gt;&gt;&gt;&gt; =
	Mutex::new(RefCell::new(None));

#[entry]
fn main() -&gt; ! {
    let mut cp = cm::Peripherals::take().unwrap();
    let dp = stm32f405::Peripherals::take().unwrap();

    // Some sort of timer configuration function.
    // Assume it configures the TIM2 timer, its NVIC interrupt,
    // and finally starts the timer.
    let tim = configure_timer_interrupt(&amp;mut cp, dp);

    interrupt::free(|cs| {
        G_TIM.borrow(cs).replace(Some(tim));
    });

    loop {
        wfi();
    }
}

#[interrupt]
fn timer() {
    interrupt::free(|cs| {
        if let Some(ref mut tim)) =  G_TIM.borrow(cs).borrow_mut().deref_mut() {
            tim.start(1.hz());
        }
    });
}
</code></pre>
<p>Whew! This is safe, but it is also a little unwieldy. Is there anything else we can do?</p>
<h2 id="rtic"><a class="header" href="#rtic">RTIC</a></h2>
<p>One alternative is the <a href="https://github.com/rtic-rs/cortex-m-rtic">RTIC framework</a>, short for Real Time Interrupt-driven Concurrency. It enforces static priorities and tracks accesses to <code>static mut</code> variables (â€œresourcesâ€) to statically ensure that shared resources are always accessed safely, without requiring the overhead of always entering critical sections and using reference counting (as in <code>RefCell</code>). This has a number of advantages such as guaranteeing no deadlocks and giving extremely low time and memory overhead.</p>
<p>The framework also includes other features like message passing, which reduces the need for explicit shared state, and the ability to schedule tasks to run at a given time, which can be used to implement periodic tasks. Check out <a href="https://rtic.rs">the documentation</a> for more information!</p>
<h2 id="real-time-operating-systems"><a class="header" href="#real-time-operating-systems">Real Time Operating Systems</a></h2>
<p>Another common model for embedded concurrency is the real-time operating system (RTOS). While currently less well explored in Rust, they are widely used in traditional embedded development. Open source examples include <a href="https://freertos.org/">FreeRTOS</a> and <a href="http://chibios.org/">ChibiOS</a>. These RTOSs provide support for running multiple application threads which the CPU swaps between, either when the threads yield control (called cooperative multitasking) or based on a regular timer or interrupts (preemptive multitasking). The RTOS typically provide mutexes and other synchronisation primitives, and often interoperate with hardware features such as DMA engines.</p>
<p>At the time of writing, there are not many Rust RTOS examples to point to, but itâ€™s an interesting area so watch this space!</p>
<h2 id="multiple-cores"><a class="header" href="#multiple-cores">Multiple Cores</a></h2>
<p>It is becoming more common to have two or more cores in embedded processors, which adds an extra layer of complexity to concurrency. All the examples using a critical section (including the <code>cortex_m::interrupt::Mutex</code>) assume the only other execution thread is the interrupt thread, but on a multi-core system thatâ€™s no longer true. Instead, weâ€™ll need synchronisation primitives designed for multiple cores (also called SMP, for symmetric multi-processing).</p>
<p>These typically use the atomic instructions we saw earlier, since the processing system will ensure that atomicity is maintained over all cores.</p>
<p>Covering these topics in detail is currently beyond the scope of this book, but the general patterns are the same as for the single-core case.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="é›†åˆ"><a class="header" href="#é›†åˆ">é›†åˆ</a></h1>
<p>æœ€çµ‚ä½ æœƒæƒ³åœ¨ç¨‹å¼ä¸­ä½¿ç”¨å‹•æ…‹è³‡æ–™çµæ§‹ï¼ˆäº¦å³é›†åˆï¼‰ã€‚<code>std</code> æä¾›ä¸€çµ„å¸¸è¦‹é›†åˆï¼š<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>ã€<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>ã€<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> ç­‰ã€‚<code>std</code> ä¸­å¯¦ä½œçš„æ‰€æœ‰é›†åˆéƒ½ä½¿ç”¨å…¨åŸŸå‹•æ…‹è¨˜æ†¶é«”é…ç½®å™¨ï¼ˆäº¦å³å †ç©ï¼‰ã€‚</p>
<p>ç”±æ–¼ <code>core</code> å®šç¾©ä¸Šä¸å«è¨˜æ†¶é«”é…ç½®ï¼Œå› æ­¤é€™äº›å¯¦ä½œåœ¨é‚£è£¡ä¸å¯ç”¨ï¼Œä½†å¯åœ¨éš¨ç·¨è­¯å™¨æä¾›çš„ <code>alloc</code> å¥—ä»¶ä¸­æ‰¾åˆ°ã€‚</p>
<p>å¦‚æœä½ éœ€è¦é›†åˆï¼Œå †ç©é…ç½®çš„å¯¦ä½œä¸¦éå”¯ä¸€é¸æ“‡ã€‚ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨_å›ºå®šå®¹é‡_é›†åˆï¼›å…¶ä¸­ä¸€ç¨®å¯¦ä½œå¯è¦‹æ–¼ <a href="https://crates.io/crates/heapless"><code>heapless</code></a> å¥—ä»¶ã€‚</p>
<p>åœ¨æœ¬ç¯€ä¸­ï¼Œæˆ‘å€‘æœƒæ¢ç´¢ä¸¦æ¯”è¼ƒé€™å…©ç¨®å¯¦ä½œã€‚</p>
<h2 id="ä½¿ç”¨-alloc"><a class="header" href="#ä½¿ç”¨-alloc">ä½¿ç”¨ <code>alloc</code></a></h2>
<p><code>alloc</code> å¥—ä»¶éš¨æ¨™æº– Rust ç™¼è¡Œç‰ˆä¸€åŒæä¾›ã€‚è¦åŒ¯å…¥æ­¤å¥—ä»¶ï¼Œä½ å¯ä»¥ç›´æ¥ <code>use</code> å®ƒï¼Œ<em>ä¸éœ€è¦</em> åœ¨ <code>Cargo.toml</code> ä¸­å®£å‘Šç›¸ä¾ã€‚</p>
<pre><code class="language-rust ignore">#![feature(alloc)]

extern crate alloc;

use alloc::vec::Vec;</code></pre>
<p>è¦èƒ½ä½¿ç”¨ä»»ä½•é›†åˆï¼Œä½ é¦–å…ˆéœ€è¦ç”¨ <code>global_allocator</code> å±¬æ€§å®£å‘Šç¨‹å¼æ‰€ä½¿ç”¨çš„å…¨åŸŸé…ç½®å™¨ã€‚ä½ é¸æ“‡çš„é…ç½®å™¨å¿…é ˆå¯¦ä½œ <a href="https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> traitã€‚</p>
<p>ç‚ºäº†å®Œæ•´æ€§ä¸¦ç›¡é‡è®“æœ¬ç¯€è‡ªè¶³ï¼Œæˆ‘å€‘æœƒå¯¦ä½œä¸€å€‹ç°¡å–®çš„æŒ‡æ¨™éå¢ï¼ˆbump pointerï¼‰é…ç½®å™¨ä¸¦å°‡å…¶ä½œç‚ºå…¨åŸŸé…ç½®å™¨ã€‚ç„¶è€Œï¼Œæˆ‘å€‘_å¼·çƒˆ_å»ºè­°ä½ åœ¨ç¨‹å¼ä¸­ä½¿ç”¨ crates.io ä¸Šä¹…ç¶“è€ƒé©—çš„é…ç½®å™¨ï¼Œè€Œä¸æ˜¯æ­¤é…ç½®å™¨ã€‚</p>
<pre><code class="language-rust ignore">// æŒ‡æ¨™éå¢é…ç½®å™¨å¯¦ä½œ

use core::alloc::{GlobalAlloc, Layout};
use core::cell::UnsafeCell;
use core::ptr;

use cortex_m::interrupt;

// é©ç”¨æ–¼*å–®æ ¸å¿ƒ*ç³»çµ±çš„æŒ‡æ¨™éå¢é…ç½®å™¨
struct BumpPointerAlloc {
    head: UnsafeCell&lt;usize&gt;,
    end: usize,
}

unsafe impl Sync for BumpPointerAlloc {}

unsafe impl GlobalAlloc for BumpPointerAlloc {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        // `interrupt::free` æ˜¯è‡¨ç•Œå€ï¼Œè®“æˆ‘å€‘çš„é…ç½®å™¨å¯å®‰å…¨
        // åœ¨ä¸­æ–·å…§ä½¿ç”¨
        interrupt::free(|_| {
            let head = self.head.get();
            let size = layout.size();
            let align = layout.align();
            let align_mask = !(align - 1);

            // å°‡èµ·é»ç§»åˆ°ä¸‹ä¸€å€‹å°é½Šé‚Šç•Œ
            let start = (*head + align - 1) &amp; align_mask;

            if start + size &gt; self.end {
                // ç©ºæŒ‡æ¨™ä»£è¡¨è¨˜æ†¶é«”ä¸è¶³ï¼ˆOOMï¼‰
                ptr::null_mut()
            } else {
                *head = start + size;
                start as *mut u8
            }
        })
    }

    unsafe fn dealloc(&amp;self, _: *mut u8, _: Layout) {
        // æ­¤é…ç½®å™¨å¾ä¸é‡‹æ”¾è¨˜æ†¶é«”
    }
}

// å…¨åŸŸè¨˜æ†¶é«”é…ç½®å™¨çš„å®£å‘Š
// æ³¨æ„ï¼šä½¿ç”¨è€…å¿…é ˆç¢ºä¿è¨˜æ†¶é«”å€åŸŸ `[0x2000_0100, 0x2000_0200]`
// æœªè¢«ç¨‹å¼çš„å…¶ä»–éƒ¨åˆ†ä½¿ç”¨
#[global_allocator]
static HEAP: BumpPointerAlloc = BumpPointerAlloc {
    head: UnsafeCell::new(0x2000_0100),
    end: 0x2000_0200,
};</code></pre>
<p>é™¤äº†é¸æ“‡å…¨åŸŸé…ç½®å™¨ä¹‹å¤–ï¼Œä½¿ç”¨è€…é‚„å¿…é ˆä½¿ç”¨_ä¸ç©©å®š_çš„ <code>alloc_error_handler</code> å±¬æ€§ä¾†å®šç¾©å¦‚ä½•è™•ç†è¨˜æ†¶é«”ä¸è¶³ï¼ˆOOMï¼‰éŒ¯èª¤ã€‚</p>
<pre><code class="language-rust ignore">#![feature(alloc_error_handler)]

use cortex_m::asm;

#[alloc_error_handler]
fn on_oom(_layout: Layout) -&gt; ! {
    asm::bkpt();

    loop {}
}</code></pre>
<p>ç•¶ä¸Šè¿°ä¸€åˆ‡å°±ç·’å¾Œï¼Œä½¿ç”¨è€…çµ‚æ–¼å¯ä»¥ä½¿ç”¨ <code>alloc</code> ä¸­çš„é›†åˆã€‚</p>
<pre><code class="language-rust ignore">#[entry]
fn main() -&gt; ! {
    let mut xs = Vec::new();

    xs.push(42);
    assert!(xs.pop(), Some(42));

    loop {
        // ..
    }
}</code></pre>
<p>å¦‚æœä½ ç”¨é <code>std</code> å¥—ä»¶çš„é›†åˆï¼Œé€™äº›æœƒå¾ˆç†Ÿæ‚‰ï¼Œå› ç‚ºå¯¦ä½œå®Œå…¨ç›¸åŒã€‚</p>
<h2 id="ä½¿ç”¨-heapless"><a class="header" href="#ä½¿ç”¨-heapless">ä½¿ç”¨ <code>heapless</code></a></h2>
<p><code>heapless</code> ä¸éœ€è¦ä»»ä½•è¨­å®šï¼Œå› ç‚ºå…¶é›†åˆä¸ä¾è³´å…¨åŸŸè¨˜æ†¶é«”é…ç½®å™¨ã€‚åªè¦ <code>use</code> å…¶é›†åˆä¸¦ç›´æ¥å»ºç«‹å¯¦ä¾‹å³å¯ï¼š</p>
<pre><code class="language-rust ignore">// heapless ç‰ˆæœ¬ï¼šv0.4.x
use heapless::Vec;
use heapless::consts::*;

#[entry]
fn main() -&gt; ! {
    let mut xs: Vec&lt;_, U8&gt; = Vec::new();

    xs.push(42).unwrap();
    assert_eq!(xs.pop(), Some(42));
    loop {}
}</code></pre>
<p>ä½ æœƒæ³¨æ„åˆ°é€™äº›é›†åˆèˆ‡ <code>alloc</code> ä¸­çš„é›†åˆæœ‰å…©å€‹å·®ç•°ã€‚</p>
<p>ç¬¬ä¸€ï¼Œä½ å¿…é ˆäº‹å…ˆå®£å‘Šé›†åˆå®¹é‡ã€‚<code>heapless</code> é›†åˆä¸æœƒé‡æ–°é…ç½®ï¼Œä¸”å®¹é‡å›ºå®šï¼›å®¹é‡æ˜¯é›†åˆå‹åˆ¥ç°½åçš„ä¸€éƒ¨åˆ†ã€‚åœ¨æ­¤ä¾‹ä¸­ï¼Œæˆ‘å€‘å®£å‘Š <code>xs</code> å®¹é‡ç‚º 8 å€‹å…ƒç´ ï¼Œä¹Ÿå°±æ˜¯é€™å€‹å‘é‡æœ€å¤šåªèƒ½å®¹ç´ 8 å€‹å…ƒç´ ã€‚é€™æœƒåœ¨å‹åˆ¥ç°½åä¸­ä»¥ <code>U8</code> è¡¨ç¤ºï¼ˆè¦‹<a href="https://crates.io/crates/typenum"><code>typenum</code></a>ï¼‰ã€‚</p>
<p>ç¬¬äºŒï¼Œ<code>push</code> èˆ‡è¨±å¤šå…¶ä»–æ–¹æ³•æœƒå›å‚³ <code>Result</code>ã€‚ç”±æ–¼ <code>heapless</code> é›†åˆå®¹é‡å›ºå®šï¼Œæ‰€æœ‰æ’å…¥å…ƒç´ çš„æ“ä½œéƒ½æœ‰å¯èƒ½å¤±æ•—ã€‚API é€éå›å‚³ <code>Result</code> ä¾†åæ˜ æ­¤å•é¡Œï¼Œä»¥è¡¨ç¤ºæ“ä½œæ˜¯å¦æˆåŠŸã€‚ç›¸è¼ƒä¹‹ä¸‹ï¼Œ<code>alloc</code> é›†åˆæœƒåœ¨å †ç©ä¸Šé‡æ–°é…ç½®ä»¥æ“´å¢å®¹é‡ã€‚</p>
<p>æˆªè‡³ v0.4.x ç‰ˆæœ¬ï¼Œæ‰€æœ‰ <code>heapless</code> é›†åˆéƒ½å°‡å…ƒç´ å…§åµŒå­˜æ”¾ã€‚é€™æ„å‘³è‘—åƒ <code>let x = heapless::Vec::new();</code> é€™æ¨£çš„æ“ä½œæœƒåœ¨å †ç–Šä¸Šé…ç½®é›†åˆï¼Œä½†ä¹Ÿå¯ä»¥å°‡é›†åˆé…ç½®åœ¨ <code>static</code> è®Šæ•¸ä¸Šï¼Œç”šè‡³æ”¾åœ¨å †ç©ä¸Šï¼ˆ<code>Box&lt;Vec&lt;_, _&gt;&gt;</code>ï¼‰ã€‚</p>
<h2 id="å–æ¨"><a class="header" href="#å–æ¨">å–æ¨</a></h2>
<p>åœ¨é¸æ“‡å¯åœ¨å †ç©é…ç½®ã€å¯æ¬ç§»çš„é›†åˆèˆ‡å›ºå®šå®¹é‡é›†åˆæ™‚ï¼Œè«‹è¨˜ä½ä»¥ä¸‹é‡é»ã€‚</p>
<h3 id="è¨˜æ†¶é«”ä¸è¶³èˆ‡éŒ¯èª¤è™•ç†"><a class="header" href="#è¨˜æ†¶é«”ä¸è¶³èˆ‡éŒ¯èª¤è™•ç†">è¨˜æ†¶é«”ä¸è¶³èˆ‡éŒ¯èª¤è™•ç†</a></h3>
<p>ä½¿ç”¨å †ç©é…ç½®æ™‚ï¼Œè¨˜æ†¶é«”ä¸è¶³ç¸½æ˜¯æœ‰å¯èƒ½ç™¼ç”Ÿï¼Œä¸”å¯èƒ½å‡ºç¾åœ¨é›†åˆéœ€è¦æˆé•·çš„ä»»ä½•åœ°æ–¹ï¼šä¾‹å¦‚æ‰€æœ‰ <code>alloc::Vec.push</code> éƒ½å¯èƒ½å¼•ç™¼ OOMã€‚å› æ­¤æŸäº›æ“ä½œå¯èƒ½æœƒ_éš±å«_å¤±æ•—ã€‚æœ‰äº› <code>alloc</code> é›†åˆæä¾› <code>try_reserve</code> æ–¹æ³•ï¼Œè®“ä½ åœ¨æ“´å……é›†åˆæ™‚æª¢æŸ¥å¯èƒ½çš„ OOM ç‹€æ³ï¼Œä½†ä½ å¿…é ˆä¸»å‹•ä½¿ç”¨å®ƒå€‘ã€‚</p>
<p>è‹¥ä½ åªä½¿ç”¨ <code>heapless</code> é›†åˆï¼Œä¸”ä¸æŠŠè¨˜æ†¶é«”é…ç½®å™¨ç”¨æ–¼å…¶ä»–ç”¨é€”ï¼Œé‚£éº¼ OOM å°±ä¸å¯èƒ½ç™¼ç”Ÿã€‚å–è€Œä»£ä¹‹ï¼Œä½ å¿…é ˆé€æ¡ˆè™•ç†é›†åˆå®¹é‡è€—ç›¡çš„æƒ…æ³ã€‚ä¹Ÿå°±æ˜¯èªªï¼Œä½ å¿…é ˆè™•ç†åƒ <code>Vec.push</code> é€™é¡æ–¹æ³•å›å‚³çš„_æ‰€æœ‰_ <code>Result</code>ã€‚</p>
<p>OOM å¤±æ•—å¯èƒ½æ¯”åœ¨ <code>heapless::Vec.push</code> å›å‚³çš„æ‰€æœ‰ <code>Result</code> ä¸Šåš <code>unwrap</code> æ›´é›£é™¤éŒ¯ï¼Œå› ç‚ºè§€å¯Ÿåˆ°çš„å¤±æ•—ä½ç½®å¯èƒ½_ä¸_ç­‰æ–¼å•é¡ŒåŸå› çš„ä½ç½®ã€‚ä¾‹å¦‚ï¼Œå¦‚æœé…ç½®å™¨å¹¾ä¹è€—ç›¡ï¼Œå³ä½¿ <code>vec.reserve(1)</code> ä¹Ÿå¯èƒ½è§¸ç™¼ OOMï¼ŒåŸå› å¯èƒ½æ˜¯å…¶ä»–é›†åˆåœ¨æ´©æ¼è¨˜æ†¶é«”ï¼ˆå®‰å…¨ Rust ä¹Ÿå¯èƒ½ç™¼ç”Ÿè¨˜æ†¶é«”æ´©æ¼ï¼‰ã€‚</p>
<h3 id="è¨˜æ†¶é«”ä½¿ç”¨"><a class="header" href="#è¨˜æ†¶é«”ä½¿ç”¨">è¨˜æ†¶é«”ä½¿ç”¨</a></h3>
<p>æ¨è«–å †ç©é…ç½®é›†åˆçš„è¨˜æ†¶é«”ç”¨é‡å¾ˆå›°é›£ï¼Œå› ç‚ºé•·ç”Ÿå‘½é€±æœŸé›†åˆçš„å®¹é‡å¯åœ¨åŸ·è¡ŒæœŸè®Šå‹•ã€‚æœ‰äº›æ“ä½œå¯èƒ½æœƒéš±å«åœ°é‡æ–°é…ç½®é›†åˆä¸¦å¢åŠ è¨˜æ†¶é«”ç”¨é‡ï¼Œæœ‰äº›é›†åˆæä¾›åƒ <code>shrink_to_fit</code> çš„æ–¹æ³•ï¼Œå¯èƒ½é™ä½é›†åˆçš„è¨˜æ†¶é«”ä½¿ç”¨é‡â€”â€”æœ€çµ‚æ˜¯å¦å¯¦éš›ç¸®æ¸›é…ç½®ä»å–æ±ºæ–¼é…ç½®å™¨ã€‚æ­¤å¤–ï¼Œé…ç½®å™¨å¯èƒ½é‚„éœ€è™•ç†è¨˜æ†¶é«”ç¢ç‰‡åŒ–ï¼Œé€™æœƒå¢åŠ _è¡¨è§€_è¨˜æ†¶é«”ç”¨é‡ã€‚</p>
<p>å¦ä¸€æ–¹é¢ï¼Œè‹¥ä½ åªä½¿ç”¨å›ºå®šå®¹é‡é›†åˆã€å°‡å¤§å¤šæ•¸æ”¾åœ¨ <code>static</code> è®Šæ•¸ä¸­ï¼Œä¸¦ç‚ºå‘¼å«å †ç–Šè¨­å®šæœ€å¤§å¤§å°ï¼Œé‚£éº¼é€£çµå™¨æœƒåœ¨ä½ å˜—è©¦ä½¿ç”¨è¶…éå¯¦é«”å¯ç”¨è¨˜æ†¶é«”æ™‚åµæ¸¬åˆ°ã€‚</p>
<p>æ­¤å¤–ï¼Œå †ç–Šä¸Šé…ç½®çš„å›ºå®šå®¹é‡é›†åˆæœƒè¢« <a href="https://doc.rust-lang.org/beta/unstable-book/compiler-flags/emit-stack-sizes.html"><code>-Z emit-stack-sizes</code></a> æ——æ¨™å›å ±ï¼Œé€™è¡¨ç¤ºåˆ†æå †ç–Šä½¿ç”¨é‡çš„å·¥å…·ï¼ˆå¦‚ <a href="https://crates.io/crates/stack-sizes"><code>stack-sizes</code></a>ï¼‰æœƒå°‡å®ƒå€‘ç´å…¥åˆ†æã€‚</p>
<p>ç„¶è€Œï¼Œå›ºå®šå®¹é‡é›†åˆ_ç„¡æ³•_ç¸®å°ï¼Œé€™å¯èƒ½å°è‡´è£è¼‰ç‡ï¼ˆé›†åˆå¤§å°èˆ‡å®¹é‡çš„æ¯”ä¾‹ï¼‰ä½æ–¼å¯æ¬ç§»é›†åˆæ‰€èƒ½é”åˆ°çš„ç¨‹åº¦ã€‚</p>
<h3 id="æœ€å£åŸ·è¡Œæ™‚é–“wcet"><a class="header" href="#æœ€å£åŸ·è¡Œæ™‚é–“wcet">æœ€å£åŸ·è¡Œæ™‚é–“ï¼ˆWCETï¼‰</a></h3>
<p>å¦‚æœä½ åœ¨æ‰“é€ æ™‚é–“æ•æ„Ÿæˆ–ç¡¬å³æ™‚çš„æ‡‰ç”¨ç¨‹å¼ï¼Œé‚£éº¼ä½ æœƒéå¸¸åœ¨æ„ç¨‹å¼å„éƒ¨åˆ†çš„æœ€å£åŸ·è¡Œæ™‚é–“ã€‚</p>
<p><code>alloc</code> é›†åˆå¯ä»¥é‡æ–°é…ç½®ï¼Œå› æ­¤å¯èƒ½å¢é•·é›†åˆçš„æ“ä½œï¼Œå…¶ WCET ä¹ŸåŒ…å«é‡æ–°é…ç½®æ‰€éœ€çš„æ™‚é–“ï¼Œè€Œé€™åˆå–æ±ºæ–¼é›†åˆçš„_åŸ·è¡ŒæœŸ_å®¹é‡ã€‚é€™ä½¿å¾—åƒ <code>alloc::Vec.push</code> é€™æ¨£çš„æ“ä½œé›£ä»¥ç¢ºå®š WCETï¼Œå› ç‚ºå®ƒå–æ±ºæ–¼ä½¿ç”¨çš„é…ç½®å™¨èˆ‡åŸ·è¡ŒæœŸå®¹é‡ã€‚</p>
<p>å¦ä¸€æ–¹é¢ï¼Œå›ºå®šå®¹é‡é›†åˆå¾ä¸é‡æ–°é…ç½®ï¼Œå› æ­¤æ‰€æœ‰æ“ä½œéƒ½æœ‰å¯é æ¸¬çš„åŸ·è¡Œæ™‚é–“ã€‚ä¾‹å¦‚ï¼Œ<code>heapless::Vec.push</code> ä»¥å¸¸æ•¸æ™‚é–“åŸ·è¡Œã€‚</p>
<h3 id="æ˜“ç”¨æ€§"><a class="header" href="#æ˜“ç”¨æ€§">æ˜“ç”¨æ€§</a></h3>
<p><code>alloc</code> éœ€è¦è¨­å®šå…¨åŸŸé…ç½®å™¨ï¼Œè€Œ <code>heapless</code> ä¸éœ€è¦ã€‚ç„¶è€Œï¼Œ<code>heapless</code> éœ€è¦ä½ ç‚ºæ¯å€‹å¯¦ä¾‹åŒ–çš„é›†åˆé¸æ“‡å®¹é‡ã€‚</p>
<p><code>alloc</code> çš„ API å¹¾ä¹å°æ¯ä½ Rust é–‹ç™¼è€…éƒ½å¾ˆç†Ÿæ‚‰ã€‚<code>heapless</code> çš„ API å˜—è©¦ç·Šå¯†æ¨¡ä»¿ <code>alloc</code> APIï¼Œä½†å› ç‚ºæ˜ç¢ºçš„éŒ¯èª¤è™•ç†ï¼Œå®ƒæ°¸é ä¸å¯èƒ½å®Œå…¨ç›¸åŒâ€”â€”æœ‰äº›é–‹ç™¼è€…å¯èƒ½è¦ºå¾—æ˜ç¢ºçš„éŒ¯èª¤è™•ç†éæ–¼å†—é•·æˆ–å¤ªç¹ç‘£ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="è¨­è¨ˆæ¨¡å¼"><a class="header" href="#è¨­è¨ˆæ¨¡å¼">è¨­è¨ˆæ¨¡å¼</a></h1>
<p>This chapter aims to collect various useful design patterns for embedded Rust.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hal-è¨­è¨ˆæ¨¡å¼"><a class="header" href="#hal-è¨­è¨ˆæ¨¡å¼">HAL è¨­è¨ˆæ¨¡å¼</a></h1>
<p>This is a set of common and recommended patterns for writing hardware abstraction layers (HALs) for microcontrollers in Rust. These patterns are intended to be used in addition to the existing <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a> when writing HALs for microcontrollers.</p>
<p><a href="#hal-design-patterns-checklist">Checklist</a></p>
<ul>
<li><a href="#å‘½å">Naming</a></li>
<li><a href="#äº’é€šæ€§">Interoperability</a></li>
<li><a href="#å¯é æ¸¬æ€§">Predictability</a></li>
<li><a href="#recommendations-for-gpio-interfaces">GPIO</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="hal-design-patterns-checklist"><a class="header" href="#hal-design-patterns-checklist">HAL Design Patterns Checklist</a></h1>
<ul>
<li><strong>Naming</strong> <em>(crate aligns with Rust naming conventions)</em>
<ul>
<li><input disabled="" type="checkbox"> The crate is named appropriately (<a href="#c-crate-name">C-CRATE-NAME</a>)</li>
</ul>
</li>
<li><strong>Interoperability</strong> <em>(crate interacts nicely with other library functionality)</em>
<ul>
<li><input disabled="" type="checkbox"> Wrapper types provide a destructor method (<a href="#c-free">C-FREE</a>)</li>
<li><input disabled="" type="checkbox"> HALs reexport their register access crate (<a href="#c-reexport-pac">C-REEXPORT-PAC</a>)</li>
<li><input disabled="" type="checkbox"> Types implement the <code>embedded-hal</code> traits (<a href="#c-hal-traits">C-HAL-TRAITS</a>)</li>
</ul>
</li>
<li><strong>Predictability</strong> <em>(crate enables legible code that acts how it looks)</em>
<ul>
<li><input disabled="" type="checkbox"> Constructors are used instead of extension traits (<a href="#c-ctor">C-CTOR</a>)</li>
</ul>
</li>
<li><strong>GPIO Interfaces</strong> <em>(GPIO Interfaces follow a common pattern)</em>
<ul>
<li><input disabled="" type="checkbox"> Pin types are zero-sized by default (<a href="#c-zst-pin">C-ZST-PIN</a>)</li>
<li><input disabled="" type="checkbox"> Pin types provide methods to erase pin and port (<a href="#c-erased-pin">C-ERASED-PIN</a>)</li>
<li><input disabled="" type="checkbox"> Pin state should be encoded as type parameters (<a href="#c-pin-state">C-PIN-STATE</a>)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="å‘½å"><a class="header" href="#å‘½å">å‘½å</a></h1>
<p><a id="c-crate-name"></a></p>
<h2 id="the-crate-is-named-appropriately-c-crate-name"><a class="header" href="#the-crate-is-named-appropriately-c-crate-name">The crate is named appropriately (C-CRATE-NAME)</a></h2>
<p>HAL crates should be named after the chip or family of chips they aim to support. Their name should end with <code>-hal</code> to distinguish them from register access crates. The name should not contain underscores (use dashes instead).</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="äº’é€šæ€§"><a class="header" href="#äº’é€šæ€§">äº’é€šæ€§</a></h1>
<p><a id="c-free"></a></p>
<h2 id="wrapper-types-provide-a-destructor-method-c-free"><a class="header" href="#wrapper-types-provide-a-destructor-method-c-free">Wrapper types provide a destructor method (C-FREE)</a></h2>
<p>Any non-<code>Copy</code> wrapper type provided by the HAL should provide a <code>free</code> method that consumes the wrapper and returns back the raw peripheral (and possibly other objects) it was created from.</p>
<p>The method should shut down and reset the peripheral if necessary. Calling <code>new</code> with the raw peripheral returned by <code>free</code> should not fail due to an unexpected state of the peripheral.</p>
<p>If the HAL type requires other non-<code>Copy</code> objects to be constructed (for example I/O pins), any such object should be released and returned by <code>free</code> as well. <code>free</code> should return a tuple in that case.</p>
<p>For example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct TIMER0;
</span>pub struct Timer(TIMER0);

impl Timer {
    pub fn new(periph: TIMER0) -&gt; Self {
        Self(periph)
    }

    pub fn free(self) -&gt; TIMER0 {
        self.0
    }
}
<span class="boring">}</span></code></pre>
<p><a id="c-reexport-pac"></a></p>
<h2 id="hals-reexport-their-register-access-crate-c-reexport-pac"><a class="header" href="#hals-reexport-their-register-access-crate-c-reexport-pac">HALs reexport their register access crate (C-REEXPORT-PAC)</a></h2>
<p>HALs can be written on top of <a href="https://github.com/rust-embedded/svd2rust">svd2rust</a>-generated PACs, or on top of other crates that provide raw register access. HALs should always reexport the register access crate they are based on in their crate root.</p>
<p>A PAC should be reexported under the name <code>pac</code>, regardless of the actual name of the crate, as the name of the HAL should already make it clear what PAC is being accessed.</p>
<p><a id="c-hal-traits"></a></p>
<h2 id="types-implement-the-embedded-hal-traits-c-hal-traits"><a class="header" href="#types-implement-the-embedded-hal-traits-c-hal-traits">Types implement the <code>embedded-hal</code> traits (C-HAL-TRAITS)</a></h2>
<p>Types provided by the HAL should implement all applicable traits provided by the <a href="https://github.com/rust-embedded/embedded-hal"><code>embedded-hal</code></a> crate.</p>
<p>Multiple traits may be implemented for the same type.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="å¯é æ¸¬æ€§"><a class="header" href="#å¯é æ¸¬æ€§">å¯é æ¸¬æ€§</a></h1>
<p><a id="c-ctor"></a></p>
<h2 id="constructors-are-used-instead-of-extension-traits-c-ctor"><a class="header" href="#constructors-are-used-instead-of-extension-traits-c-ctor">Constructors are used instead of extension traits (C-CTOR)</a></h2>
<p>All peripherals to which the HAL adds functionality should be wrapped in a new type, even if no additional fields are required for that functionality.</p>
<p>Extension traits implemented for the raw peripheral should be avoided.</p>
<p><a id="c-inline"></a></p>
<h2 id="methods-are-decorated-with-inline-where-appropriate-c-inline"><a class="header" href="#methods-are-decorated-with-inline-where-appropriate-c-inline">Methods are decorated with <code>#[inline]</code> where appropriate (C-INLINE)</a></h2>
<p>The Rust compiler does not by default perform full inlining across crate boundaries. As embedded applications are sensitive to unexpected code size increases, <code>#[inline]</code> should be used to guide the compiler as follows:</p>
<ul>
<li>All â€œsmallâ€ functions should be marked <code>#[inline]</code>. What qualifies as â€œsmallâ€ is subjective, but generally all functions that are expected to compile down to single-digit instruction sequences qualify as small.</li>
<li>Functions that are very likely to take constant values as parameters should be marked as <code>#[inline]</code>. This enables the compiler to compute even complicated initialization logic at compile time, provided the function inputs are known.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="recommendations-for-gpio-interfaces"><a class="header" href="#recommendations-for-gpio-interfaces">Recommendations for GPIO Interfaces</a></h1>
<p><a id="c-zst-pin"></a></p>
<h2 id="pin-types-are-zero-sized-by-default-c-zst-pin"><a class="header" href="#pin-types-are-zero-sized-by-default-c-zst-pin">Pin types are zero-sized by default (C-ZST-PIN)</a></h2>
<p>GPIO Interfaces exposed by the HAL should provide dedicated zero-sized types for each pin on every interface or port, resulting in a zero-cost GPIO abstraction when all pin assignments are statically known.</p>
<p>Each GPIO Interface or Port should implement a <code>split</code> method returning a struct with every pin.</p>
<p>Example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PA0;
pub struct PA1;
// ...

pub struct PortA;

impl PortA {
    pub fn split(self) -&gt; PortAPins {
        PortAPins {
            pa0: PA0,
            pa1: PA1,
            // ...
        }
    }
}

pub struct PortAPins {
    pub pa0: PA0,
    pub pa1: PA1,
    // ...
}
<span class="boring">}</span></code></pre>
<p><a id="c-erased-pin"></a></p>
<h2 id="pin-types-provide-methods-to-erase-pin-and-port-c-erased-pin"><a class="header" href="#pin-types-provide-methods-to-erase-pin-and-port-c-erased-pin">Pin types provide methods to erase pin and port (C-ERASED-PIN)</a></h2>
<p>Pins should provide type erasure methods that move their properties from compile time to runtime, and allow more flexibility in applications.</p>
<p>Example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Port A, pin 0.
pub struct PA0;

impl PA0 {
    pub fn erase_pin(self) -&gt; PA {
        PA { pin: 0 }
    }
}

/// A pin on port A.
pub struct PA {
    /// The pin number.
    pin: u8,
}

impl PA {
    pub fn erase_port(self) -&gt; Pin {
        Pin {
            port: Port::A,
            pin: self.pin,
        }
    }
}

pub struct Pin {
    port: Port,
    pin: u8,
    // (these fields can be packed to reduce the memory footprint)
}

enum Port {
    A,
    B,
    C,
    D,
}
<span class="boring">}</span></code></pre>
<p><a id="c-pin-state"></a></p>
<h2 id="pin-state-should-be-encoded-as-type-parameters-c-pin-state"><a class="header" href="#pin-state-should-be-encoded-as-type-parameters-c-pin-state">Pin state should be encoded as type parameters (C-PIN-STATE)</a></h2>
<p>Pins may be configured as input or output with different characteristics depending on the chip or family. This state should be encoded in the type system to prevent use of pins in incorrect states.</p>
<p>Additional, chip-specific state (eg. drive strength) may also be encoded in this way, using additional type parameters.</p>
<p>Methods for changing the pin state should be provided as <code>into_input</code> and <code>into_output</code> methods.</p>
<p>Additionally, <code>with_{input,output}_state</code> methods should be provided that temporarily reconfigure a pin in a different state without moving it.</p>
<p>The following methods should be provided for every pin type (that is, both erased and non-erased pin types should provide the same API):</p>
<ul>
<li>
<p><code>pub fn into_input&lt;N: InputState&gt;(self, input: N) -&gt; Pin&lt;N&gt;</code></p>
</li>
<li>
<p><code>pub fn into_output&lt;N: OutputState&gt;(self, output: N) -&gt; Pin&lt;N&gt;</code></p>
</li>
<li>
<pre><code class="language-ignore">pub fn with_input_state&lt;N: InputState, R&gt;(
    &amp;mut self,
    input: N,
    f: impl FnOnce(&amp;mut PA1&lt;N&gt;) -&gt; R,
) -&gt; R
</code></pre>
</li>
<li>
<pre><code class="language-ignore">pub fn with_output_state&lt;N: OutputState, R&gt;(
    &amp;mut self,
    output: N,
    f: impl FnOnce(&amp;mut PA1&lt;N&gt;) -&gt; R,
) -&gt; R
</code></pre>
</li>
</ul>
<p>Pin state should be bounded by sealed traits. Users of the HAL should have no need to add their own state. The traits can provide HAL-specific methods required to implement the pin state API.</p>
<p>Example:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::marker::PhantomData;
</span>mod sealed {
    pub trait Sealed {}
}

pub trait PinState: sealed::Sealed {}
pub trait OutputState: sealed::Sealed {}
pub trait InputState: sealed::Sealed {
    // ...
}

pub struct Output&lt;S: OutputState&gt; {
    _p: PhantomData&lt;S&gt;,
}

impl&lt;S: OutputState&gt; PinState for Output&lt;S&gt; {}
impl&lt;S: OutputState&gt; sealed::Sealed for Output&lt;S&gt; {}

pub struct PushPull;
pub struct OpenDrain;

impl OutputState for PushPull {}
impl OutputState for OpenDrain {}
impl sealed::Sealed for PushPull {}
impl sealed::Sealed for OpenDrain {}

pub struct Input&lt;S: InputState&gt; {
    _p: PhantomData&lt;S&gt;,
}

impl&lt;S: InputState&gt; PinState for Input&lt;S&gt; {}
impl&lt;S: InputState&gt; sealed::Sealed for Input&lt;S&gt; {}

pub struct Floating;
pub struct PullUp;
pub struct PullDown;

impl InputState for Floating {}
impl InputState for PullUp {}
impl InputState for PullDown {}
impl sealed::Sealed for Floating {}
impl sealed::Sealed for PullUp {}
impl sealed::Sealed for PullDown {}

pub struct PA1&lt;S: PinState&gt; {
    _p: PhantomData&lt;S&gt;,
}

impl&lt;S: PinState&gt; PA1&lt;S&gt; {
    pub fn into_input&lt;N: InputState&gt;(self, input: N) -&gt; PA1&lt;Input&lt;N&gt;&gt; {
        todo!()
    }

    pub fn into_output&lt;N: OutputState&gt;(self, output: N) -&gt; PA1&lt;Output&lt;N&gt;&gt; {
        todo!()
    }

    pub fn with_input_state&lt;N: InputState, R&gt;(
        &amp;mut self,
        input: N,
        f: impl FnOnce(&amp;mut PA1&lt;N&gt;) -&gt; R,
    ) -&gt; R {
        todo!()
    }

    pub fn with_output_state&lt;N: OutputState, R&gt;(
        &amp;mut self,
        output: N,
        f: impl FnOnce(&amp;mut PA1&lt;N&gt;) -&gt; R,
    ) -&gt; R {
        todo!()
    }
}

// Same for `PA` and `Pin`, and other pin types.
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="çµ¦åµŒå…¥å¼-c-é–‹ç™¼è€…çš„æç¤º"><a class="header" href="#çµ¦åµŒå…¥å¼-c-é–‹ç™¼è€…çš„æç¤º">çµ¦åµŒå…¥å¼ C é–‹ç™¼è€…çš„æç¤º</a></h1>
<p>æœ¬ç« æ”¶éŒ„å„ç¨®å¯èƒ½å°æœ‰ç¶“é©—çš„åµŒå…¥å¼ C é–‹ç™¼è€…æœ‰ç”¨çš„æç¤ºï¼Œä»¥ä¾¿é–‹å§‹æ’°å¯« Rustã€‚å…¶ä¸­æœƒç‰¹åˆ¥å¼·èª¿ä½ åœ¨ C ä¸­ç¿’ä»¥ç‚ºå¸¸çš„äº‹ï¼Œåœ¨ Rust ä¸­æœ‰ä½•ä¸åŒã€‚</p>
<h2 id="é è™•ç†å™¨"><a class="header" href="#é è™•ç†å™¨">é è™•ç†å™¨</a></h2>
<p>åœ¨åµŒå…¥å¼ C ä¸­ï¼Œé è™•ç†å™¨å¸¸è¢«ç”¨æ–¼å„ç¨®ç”¨é€”ï¼Œä¾‹å¦‚ï¼š</p>
<ul>
<li>ä½¿ç”¨ <code>#ifdef</code> æ–¼ç·¨è­¯æœŸé¸æ“‡ç¨‹å¼ç¢¼å€å¡Š</li>
<li>ç·¨è­¯æœŸçš„é™£åˆ—å¤§å°èˆ‡è¨ˆç®—</li>
<li>ç”¨å·¨é›†ç°¡åŒ–å¸¸è¦‹æ¨¡å¼ï¼ˆé¿å…å‡½å¼å‘¼å«é–‹éŠ·ï¼‰</li>
</ul>
<p>Rust æ²’æœ‰é è™•ç†å™¨ï¼Œå› æ­¤é€™äº›ç”¨ä¾‹å¤šåŠä»¥ä¸åŒæ–¹å¼è™•ç†ã€‚åœ¨æœ¬ç¯€å…¶é¤˜éƒ¨åˆ†ï¼Œæˆ‘å€‘æœƒä»‹ç´¹å¤šç¨®é è™•ç†å™¨çš„æ›¿ä»£æ–¹æ¡ˆã€‚</p>
<h3 id="ç·¨è­¯æœŸç¨‹å¼ç¢¼é¸æ“‡"><a class="header" href="#ç·¨è­¯æœŸç¨‹å¼ç¢¼é¸æ“‡">ç·¨è­¯æœŸç¨‹å¼ç¢¼é¸æ“‡</a></h3>
<p>åœ¨ Rust ä¸­ï¼Œæœ€æ¥è¿‘ <code>#ifdef ... #endif</code> çš„æ˜¯ <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section">Cargo features</a>ã€‚å®ƒå€‘æ¯” C é è™•ç†å™¨æ›´æ­£å¼ï¼šæ¯å€‹ crate æœƒæ˜ç¢ºåˆ—å‡ºæ‰€æœ‰å¯èƒ½çš„ featureï¼Œä¸”åªèƒ½æ˜¯é–‹æˆ–é—œã€‚ç•¶ä½ æŠŠæŸå€‹ crate åˆ—ç‚ºç›¸ä¾æ™‚æœƒå•Ÿç”¨ featureï¼Œè€Œä¸” feature æ˜¯å¯ç´¯åŠ çš„ï¼šè‹¥ç›¸ä¾æ¨¹ä¸­ä»»ä½• crate ç‚ºå¦ä¸€å€‹ crate å•Ÿç”¨ featureï¼Œè©² crate çš„æ‰€æœ‰ä½¿ç”¨è€…éƒ½æœƒå•Ÿç”¨è©² featureã€‚</p>
<p>ä¾‹å¦‚ï¼Œä½ å¯èƒ½æœ‰å€‹ crate æä¾›è¨Šè™Ÿè™•ç†åŸºç¤å…ƒä»¶ã€‚æ¯å€‹å…ƒä»¶å¯èƒ½éœ€è¦é¡å¤–ç·¨è­¯æ™‚é–“æˆ–å®£å‘Šå¤§å‹å¸¸æ•¸è¡¨ï¼Œè€Œä½ å¸Œæœ›é¿å…ã€‚ä½ å¯ä»¥åœ¨ <code>Cargo.toml</code> ç‚ºæ¯å€‹å…ƒä»¶å®£å‘Šä¸€å€‹ Cargo featureï¼š</p>
<pre><code class="language-toml">[features]
FIR = []
IIR = []
</code></pre>
<p>ç„¶å¾Œåœ¨ç¨‹å¼ç¢¼ä¸­ä½¿ç”¨ <code>#[cfg(feature="FIR")]</code> ä¾†æ§åˆ¶è¦åŒ…å«å“ªäº›å…§å®¹ã€‚</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// åœ¨ä½ çš„é ‚å±¤ lib.rs ä¸­

#[cfg(feature="FIR")]
pub mod fir;

#[cfg(feature="IIR")]
pub mod iir;
<span class="boring">}</span></code></pre>
<p>ä½ ä¹Ÿå¯ä»¥åœ¨ feature _æœª_å•Ÿç”¨æ™‚åŒ…å«ç¨‹å¼ç¢¼å€å¡Šï¼Œæˆ–åœ¨æŸäº› feature çµ„åˆå•Ÿç”¨æˆ–æœªå•Ÿç”¨æ™‚åŒ…å«ç¨‹å¼ç¢¼ã€‚</p>
<p>æ­¤å¤–ï¼ŒRust æä¾›å¤šç¨®è‡ªå‹•è¨­å®šçš„æ¢ä»¶å¯ç”¨ï¼Œä¾‹å¦‚ <code>target_arch</code> å¯ä¾æ¶æ§‹é¸æ“‡ä¸åŒç¨‹å¼ç¢¼ã€‚é—œæ–¼æ¢ä»¶å¼ç·¨è­¯æ”¯æ´çš„å®Œæ•´ç´°ç¯€ï¼Œè«‹åƒè€ƒ Rust åƒè€ƒæ–‡ä»¶ä¸­çš„<a href="https://doc.rust-lang.org/reference/conditional-compilation.html">æ¢ä»¶å¼ç·¨è­¯</a> ç« ç¯€ã€‚</p>
<p>æ¢ä»¶å¼ç·¨è­¯åªæœƒå¥—ç”¨åˆ°ä¸‹ä¸€å€‹æ•˜è¿°æˆ–å€å¡Šã€‚è‹¥æŸå€‹å€å¡Šåœ¨ç›®å‰ä½œç”¨åŸŸç„¡æ³•ä½¿ç”¨ï¼Œå°±éœ€è¦å¤šæ¬¡ä½¿ç”¨ <code>cfg</code> å±¬æ€§ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¤šæ•¸æƒ…æ³ä¸‹æ›´å¥½çš„ä½œæ³•æ˜¯ç›´æ¥åŒ…å«æ‰€æœ‰ç¨‹å¼ç¢¼ï¼Œè®“ç·¨è­¯å™¨åœ¨æœ€ä½³åŒ–æ™‚ç§»é™¤æ­»ç¢¼ï¼šå°ä½ èˆ‡ä½¿ç”¨è€…éƒ½æ›´ç°¡å–®ï¼Œä¸”é€šå¸¸ç·¨è­¯å™¨èƒ½å¾ˆå¥½åœ°ç§»é™¤æœªä½¿ç”¨çš„ç¨‹å¼ç¢¼ã€‚</p>
<h3 id="ç·¨è­¯æœŸå¤§å°èˆ‡è¨ˆç®—"><a class="header" href="#ç·¨è­¯æœŸå¤§å°èˆ‡è¨ˆç®—">ç·¨è­¯æœŸå¤§å°èˆ‡è¨ˆç®—</a></h3>
<p>Rust æ”¯æ´ <code>const fn</code>ï¼Œå…¶å‡½å¼å¯ä¿è­‰åœ¨ç·¨è­¯æœŸæ±‚å€¼ï¼Œå› æ­¤å¯ç”¨æ–¼éœ€è¦å¸¸æ•¸çš„åœ°æ–¹ï¼Œä¾‹å¦‚é™£åˆ—å¤§å°ã€‚å®ƒå¯èˆ‡ä¸Šè¿° feature ä¸€èµ·ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn array_size() -&gt; usize {
    #[cfg(feature="use_more_ram")]
    { 1024 }
    #[cfg(not(feature="use_more_ram"))]
    { 128 }
}

static BUF: [u32; array_size()] = [0u32; array_size()];
<span class="boring">}</span></code></pre>
<p>é€™äº›åŠŸèƒ½è‡ª Rust 1.31 èµ·æ‰é€²å…¥ç©©å®šç‰ˆï¼Œå› æ­¤æ–‡ä»¶ä»è¼ƒå°‘ã€‚æ’°å¯«æœ¬æ›¸æ™‚ï¼Œ<code>const fn</code> å¯ç”¨çš„åŠŸèƒ½ä¹Ÿç›¸ç•¶æœ‰é™ï¼›æœªä¾† Rust ç‰ˆæœ¬é æœŸæœƒæ“´å…… <code>const fn</code> å…è¨±çš„å…§å®¹ã€‚</p>
<h3 id="å·¨é›†"><a class="header" href="#å·¨é›†">å·¨é›†</a></h3>
<p>Rust æä¾›éå¸¸å¼·å¤§çš„<a href="https://doc.rust-lang.org/book/ch19-06-macros.html">å·¨é›†ç³»çµ±</a>ã€‚C çš„é è™•ç†å™¨å¹¾ä¹ç›´æ¥æ“ä½œåŸå§‹ç¢¼æ–‡å­—ï¼Œè€Œ Rust å·¨é›†ç³»çµ±åœ¨æ›´é«˜å±¤ç´šé‹ä½œã€‚Rust çš„å·¨é›†æœ‰å…©ç¨®ï¼š<em>å·¨é›†ç¯„ä¾‹ï¼ˆmacros by exampleï¼‰</em> èˆ‡ <em>ç¨‹åºå¼å·¨é›†ï¼ˆprocedural macrosï¼‰</em>ã€‚å‰è€…è¼ƒç°¡å–®ä¸”æœ€å¸¸è¦‹ï¼Œçœ‹èµ·ä¾†åƒå‡½å¼å‘¼å«ï¼Œèƒ½å±•é–‹æˆå®Œæ•´çš„è¡¨é”å¼ã€æ•˜è¿°ã€é …ç›®æˆ–æ¨£å¼ã€‚ç¨‹åºå¼å·¨é›†æ›´è¤‡é›œï¼Œä½†å¯å° Rust èªè¨€é€²è¡Œæ¥µå…¶å¼·å¤§çš„æ“´å±•ï¼šå®ƒå€‘å¯å°‡ä»»æ„ Rustèªæ³•è½‰æ›æˆæ–°çš„ Rust èªæ³•ã€‚</p>
<p>ä¸€èˆ¬è€Œè¨€ï¼Œè‹¥ä½ åŸæœ¬æœƒç”¨ C é è™•ç†å™¨å·¨é›†ï¼Œæ‡‰å…ˆçœ‹çœ‹å·¨é›†ç¯„ä¾‹æ˜¯å¦èƒ½å®Œæˆä»»å‹™ã€‚å®ƒå€‘å¯åœ¨ä½ çš„ crate ä¸­å®šç¾©ï¼Œä¸¦è¼•é¬†ä¾›è‡ªå·±çš„ crate ä½¿ç”¨æˆ–åŒ¯å‡ºçµ¦å…¶ä»–ä½¿ç”¨è€…ã€‚è«‹æ³¨æ„ï¼Œå› ç‚ºå®ƒå€‘å¿…é ˆå±•é–‹æˆå®Œæ•´çš„è¡¨é”å¼ã€æ•˜è¿°ã€é …ç›®æˆ–æ¨£å¼ï¼Œæ‰€ä»¥æŸäº› C é è™•ç†å™¨å·¨é›†çš„ç”¨æ³•ç„¡æ³•ä½¿ç”¨ï¼Œä¾‹å¦‚å±•é–‹æˆè®Šæ•¸åç¨±çš„ä¸€éƒ¨åˆ†ï¼Œæˆ–æ¸…å–®ä¸­ä¸å®Œæ•´çš„ä¸€çµ„é …ç›®ã€‚</p>
<p>å’Œ Cargo features ä¸€æ¨£ï¼Œä¹Ÿå€¼å¾—è€ƒæ…®æ˜¯å¦çœŸçš„éœ€è¦å·¨é›†ã€‚è¨±å¤šæƒ…æ³ä¸‹ï¼Œä¸€èˆ¬å‡½å¼æ›´å®¹æ˜“ç†è§£ï¼Œä¸”æœƒè¢«å…§è¯æˆèˆ‡å·¨é›†ç›¸åŒçš„ç¨‹å¼ç¢¼ã€‚<code>#[inline]</code> èˆ‡ <code>#[inline(always)]</code> <a href="https://doc.rust-lang.org/reference/attributes.html#inline-attribute">å±¬æ€§</a> å¯æä¾›æ›´å¤šæ§åˆ¶ï¼Œä½†ä¹Ÿéœ€å°å¿ƒâ€”â€”ç·¨è­¯å™¨æœƒåœ¨é©ç•¶æ™‚è‡ªå‹•å…§è¯åŒä¸€ crate çš„å‡½å¼ï¼Œè‹¥å¼·åˆ¶å…§è¯ä¸æ°ç•¶ï¼Œåè€Œå¯èƒ½é™ä½æ•ˆèƒ½ã€‚</p>
<p>å®Œæ•´èªªæ˜ Rust å·¨é›†ç³»çµ±è¶…å‡ºæœ¬æç¤ºé çš„ç¯„åœï¼Œå»ºè­°åƒè€ƒ Rust æ–‡ä»¶ä»¥äº†è§£å®Œæ•´ç´°ç¯€ã€‚</p>
<h2 id="å»ºç½®ç³»çµ±"><a class="header" href="#å»ºç½®ç³»çµ±">å»ºç½®ç³»çµ±</a></h2>
<p>å¤šæ•¸ Rust crate ä»¥ Cargo å»ºç½®ï¼ˆé›–éå¿…é ˆï¼‰ã€‚é€™è§£æ±ºäº†å‚³çµ±å»ºç½®ç³»çµ±çš„è¨±å¤šé›£é¡Œã€‚ä¸éï¼Œä½ å¯èƒ½å¸Œæœ›è‡ªè¨‚å»ºç½®æµç¨‹ã€‚Cargo æä¾› <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code> è…³æœ¬</a> ä¾†é”æˆæ­¤ç›®çš„ã€‚é€™äº›æ˜¯å¯ä¾éœ€æ±‚èˆ‡ Cargo å»ºç½®ç³»çµ±äº’å‹•çš„ Rust è…³æœ¬ã€‚</p>
<p>å»ºç½®è…³æœ¬çš„å¸¸è¦‹ç”¨é€”åŒ…æ‹¬ï¼š</p>
<ul>
<li>æä¾›å»ºç½®æ™‚è³‡è¨Šï¼Œä¾‹å¦‚å°‡å»ºç½®æ—¥æœŸæˆ– Git æäº¤é›œæ¹Šå€¼éœæ…‹åµŒå…¥å¯åŸ·è¡Œæª”</li>
<li>ä¾é¸æ“‡çš„ feature æˆ–å…¶ä»–é‚è¼¯åœ¨å»ºç½®æ™‚ç”¢ç”Ÿé€£çµå™¨è…³æœ¬</li>
<li>è®Šæ›´ Cargo å»ºç½®è¨­å®š</li>
<li>åŠ å…¥é¡å¤–è¦é€£çµçš„éœæ…‹å‡½å¼åº«</li>
</ul>
<p>ç›®å‰æ²’æœ‰å¾Œç½®å»ºç½®è…³æœ¬çš„æ”¯æ´ï¼Œè€Œä½ å¯èƒ½æ›¾ç”¨å®ƒä¾†è‡ªå‹•å¾å»ºç½®ç‰©ä»¶ç”¢ç”ŸäºŒé€²ä½æª”æˆ–è¼¸å‡ºå»ºç½®è³‡è¨Šã€‚</p>
<h3 id="äº¤å‰ç·¨è­¯-1"><a class="header" href="#äº¤å‰ç·¨è­¯-1">äº¤å‰ç·¨è­¯</a></h3>
<p>ä½¿ç”¨ Cargo ä½œç‚ºå»ºç½®ç³»çµ±ä¹Ÿèƒ½ç°¡åŒ–äº¤å‰ç·¨è­¯ã€‚å¤šæ•¸æƒ…æ³ä¸‹åªéœ€å‘Šè¨´ Cargo <code>--target thumbv6m-none-eabi</code>ï¼Œä¸¦åœ¨ <code>target/thumbv6m-none-eabi/debug/myapp</code> æ‰¾åˆ°åˆé©çš„å¯åŸ·è¡Œæª”ã€‚</p>
<p>å°æ–¼ Rust å°šæœªåŸç”Ÿæ”¯æ´çš„å¹³å°ï¼Œä½ éœ€è¦è‡ªè¡Œç‚ºè©²ç›®æ¨™å»ºç½® <code>libcore</code>ã€‚åœ¨é€™é¡å¹³å°ä¸Šï¼Œå¯ä½¿ç”¨ <a href="https://github.com/japaric/xargo">Xargo</a> ä½œç‚º Cargo çš„æ›¿ä»£ï¼Œç‚ºä½ è‡ªå‹•å»ºç½® <code>libcore</code>ã€‚</p>
<h2 id="ç–Šä»£å™¨èˆ‡é™£åˆ—å­˜å–"><a class="header" href="#ç–Šä»£å™¨èˆ‡é™£åˆ—å­˜å–">ç–Šä»£å™¨èˆ‡é™£åˆ—å­˜å–</a></h2>
<p>åœ¨ C ä¸­ï¼Œä½ å¯èƒ½ç¿’æ…£ä»¥ç´¢å¼•ç›´æ¥å­˜å–é™£åˆ—ï¼š</p>
<pre><code class="language-c">int16_t arr[16];
int i;
for(i=0; i&lt;sizeof(arr)/sizeof(arr[0]); i++) {
    process(arr[i]);
}
</code></pre>
<p>åœ¨ Rust ä¸­é€™æ˜¯åæ¨¡å¼ï¼šç´¢å¼•å­˜å–å¯èƒ½è¼ƒæ…¢ï¼ˆå› ç‚ºéœ€è¦é‚Šç•Œæª¢æŸ¥ï¼‰ï¼Œä¹Ÿå¯èƒ½é˜»ç¤™å„ç¨®ç·¨è­¯å™¨æœ€ä½³åŒ–ã€‚é€™é»å¾ˆé‡è¦ï¼Œå€¼å¾—é‡ç”³ï¼šRust æœƒå°æ‰‹å‹•ç´¢å¼•é™£åˆ—é€²è¡Œè¶Šç•Œæª¢æŸ¥ä»¥ä¿è­‰è¨˜æ†¶é«”å®‰å…¨ï¼Œè€Œ C å‰‡æœƒæ„‰å¿«åœ°ç´¢å¼•åˆ°é™£åˆ—ä¹‹å¤–ã€‚</p>
<p>æ”¹ç”¨ç–Šä»£å™¨ï¼š</p>
<pre><code class="language-rust ignore">let arr = [0u16; 16];
for element in arr.iter() {
    process(*element);
}</code></pre>
<p>ç–Šä»£å™¨æä¾›äº†ä½ åœ¨ C ä¸­å¿…é ˆæ‰‹å‹•å¯¦ä½œçš„ä¸€ç³»åˆ—å¼·å¤§åŠŸèƒ½ï¼Œä¾‹å¦‚ä¸²æ¥ã€æ‹‰éŠåŒ–ã€æšèˆ‰ã€æ‰¾æœ€å°/æœ€å¤§å€¼ã€åŠ ç¸½ç­‰ã€‚ç–Šä»£å™¨æ–¹æ³•ä¹Ÿå¯ä¸²æ¥ï¼Œè®“è³‡æ–™è™•ç†ç¨‹å¼ç¢¼éå¸¸æ˜“è®€ã€‚</p>
<p>æ›´å¤šç´°ç¯€è«‹åƒè€ƒ<a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">æ‰‹å†Šä¸­çš„ç–Šä»£å™¨</a>èˆ‡<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator æ–‡ä»¶</a>ã€‚</p>
<h2 id="åƒè€ƒèˆ‡æŒ‡æ¨™"><a class="header" href="#åƒè€ƒèˆ‡æŒ‡æ¨™">åƒè€ƒèˆ‡æŒ‡æ¨™</a></h2>
<p>åœ¨ Rust ä¸­ç¢ºå¯¦æœ‰æŒ‡æ¨™ï¼ˆç¨±ç‚º<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer"><em>è£¸æŒ‡æ¨™</em></a>ï¼‰ï¼Œä½†åªåœ¨ç‰¹å®šæƒ…æ³ä¸‹ä½¿ç”¨ï¼Œå› ç‚ºè§£åƒè€ƒå®ƒå€‘ä¸€å¾‹è¢«è¦–ç‚º <code>unsafe</code>â€”â€”Rust ç„¡æ³•å°æŒ‡æ¨™èƒŒå¾Œçš„å…§å®¹æä¾›ä¸€è²«çš„ä¿è­‰ã€‚</p>
<p>åœ¨å¤šæ•¸æƒ…æ³ä¸‹ï¼Œæˆ‘å€‘æœƒæ”¹ç”¨_åƒè€ƒ_ï¼ˆä»¥ <code>&amp;</code> è¡¨ç¤ºï¼‰ï¼Œæˆ–_å¯è®Šåƒè€ƒ_ï¼ˆä»¥ <code>&amp;mut</code> è¡¨ç¤ºï¼‰ã€‚åƒè€ƒçš„è¡Œç‚ºé¡ä¼¼æŒ‡æ¨™ï¼Œå¯è§£åƒè€ƒä»¥å­˜å–åº•å±¤å€¼ï¼Œä½†å®ƒå€‘æ˜¯ Rust æ‰€æœ‰æ¬Šç³»çµ±çš„é—œéµï¼šRust åš´æ ¼ä¿è­‰åœ¨ä»»ä½•æ™‚åˆ»å°åŒä¸€å€‹å€¼åªèƒ½æœ‰ä¸€å€‹å¯è®Šåƒè€ƒï¼Œ<em>æˆ–</em> å¤šå€‹ä¸å¯è®Šåƒè€ƒã€‚</p>
<p>å¯¦å‹™ä¸Šé€™ä»£è¡¨ä½ å¿…é ˆæ›´è¬¹æ…è€ƒæ…®æ˜¯å¦çœŸçš„éœ€è¦å°è³‡æ–™é€²è¡Œå¯è®Šå­˜å–ï¼šåœ¨ C ä¸­é è¨­å¯è®Šä¸”éœ€æ˜ç¢ºæ¨™ç¤º <code>const</code>ï¼Œåœ¨ Rust ä¸­å‰‡ç›¸åã€‚</p>
<p>ä»å¯èƒ½ä½¿ç”¨è£¸æŒ‡æ¨™çš„æƒ…æ³ä¹‹ä¸€æ˜¯ç›´æ¥èˆ‡ç¡¬é«”äº’å‹•ï¼ˆä¾‹å¦‚å°‡ç·©è¡å€æŒ‡æ¨™å¯«å…¥ DMA å‘¨é‚Šæš«å­˜å™¨ï¼‰ã€‚å®ƒå€‘ä¹Ÿè¢«æ‰€æœ‰å‘¨é‚Šå­˜å–å¥—ä»¶åœ¨åº•å±¤ä½¿ç”¨ï¼Œä»¥å…è¨±è®€å¯«è¨˜æ†¶é«”å°æ˜ æš«å­˜å™¨ã€‚</p>
<h2 id="æ˜“è®Šå­˜å–"><a class="header" href="#æ˜“è®Šå­˜å–">æ˜“è®Šå­˜å–</a></h2>
<p>åœ¨ C ä¸­ï¼Œå–®ä¸€è®Šæ•¸å¯æ¨™è¨˜ç‚º <code>volatile</code>ï¼Œå‘Šè¨´ç·¨è­¯å™¨è©²è®Šæ•¸çš„å€¼å¯èƒ½åœ¨å­˜å–ä¹‹é–“æ”¹è®Šã€‚æ˜“è®Šè®Šæ•¸åœ¨åµŒå…¥å¼æƒ…å¢ƒä¸­å¸¸ç”¨æ–¼è¨˜æ†¶é«”å°æ˜ æš«å­˜å™¨ã€‚</p>
<p>åœ¨ Rust ä¸­ï¼Œä¸æ˜¯å°‡è®Šæ•¸æ¨™è¨˜ç‚º <code>volatile</code>ï¼Œè€Œæ˜¯ä½¿ç”¨ç‰¹å®šæ–¹æ³•é€²è¡Œæ˜“è®Šå­˜å–ï¼š<a href="https://doc.rust-lang.org/core/ptr/fn.read_volatile.html"><code>core::ptr::read_volatile</code></a> èˆ‡<a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html"><code>core::ptr::write_volatile</code></a>ã€‚é€™äº›æ–¹æ³•æ¥å— <code>*const T</code> æˆ– <code>*mut T</code>ï¼ˆå¦‚ä¸Šæ‰€è¿°çš„_è£¸æŒ‡æ¨™_ï¼‰ï¼Œä¸¦åŸ·è¡Œæ˜“è®Šè®€å¯«ã€‚</p>
<p>ä¾‹å¦‚ï¼Œåœ¨ C ä¸­ä½ å¯èƒ½æœƒå¯«ï¼š</p>
<pre><code class="language-c">volatile bool signalled = false;

void ISR() {
    // è¡¨ç¤ºä¸­æ–·å·²ç™¼ç”Ÿ
    signalled = true;
}

void driver() {
    while(true) {
        // ç¡çœ ç›´åˆ°æ”¶åˆ°è¨Šè™Ÿ
        while(!signalled) { WFI(); }
        // é‡è¨­å·²é€šçŸ¥çš„æŒ‡ç¤º
        signalled = false;
        // åŸ·è¡Œå…ˆå‰ç­‰å¾…ä¸­æ–·çš„ä»»å‹™
        run_task();
    }
}
</code></pre>
<p>åœ¨ Rust ä¸­ç­‰æ•ˆä½œæ³•æ˜¯åœ¨æ¯æ¬¡å­˜å–æ™‚ä½¿ç”¨æ˜“è®Šæ–¹æ³•ï¼š</p>
<pre><code class="language-rust ignore">static mut SIGNALLED: bool = false;

#[interrupt]
fn ISR() {
    // è¡¨ç¤ºä¸­æ–·å·²ç™¼ç”Ÿ
    //ï¼ˆåœ¨å¯¦éš›ç¨‹å¼ç¢¼ä¸­ï¼Œä½ æ‡‰è€ƒæ…®æ›´é«˜éšçš„åŸèªï¼Œ
    //  ä¾‹å¦‚åŸå­å‹åˆ¥ï¼‰ã€‚
    unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, true) };
}

fn driver() {
    loop {
        // ç¡çœ ç›´åˆ°æ”¶åˆ°è¨Šè™Ÿ
        while unsafe { !core::ptr::read_volatile(&amp;SIGNALLED) } {}
        // é‡è¨­å·²é€šçŸ¥çš„æŒ‡ç¤º
        unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, false) };
        // åŸ·è¡Œå…ˆå‰ç­‰å¾…ä¸­æ–·çš„ä»»å‹™
        run_task();
    }
}</code></pre>
<p>ç¨‹å¼ç¢¼ç¯„ä¾‹ä¸­æœ‰å¹¾é»å€¼å¾—æ³¨æ„ï¼š</p>
<ul>
<li>æˆ‘å€‘å¯ä»¥å°‡ <code>&amp;mut SIGNALLED</code> å‚³çµ¦éœ€è¦ <code>*mut T</code> çš„å‡½å¼ï¼Œå› ç‚º <code>&amp;mut T</code> æœƒè‡ªå‹•è½‰æ›ç‚º <code>*mut T</code>ï¼ˆ<code>*const T</code> äº¦åŒï¼‰</li>
<li>ç”±æ–¼ <code>read_volatile</code>/<code>write_volatile</code> æ˜¯ <code>unsafe</code> å‡½å¼ï¼Œæˆ‘å€‘éœ€è¦ä½¿ç”¨ <code>unsafe</code> å€å¡Šã€‚ç¢ºä¿å®‰å…¨ä½¿ç”¨æ˜¯ç¨‹å¼è¨­è¨ˆè€…çš„è²¬ä»»ï¼šè©³æƒ…è«‹åƒè€ƒé€™äº›æ–¹æ³•çš„æ–‡ä»¶ã€‚</li>
</ul>
<p>é€šå¸¸ä¸éœ€è¦åœ¨ç¨‹å¼ä¸­ç›´æ¥å‘¼å«é€™äº›å‡½å¼ï¼Œå› ç‚ºé«˜éšå‡½å¼åº«æœƒæ›¿ä½ è™•ç†ã€‚å°è¨˜æ†¶é«”å°æ˜ å‘¨é‚Šè€Œè¨€ï¼Œå‘¨é‚Šå­˜å–å¥—ä»¶æœƒè‡ªå‹•å¯¦ä½œæ˜“è®Šå­˜å–ï¼›å°ä¸¦è¡ŒåŸèªå‰‡æœ‰æ›´å¥½çš„æŠ½è±¡å¯ç”¨ï¼ˆåƒè¦‹<a href="#ä¸¦è¡Œ">ä¸¦è¡Œç« ç¯€</a>ï¼‰ã€‚</p>
<h2 id="æ‰“åŒ…èˆ‡å°é½Šå‹åˆ¥"><a class="header" href="#æ‰“åŒ…èˆ‡å°é½Šå‹åˆ¥">æ‰“åŒ…èˆ‡å°é½Šå‹åˆ¥</a></h2>
<p>åœ¨åµŒå…¥å¼ C ä¸­ï¼Œå¸¸è¦‹åšæ³•æ˜¯å‘Šè¨´ç·¨è­¯å™¨æŸè®Šæ•¸å¿…é ˆæœ‰ç‰¹å®šä½å…ƒçµ„å°é½Šï¼Œæˆ–æŸå€‹çµæ§‹é«”å¿…é ˆæ‰“åŒ…è€Œéå°é½Šï¼Œé€šå¸¸æ˜¯ç‚ºäº†æ»¿è¶³ç‰¹å®šç¡¬é«”æˆ–é€šè¨Šå”å®šéœ€æ±‚ã€‚</p>
<p>åœ¨ Rust ä¸­ï¼Œé€™ç”±çµæ§‹é«”æˆ–è¯åˆé«”ä¸Šçš„ <code>repr</code> å±¬æ€§æ§åˆ¶ã€‚é è¨­è¡¨ç¾å½¢å¼ä¸ä¿è­‰ç‰ˆé¢é…ç½®ï¼Œå› æ­¤ä¸æ‡‰ç”¨æ–¼èˆ‡ç¡¬é«”æˆ– C äº’é€šçš„ç¨‹å¼ç¢¼ã€‚ç·¨è­¯å™¨å¯èƒ½æœƒé‡æ–°æ’åºçµæ§‹é«”æˆå“¡æˆ–æ’å…¥å¡«å……ï¼Œä¸”è¡Œç‚ºå¯èƒ½åœ¨æœªä¾† Rust ç‰ˆæœ¬ä¸­æ”¹è®Šã€‚</p>
<pre class="playground"><code class="language-rust">struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2
// æ³¨æ„ç‚ºäº†æ”¹å–„æ‰“åŒ…ï¼Œé †åºå·²æ”¹ç‚º xã€zã€yã€‚</code></pre>
<p>ç‚ºäº†ç¢ºä¿èˆ‡ C äº’é€šçš„ç‰ˆé¢é…ç½®ï¼Œä½¿ç”¨ <code>repr(C)</code>ï¼š</p>
<pre class="playground"><code class="language-rust">#[repr(C)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64
// é †åºä¿æŒä¸è®Šï¼Œä¸”ç‰ˆé¢é…ç½®ä¸æœƒéš¨æ™‚é–“æ”¹è®Šã€‚
// `z` éœ€ 2 ä½å…ƒçµ„å°é½Šï¼Œå› æ­¤ `y` èˆ‡ `z` ä¹‹é–“å­˜åœ¨ 1 ä½å…ƒçµ„å¡«å……ã€‚</code></pre>
<p>è‹¥è¦ç¢ºä¿æ‰“åŒ…è¡¨ç¤ºï¼Œä½¿ç”¨ <code>repr(packed)</code>ï¼š</p>
<pre class="playground"><code class="language-rust">#[repr(packed)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    // åƒè€ƒå¿…é ˆæ°¸é å°é½Šï¼Œå› æ­¤è¦æª¢æŸ¥çµæ§‹é«”æ¬„ä½ä½å€æ™‚ï¼Œ
    // æˆ‘å€‘ä½¿ç”¨ `std::ptr::addr_of!()` å–å¾—è£¸æŒ‡æ¨™ï¼Œ
    // è€Œä¸æ˜¯ç›´æ¥åˆ—å° `&amp;v.x`ã€‚
    let px = std::ptr::addr_of!(v.x);
    let py = std::ptr::addr_of!(v.y);
    let pz = std::ptr::addr_of!(v.z);
    println!("{:p} {:p} {:p}", px, py, pz);
}

// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493
// `y` èˆ‡ `z` ä¹‹é–“æœªæ’å…¥å¡«å……ï¼Œå› æ­¤ `z` ç¾åœ¨æœªå°é½Šã€‚</code></pre>
<p>æ³¨æ„ï¼Œä½¿ç”¨ <code>repr(packed)</code> ä¹ŸæœƒæŠŠå‹åˆ¥å°é½Šè¨­ç‚º <code>1</code>ã€‚</p>
<p>æœ€å¾Œï¼Œè‹¥è¦æŒ‡å®šç‰¹å®šå°é½Šæ–¹å¼ï¼Œä½¿ç”¨ <code>repr(align(n))</code>ï¼Œå…¶ä¸­ <code>n</code> æ˜¯å°é½Šåˆ°çš„ä½å…ƒçµ„æ•¸ï¼ˆä¸”å¿…é ˆç‚º 2 çš„å†ªï¼‰ï¼š</p>
<pre class="playground"><code class="language-rust">#[repr(C)]
#[repr(align(4096))]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    let u = Foo { x: 0, y: 0, z: 0 };
    println!("{:p} {:p} {:p}", &amp;v.x, &amp;v.y, &amp;v.z);
    println!("{:p} {:p} {:p}", &amp;u.x, &amp;u.y, &amp;u.z);
}

// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004
// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004
// å…©å€‹å¯¦ä¾‹ `u` èˆ‡ `v` è¢«æ”¾åœ¨ 4096 ä½å…ƒçµ„å°é½Šçš„ä½ç½®ï¼Œ
// å¾ä½å€æœ«å°¾çš„ `000` å¯çœ‹å‡ºã€‚</code></pre>
<p>æ³¨æ„ï¼Œæˆ‘å€‘å¯å°‡ <code>repr(C)</code> èˆ‡ <code>repr(align(n))</code> çµåˆä»¥å–å¾—å°é½Šä¸”ç›¸å®¹ C çš„é…ç½®ã€‚ä¸å¾—å°‡ <code>repr(align(n))</code> èˆ‡ <code>repr(packed)</code> çµåˆï¼Œå› ç‚º <code>repr(packed)</code> æœƒæŠŠå°é½Šè¨­ç‚º <code>1</code>ã€‚<code>repr(packed)</code> å‹åˆ¥ä¹Ÿä¸å¾—åŒ…å« <code>repr(align(n))</code> å‹åˆ¥ã€‚</p>
<p>é—œæ–¼å‹åˆ¥é…ç½®çš„æ›´å¤šç´°ç¯€ï¼Œè«‹åƒè€ƒ Rust åƒè€ƒæ–‡ä»¶çš„ <a href="https://doc.rust-lang.org/reference/type-layout.html">type layout</a> ç« ç¯€ã€‚</p>
<h2 id="å…¶ä»–è³‡æº-1"><a class="header" href="#å…¶ä»–è³‡æº-1">å…¶ä»–è³‡æº</a></h2>
<ul>
<li>æœ¬æ›¸ä¸­çš„è³‡æºï¼š
<ul>
<li><a href="#åœ¨-rust-ä¸­ç”¨é»-c">åœ¨ Rust ä¸­ç”¨é» C</a></li>
<li><a href="#åœ¨-c-ä¸­ç”¨é»-rust">åœ¨ C ä¸­ç”¨é» Rust</a></li>
</ul>
</li>
<li><a href="https://docs.rust-embedded.org/faq.html">Rust Embedded å¸¸è¦‹å•é¡Œ</a></li>
<li><a href="http://blahg.josefsipek.net/?p=580">çµ¦ C ç¨‹å¼è¨­è¨ˆè€…çš„ Rust æŒ‡æ¨™</a></li>
<li><a href="https://github.com/diwic/reffers-rs/blob/master/docs/Pointers.md">æˆ‘ä»¥å‰ç”¨æŒ‡æ¨™â€”ç¾åœ¨å‘¢ï¼Ÿ</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="äº’é€šæ€§-1"><a class="header" href="#äº’é€šæ€§-1">äº’é€šæ€§</a></h1>
<p>Interoperability between Rust and C code is always dependent on transforming data between the two languages. For this purpose, there is a dedicated module in the <code>stdlib</code> called <a href="https://doc.rust-lang.org/std/ffi/index.html"><code>std::ffi</code></a>.</p>
<p><code>std::ffi</code> provides type definitions for C primitive types, such as <code>char</code>, <code>int</code>, and <code>long</code>. It also provides some utility for converting more complex types such as strings, mapping both <code>&amp;str</code> and <code>String</code> to C types that are easier and safer to handle.</p>
<p>As of Rust 1.30, functionalities of <code>std::ffi</code> are available in either <code>core::ffi</code> or <code>alloc::ffi</code> depending on whether or not memory allocation is involved. The <a href="https://crates.io/crates/cty"><code>cty</code></a> crate and the <a href="https://crates.io/crates/cstr_core"><code>cstr_core</code></a> crate also offer similar functionalities.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Rust type</th><th>Intermediate</th><th>C type</th></tr>
</thead>
<tbody>
<tr><td><code>String</code></td><td><code>CString</code></td><td><code>char *</code></td></tr>
<tr><td><code>&amp;str</code></td><td><code>CStr</code></td><td><code>const char *</code></td></tr>
<tr><td><code>()</code></td><td><code>c_void</code></td><td><code>void</code></td></tr>
<tr><td><code>u32</code> or <code>u64</code></td><td><code>c_uint</code></td><td><code>unsigned int</code></td></tr>
<tr><td>etc</td><td>â€¦</td><td>â€¦</td></tr>
</tbody>
</table>
</div>
<p>A value of a C primitive type can be used as one of the corresponding Rust type and vice versa, since the former is simply a type alias of the latter. For example, the following code compiles on platforms where <code>unsigned int</code> is 32-bit long.</p>
<pre><code class="language-rust ignore">fn foo(num: u32) {
    let c_num: c_uint = num;
    let r_num: u32 = c_num;
}</code></pre>
<h2 id="interoperability-with-other-build-systems"><a class="header" href="#interoperability-with-other-build-systems">Interoperability with other build systems</a></h2>
<p>A common requirement for including Rust in your embedded project is combining Cargo with your existing build system, such as make or cmake.</p>
<p>We are collecting examples and use cases for this on our issue tracker in <a href="https://github.com/rust-embedded/book/issues/61">issue #61</a>.</p>
<h2 id="interoperability-with-rtoss"><a class="header" href="#interoperability-with-rtoss">Interoperability with RTOSs</a></h2>
<p>Integrating Rust with an RTOS such as FreeRTOS or ChibiOS is still a work in progress; especially calling RTOS functions from Rust can be tricky.</p>
<p>We are collecting examples and use cases for this on our issue tracker in <a href="https://github.com/rust-embedded/book/issues/62">issue #62</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="åœ¨-rust-ä¸­ç”¨é»-c"><a class="header" href="#åœ¨-rust-ä¸­ç”¨é»-c">åœ¨ Rust ä¸­ç”¨é» C</a></h1>
<p>Using C or C++ inside of a Rust project consists of two major parts:</p>
<ul>
<li>Wrapping the exposed C API for use with Rust</li>
<li>Building your C or C++ code to be integrated with the Rust code</li>
</ul>
<p>As C++ does not have a stable ABI for the Rust compiler to target, it is recommended to use the <code>C</code> ABI when combining Rust with C or C++.</p>
<h2 id="defining-the-interface"><a class="header" href="#defining-the-interface">Defining the interface</a></h2>
<p>Before consuming C or C++ code from Rust, it is necessary to define (in Rust) what data types and function signatures exist in the linked code. In C or C++, you would include a header (<code>.h</code> or <code>.hpp</code>) file which defines this data. In Rust, it is necessary to either manually translate these definitions to Rust, or use a tool to generate these definitions.</p>
<p>First, we will cover manually translating these definitions from C/C++ to Rust.</p>
<h3 id="wrapping-c-functions-and-datatypes"><a class="header" href="#wrapping-c-functions-and-datatypes">Wrapping C functions and Datatypes</a></h3>
<p>Typically, libraries written in C or C++ will provide a header file defining all types and functions used in public interfaces. An example file may look like this:</p>
<pre><code class="language-C">/* File: cool.h */
typedef struct CoolStruct {
    int x;
    int y;
} CoolStruct;

void cool_function(int i, char c, CoolStruct* cs);
</code></pre>
<p>When translated to Rust, this interface would look as such:</p>
<pre><code class="language-rust ignore">/* File: cool_bindings.rs */
#[repr(C)]
pub struct CoolStruct {
    pub x: cty::c_int,
    pub y: cty::c_int,
}

extern "C" {
    pub fn cool_function(
        i: cty::c_int,
        c: cty::c_char,
        cs: *mut CoolStruct
    );
}</code></pre>
<p>Letâ€™s take a look at this definition one piece at a time, to explain each of the parts.</p>
<pre><code class="language-rust ignore">#[repr(C)]
pub struct CoolStruct { ... }</code></pre>
<p>By default, Rust does not guarantee order, padding, or the size of data included in a <code>struct</code>. In order to guarantee compatibility with C code, we include the <code>#[repr(C)]</code> attribute, which instructs the Rust compiler to always use the same rules C does for organizing data within a struct.</p>
<pre><code class="language-rust ignore">pub x: cty::c_int,
pub y: cty::c_int,</code></pre>
<p>Due to the flexibility of how C or C++ defines an <code>int</code> or <code>char</code>, it is recommended to use primitive data types defined in <code>cty</code>, which will map types from C to types in Rust.</p>
<pre><code class="language-rust ignore">extern "C" { pub fn cool_function( ... ); }</code></pre>
<p>This statement defines the signature of a function that uses the C ABI, called <code>cool_function</code>. By defining the signature without defining the body of the function, the definition of this function will need to be provided elsewhere, or linked into the final library or binary from a static library.</p>
<pre><code class="language-rust ignore">    i: cty::c_int,
    c: cty::c_char,
    cs: *mut CoolStruct</code></pre>
<p>Similar to our datatype above, we define the datatypes of the function arguments using C-compatible definitions. We also retain the same argument names, for clarity.</p>
<p>We have one new type here, <code>*mut CoolStruct</code>. As C does not have a concept of Rustâ€™s references, which would look like this: <code>&amp;mut CoolStruct</code>, we instead have a raw pointer. As dereferencing this pointer is <code>unsafe</code>, and the pointer may in fact be a <code>null</code> pointer, care must be taken to ensure the guarantees typical of Rust when interacting with C or C++ code.</p>
<h3 id="automatically-generating-the-interface"><a class="header" href="#automatically-generating-the-interface">Automatically generating the interface</a></h3>
<p>Rather than manually generating these interfaces, which may be tedious and error prone, there is a tool called <a href="https://github.com/rust-lang/rust-bindgen">bindgen</a> which will perform these conversions automatically. For instructions of the usage of <a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>, please refer to the <a href="https://rust-lang.github.io/rust-bindgen/">bindgen userâ€™s manual</a>, however the typical process consists of the following:</p>
<ol>
<li>Gather all C or C++ headers defining interfaces or datatypes you would like to use with Rust.</li>
<li>Write a <code>bindings.h</code> file, which <code>#include "..."</code>â€™s each of the files you gathered in step one.</li>
<li>Feed this <code>bindings.h</code> file, along with any compilation flags used to compile your code into <code>bindgen</code>. Tip: use <code>Builder.ctypes_prefix("cty")</code> / <code>--ctypes-prefix=cty</code> and <code>Builder.use_core()</code> / <code>--use-core</code> to make the generated code <code>#![no_std]</code> compatible.</li>
<li><code>bindgen</code> will produce the generated Rust code to the output of the terminal window. This output may be piped to a file in your project, such as <code>bindings.rs</code>. You may use this file in your Rust project to interact with C/C++ code compiled and linked as an external library. Tip: donâ€™t forget to use the <a href="https://crates.io/crates/cty"><code>cty</code></a> crate if your types in the generated bindings are prefixed with <code>cty</code>.</li>
</ol>
<h2 id="å»ºç½®æ‚¨çš„-cc-ç¨‹å¼ç¢¼"><a class="header" href="#å»ºç½®æ‚¨çš„-cc-ç¨‹å¼ç¢¼">å»ºç½®æ‚¨çš„ C/C++ ç¨‹å¼ç¢¼</a></h2>
<p>As the Rust compiler does not directly know how to compile C or C++ code (or code from any other language, which presents a C interface), it is necessary to compile your non-Rust code ahead of time.</p>
<p>For embedded projects, this most commonly means compiling the C/C++ code to a static archive (such as <code>cool-library.a</code>), which can then be combined with your Rust code at the final linking step.</p>
<p>If the library you would like to use is already distributed as a static archive, it is not necessary to rebuild your code. Just convert the provided interface header file as described above, and include the static archive at compile/link time.</p>
<p>If your code exists as a source project, it will be necessary to compile your C/C++ code to a static library, either by triggering your existing build system (such as <code>make</code>, <code>CMake</code>, etc.), or by porting the necessary compilation steps to use a tool called the <code>cc</code> crate. For both of these steps, it is necessary to use a <code>build.rs</code> script.</p>
<h3 id="rust-buildrs-build-scripts"><a class="header" href="#rust-buildrs-build-scripts">Rust <code>build.rs</code> build scripts</a></h3>
<p>A <code>build.rs</code> script is a file written in Rust syntax, that is executed on your compilation machine, AFTER dependencies of your project have been built, but BEFORE your project is built.</p>
<p>The full reference may be found <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">here</a>. <code>build.rs</code> scripts are useful for generating code (such as via <a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>), calling out to external build systems such as <code>Make</code>, or directly compiling C/C++ through use of the <code>cc</code> crate.</p>
<h3 id="triggering-external-build-systems"><a class="header" href="#triggering-external-build-systems">Triggering external build systems</a></h3>
<p>For projects with complex external projects or build systems, it may be easiest to use <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>std::process::Command</code></a> to â€œshell outâ€ to your other build systems by traversing relative paths, calling a fixed command (such as <code>make library</code>), and then copying the resulting static library to the proper location in the <code>target</code> build directory.</p>
<p>While your crate may be targeting a <code>no_std</code> embedded platform, your <code>build.rs</code> executes only on machines compiling your crate. This means you may use any Rust crates which will run on your compilation host.</p>
<h3 id="building-cc-code-with-the-cc-crate"><a class="header" href="#building-cc-code-with-the-cc-crate">Building C/C++ code with the <code>cc</code> crate</a></h3>
<p>For projects with limited dependencies or complexity, or for projects where it is difficult to modify the build system to produce a static library (rather than a final binary or executable), it may be easier to instead utilize the <a href="https://github.com/alexcrichton/cc-rs"><code>cc</code> crate</a>, which provides an idiomatic Rust interface to the compiler provided by the host.</p>
<p>In the simplest case of compiling a single C file as a dependency to a static library, an example <code>build.rs</code> script using the <a href="https://github.com/alexcrichton/cc-rs"><code>cc</code> crate</a> would look like this:</p>
<pre><code class="language-rust ignore">fn main() {
    cc::Build::new()
        .file("src/foo.c")
        .compile("foo");
}</code></pre>
<p>The <code>build.rs</code> is placed at the root of the package. Then <code>cargo build</code> will compile and execute it before the build of the package. A static archive named <code>libfoo.a</code> is generated and placed in the <code>target</code> directory.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="åœ¨-c-ä¸­ç”¨é»-rust"><a class="header" href="#åœ¨-c-ä¸­ç”¨é»-rust">åœ¨ C ä¸­ç”¨é» Rust</a></h1>
<p>Using Rust code inside a C or C++ project mostly consists of two parts.</p>
<ul>
<li>Creating a C-friendly API in Rust</li>
<li>Embedding your Rust project into an external build system</li>
</ul>
<p>Apart from <code>cargo</code> and <code>meson</code>, most build systems donâ€™t have native Rust support. So youâ€™re most likely best off just using <code>cargo</code> for compiling your crate and any dependencies.</p>
<h2 id="setting-up-a-project"><a class="header" href="#setting-up-a-project">Setting up a project</a></h2>
<p>Create a new <code>cargo</code> project as usual.</p>
<p>There are flags to tell <code>cargo</code> to emit a systems library, instead of its regular rust target. This also allows you to set a different output name for your library, if you want it to differ from the rest of your crate.</p>
<pre><code class="language-toml">[lib]
name = "your_crate"
crate-type = ["cdylib"]      # Creates dynamic lib
# crate-type = ["staticlib"] # Creates static lib
</code></pre>
<h2 id="building-a-c-api"><a class="header" href="#building-a-c-api">Building a <code>C</code> API</a></h2>
<p>Because C++ has no stable ABI for the Rust compiler to target, we use <code>C</code> for any interoperability between different languages. This is no exception when using Rust inside of C and C++ code.</p>
<h3 id="no_mangle"><a class="header" href="#no_mangle"><code>#[no_mangle]</code></a></h3>
<p>The Rust compiler mangles symbol names differently than native code linkers expect. As such, any function that Rust exports to be used outside of Rust needs to be told not to be mangled by the compiler.</p>
<h3 id="extern-c"><a class="header" href="#extern-c"><code>extern "C"</code></a></h3>
<p>By default, any function you write in Rust will use the Rust ABI (which is also not stabilized). Instead, when building outwards facing FFI APIs we need to tell the compiler to use the system ABI.</p>
<p>Depending on your platform, you might want to target a specific ABI version, which are documented <a href="https://doc.rust-lang.org/reference/items/external-blocks.html">here</a>.</p>
<hr>
<p>Putting these parts together, you get a function that looks roughly like this.</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern "C" fn rust_function() {

}</code></pre>
<p>Just as when using <code>C</code> code in your Rust project you now need to transform data from and to a form that the rest of the application will understand.</p>
<h2 id="linking-and-greater-project-context"><a class="header" href="#linking-and-greater-project-context">Linking and greater project context.</a></h2>
<p>So then, thatâ€™s one half of the problem solved. How do you use this now?</p>
<p><strong>This very much depends on your project and/or build system</strong></p>
<p><code>cargo</code> will create a <code>my_lib.so</code>/<code>my_lib.dll</code> or <code>my_lib.a</code> file, depending on your platform and settings. This library can simply be linked by your build system.</p>
<p>However, calling a Rust function from C requires a header file to declare the function signatures.</p>
<p>Every function in your Rust-ffi API needs to have a corresponding header function.</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern "C" fn rust_function() {}</code></pre>
<p>would then become</p>
<pre><code class="language-C">void rust_function();
</code></pre>
<p>etc.</p>
<p>There is a tool to automate this process, called <a href="https://github.com/eqrion/cbindgen">cbindgen</a> which analyses your Rust code and then generates headers for your C and C++ projects from it.</p>
<p>At this point, using the Rust functions from C is as simple as including the header and calling them!</p>
<pre><code class="language-C">#include "my-rust-project.h"
rust_function();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="æœªåˆ†é¡ä¸»é¡Œ"><a class="header" href="#æœªåˆ†é¡ä¸»é¡Œ">æœªåˆ†é¡ä¸»é¡Œ</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="optimizations-the-speed-size-tradeoff"><a class="header" href="#optimizations-the-speed-size-tradeoff">Optimizations: the speed size tradeoff</a></h1>
<p>Everyone wants their program to be super fast and super small but itâ€™s usually not possible to have both characteristics. This section discusses the different optimization levels that <code>rustc</code> provides and how they affect the execution time and binary size of a program.</p>
<h2 id="no-optimizations"><a class="header" href="#no-optimizations">No optimizations</a></h2>
<p>This is the default. When you call <code>cargo build</code> you use the development (AKA <code>dev</code>) profile. This profile is optimized for debugging so it enables debug information and does <em>not</em> enable any optimizations, i.e. it uses <code>-C opt-level = 0</code>.</p>
<p>At least for bare metal development, debuginfo is zero cost in the sense that it wonâ€™t occupy space in Flash / ROM so we actually recommend that you enable debuginfo in the release profile â€“ it is disabled by default. That will let you use breakpoints when debugging release builds.</p>
<pre><code class="language-toml">[profile.release]
# symbols are nice and they don't increase the size on Flash
debug = true
</code></pre>
<p>No optimizations is great for debugging because stepping through the code feels like you are executing the program statement by statement, plus you can <code>print</code> stack variables and function arguments in GDB. When the code is optimized, trying to print variables results in <code>$0 = &lt;value optimized out&gt;</code> being printed.</p>
<p>The biggest downside of the <code>dev</code> profile is that the resulting binary will be huge and slow. The size is usually more of a problem because unoptimized binaries can occupy dozens of KiB of Flash, which your target device may not have â€“ the result: your unoptimized binary doesnâ€™t fit in your device!</p>
<p>Can we have smaller, debugger friendly binaries? Yes, thereâ€™s a trick.</p>
<h3 id="optimizing-dependencies"><a class="header" href="#optimizing-dependencies">Optimizing dependencies</a></h3>
<p>Thereâ€™s a Cargo feature named <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#overrides"><code>profile-overrides</code></a> that lets you override the optimization level of dependencies. You can use that feature to optimize all dependencies for size while keeping the top crate unoptimized and debugger friendly.</p>
<p>Beware that generic code can sometimes be optimized alongside the crate where it is instantiated, rather than the crate where it is defined. If you create an instance of a generic struct in your application and find that it pulls in code with a large footprint, it may be that increasing the optimisation level of the relevant dependencies has no effect.</p>
<p>Hereâ€™s an example:</p>
<pre><code class="language-toml"># Cargo.toml
[package]
name = "app"
# ..

[profile.dev.package."*"] # +
opt-level = "z" # +
</code></pre>
<p>Without the override:</p>
<pre><code class="language-text">$ cargo size --bin app -- -A
app  :
section               size        addr
.vector_table         1024   0x8000000
.text                 9060   0x8000400
.rodata               1708   0x8002780
.data                    0  0x20000000
.bss                     4  0x20000000
</code></pre>
<p>With the override:</p>
<pre><code class="language-text">$ cargo size --bin app -- -A
app  :
section               size        addr
.vector_table         1024   0x8000000
.text                 3490   0x8000400
.rodata               1100   0x80011c0
.data                    0  0x20000000
.bss                     4  0x20000000
</code></pre>
<p>Thatâ€™s a 6 KiB reduction in Flash usage without any loss in the debuggability of the top crate. If you step into a dependency then youâ€™ll start seeing those <code>&lt;value optimized out&gt;</code> messages again but itâ€™s usually the case that you want to debug the top crate and not the dependencies. And if you <em>do</em> need to debug a dependency then you can use the <code>profile-overrides</code> feature to exclude a particular dependency from being optimized. See example below:</p>
<pre><code class="language-toml"># ..

# don't optimize the `cortex-m-rt` crate
[profile.dev.package.cortex-m-rt] # +
opt-level = 0 # +

# but do optimize all the other dependencies
[profile.dev.package."*"]
codegen-units = 1 # better optimizations
opt-level = "z"
</code></pre>
<p>Now the top crate and <code>cortex-m-rt</code> are debugger friendly!</p>
<h2 id="optimize-for-speed"><a class="header" href="#optimize-for-speed">Optimize for speed</a></h2>
<p>As of 2018-09-18 <code>rustc</code> supports three â€œoptimize for speedâ€ levels: <code>opt-level = 1</code>, <code>2</code> and <code>3</code>. When you run <code>cargo build --release</code> you are using the release profile which defaults to <code>opt-level = 3</code>.</p>
<p>Both <code>opt-level = 2</code> and <code>3</code> optimize for speed at the expense of binary size, but level <code>3</code> does more vectorization and inlining than level <code>2</code>. In particular, youâ€™ll see that at <code>opt-level</code> equal to or greater than <code>2</code> LLVM will unroll loops. Loop unrolling has a rather high cost in terms of Flash / ROM (e.g. from 26 bytes to 194 for a zero this array loop) but can also halve the execution time given the right conditions (e.g. number of iterations is big enough).</p>
<p>Currently thereâ€™s no way to disable loop unrolling in <code>opt-level = 2</code> and <code>3</code> so if you canâ€™t afford its cost you should optimize your program for size.</p>
<h2 id="optimize-for-size"><a class="header" href="#optimize-for-size">Optimize for size</a></h2>
<p>As of 2018-09-18 <code>rustc</code> supports two â€œoptimize for sizeâ€ levels: <code>opt-level = "s"</code> and <code>"z"</code>. These names were inherited from clang / LLVM and are not too descriptive but <code>"z"</code> is meant to give the idea that it produces smaller binaries than <code>"s"</code>.</p>
<p>If you want your release binaries to be optimized for size then change the <code>profile.release.opt-level</code> setting in <code>Cargo.toml</code> as shown below.</p>
<pre><code class="language-toml">[profile.release]
# or "z"
opt-level = "s"
</code></pre>
<p>These two optimization levels greatly reduce LLVMâ€™s inline threshold, a metric used to decide whether to inline a function or not. One of Rust principles are zero cost abstractions; these abstractions tend to use a lot of newtypes and small functions to hold invariants (e.g. functions that borrow an inner value like <code>deref</code>, <code>as_ref</code>) so a low inline threshold can make LLVM miss optimization opportunities (e.g. eliminate dead branches, inline calls to closures).</p>
<p>When optimizing for size you may want to try increasing the inline threshold to see if that has any effect on the binary size. The recommended way to change the inline threshold is to append the <code>-C inline-threshold</code> flag to the other rustflags in <code>.cargo/config.toml</code>.</p>
<pre><code class="language-toml"># .cargo/config.toml
# this assumes that you are using the cortex-m-quickstart template
[target.'cfg(all(target_arch = "arm", target_os = "none"))']
rustflags = [
  # ..
  "-C", "inline-threshold=123", # +
]
</code></pre>
<p>What value to use? <a href="https://github.com/rust-lang/rust/blob/1.29.0/src/librustc_codegen_llvm/back/write.rs#L2105-L2122">As of 1.29.0 these are the inline thresholds that the different optimization levels use</a>:</p>
<ul>
<li><code>opt-level = 3</code> uses 275</li>
<li><code>opt-level = 2</code> uses 225</li>
<li><code>opt-level = "s"</code> uses 75</li>
<li><code>opt-level = "z"</code> uses 25</li>
</ul>
<p>You should try <code>225</code> and <code>275</code> when optimizing for size.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performing-math-functionality-with-no_std"><a class="header" href="#performing-math-functionality-with-no_std">Performing math functionality with <code>#[no_std]</code></a></h1>
<p>If you want to perform math related functionality like calculating the squareroot or the exponential of a number and you have the full standard library available, your code might look like this:</p>
<pre><code class="language-rs">//! Some mathematical functions with standard support available

fn main() {
    let float: f32 = 4.82832;
    let floored_float = float.floor();

    let sqrt_of_four = floored_float.sqrt();

    let sinus_of_four = floored_float.sin();

    let exponential_of_four = floored_float.exp();
    println!("Floored test float {} to {}", float, floored_float);
    println!("The square root of {} is {}", floored_float, sqrt_of_four);
    println!("The sinus of four is {}", sinus_of_four);
    println!(
        "The exponential of four to the base e is {}",
        exponential_of_four
    )
}
</code></pre>
<p>Without standard library support, these functions are not available. An external crate like <a href="https://crates.io/crates/libm"><code>libm</code></a> can be used instead. The example code would then look like this:</p>
<pre><code class="language-rs">#![no_main]
#![no_std]

use panic_halt as _;

use cortex_m_rt::entry;
use cortex_m_semihosting::{debug, hprintln};
use libm::{exp, floorf, sin, sqrtf};

#[entry]
fn main() -&gt; ! {
    let float = 4.82832;
    let floored_float = floorf(float);

    let sqrt_of_four = sqrtf(floored_float);

    let sinus_of_four = sin(floored_float.into());

    let exponential_of_four = exp(floored_float.into());
    hprintln!("Floored test float {} to {}", float, floored_float).unwrap();
    hprintln!("The square root of {} is {}", floored_float, sqrt_of_four).unwrap();
    hprintln!("The sinus of four is {}", sinus_of_four).unwrap();
    hprintln!(
        "The exponential of four to the base e is {}",
        exponential_of_four
    )
    .unwrap();
    // exit QEMU
    // NOTE do not run this on hardware; it can corrupt OpenOCD state
    // debug::exit(debug::EXIT_SUCCESS);

    loop {}
}
</code></pre>
<p>If you need to perform more complex operations like DSP signal processing or advanced linear algebra on your MCU, the following crates might help you</p>
<ul>
<li><a href="https://github.com/jacobrosenthal/cmsis-dsp-sys">CMSIS DSP library binding</a></li>
<li><a href="https://crates.io/crates/constgebra"><code>constgebra</code></a></li>
<li><a href="https://github.com/tarcieri/micromath"><code>micromath</code></a></li>
<li><a href="https://crates.io/crates/microfft"><code>microfft</code></a></li>
<li><a href="https://github.com/dimforge/nalgebra"><code>nalgebra</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="é™„éŒ„-aè©å½™è¡¨"><a class="header" href="#é™„éŒ„-aè©å½™è¡¨">é™„éŒ„ Aï¼šè©å½™è¡¨</a></h1>
<p>åµŒå…¥å¼ç”Ÿæ…‹ç³»å……æ»¿å„ç¨®å”å®šã€ç¡¬é«”å…ƒä»¶èˆ‡å» å•†ç‰¹æœ‰çš„äº‹ç‰©ï¼Œä¸”éƒ½æœ‰å„è‡ªçš„è¡“èªèˆ‡ç¸®å¯«ã€‚æœ¬è©å½™è¡¨å˜—è©¦åˆ—å‡ºå®ƒå€‘ï¼Œä¸¦æä¾›ç†è§£å®ƒå€‘çš„æŒ‡å¼•ã€‚</p>
<h3 id="bsp"><a class="header" href="#bsp">BSP</a></h3>
<p>æ¿ç´šæ”¯æ´å¥—ä»¶ï¼ˆBoard Support Crateï¼‰æä¾›ç‚ºç‰¹å®šé–‹ç™¼æ¿è¨­å®šå¥½çš„é«˜éšä»‹é¢ã€‚å®ƒé€šå¸¸ä¾è³´ <a href="#hal">HAL</a> å¥—ä»¶ã€‚æ›´è©³ç´°çš„èªªæ˜å¯åƒè€ƒ<a href="#memory-mapped-registers">è¨˜æ†¶é«”å°æ˜ æš«å­˜å™¨é é¢</a>ï¼Œæˆ–è§€çœ‹æ›´å»£æ³›æ¦‚è¦½çš„<a href="https://youtu.be/vLYit_HHPaY">é€™æ®µå½±ç‰‡</a>ã€‚</p>
<h3 id="fpu"><a class="header" href="#fpu">FPU</a></h3>
<p>æµ®é»é‹ç®—å–®å…ƒã€‚åƒ…åŸ·è¡Œæµ®é»æ•¸é‹ç®—çš„ã€Œæ•¸å­¸è™•ç†å™¨ã€ã€‚</p>
<h3 id="hal"><a class="header" href="#hal">HAL</a></h3>
<p>ç¡¬é«”æŠ½è±¡å±¤ï¼ˆHardware Abstraction Layerï¼‰å¥—ä»¶æä¾›å°å¾®æ§åˆ¶å™¨åŠŸèƒ½èˆ‡å‘¨é‚Šçš„é–‹ç™¼è€…å‹å–„ä»‹é¢ã€‚å®ƒé€šå¸¸å»ºç«‹åœ¨<a href="#pac">å‘¨é‚Šå­˜å–å¥—ä»¶ï¼ˆPACï¼‰</a>ä¹‹ä¸Šï¼Œä¹Ÿå¯èƒ½å¯¦ä½œ<a href="https://crates.io/crates/embedded-hal"><code>embedded-hal</code></a> å¥—ä»¶ä¸­çš„ traitsã€‚æ›´è©³ç´°çš„èªªæ˜å¯åƒè€ƒ<a href="#memory-mapped-registers">è¨˜æ†¶é«”å°æ˜ æš«å­˜å™¨é é¢</a>ï¼Œæˆ–è§€çœ‹æ›´å»£æ³›æ¦‚è¦½çš„<a href="https://youtu.be/vLYit_HHPaY">é€™æ®µå½±ç‰‡</a>ã€‚</p>
<h3 id="i2c"><a class="header" href="#i2c">I2C</a></h3>
<p>æœ‰æ™‚ç¨±ç‚º <code>IÂ²C</code> æˆ– Inter-ICã€‚é€™æ˜¯ä¸€ç¨®ç”¨æ–¼å–®ä¸€ç©é«”é›»è·¯å…§ç¡¬é«”é€šè¨Šçš„å”å®šã€‚è©³è¦‹<a href="https://en.wikipedia.org/wiki/I2c">é€™è£¡</a>ã€‚</p>
<h3 id="pac"><a class="header" href="#pac">PAC</a></h3>
<p>å‘¨é‚Šå­˜å–å¥—ä»¶ï¼ˆPeripheral Access Crateï¼‰æä¾›å°å¾®æ§åˆ¶å™¨å‘¨é‚Šçš„å­˜å–ã€‚å®ƒæ˜¯è¼ƒåº•å±¤çš„å¥—ä»¶ä¹‹ä¸€ï¼Œé€šå¸¸ç›´æ¥ç”±æä¾›çš„ <a href="#svd">SVD</a> ç”¢ç”Ÿï¼Œå¸¸ç”¨å·¥å…·ç‚º <a href="https://github.com/rust-embedded/svd2rust/">svd2rust</a>ã€‚<a href="#hal">ç¡¬é«”æŠ½è±¡å±¤</a>é€šå¸¸æœƒä¾è³´æ­¤å¥—ä»¶ã€‚æ›´è©³ç´°çš„èªªæ˜å¯åƒè€ƒ<a href="#memory-mapped-registers">è¨˜æ†¶é«”å°æ˜ æš«å­˜å™¨é é¢</a>ï¼Œæˆ–è§€çœ‹æ›´å»£æ³›æ¦‚è¦½çš„<a href="https://youtu.be/vLYit_HHPaY">é€™æ®µå½±ç‰‡</a>ã€‚</p>
<h3 id="spi"><a class="header" href="#spi">SPI</a></h3>
<p>åºåˆ—å‘¨é‚Šä»‹é¢ã€‚è©³è¦‹<a href="https://en.wikipedia.org/wiki/Serial_peripheral_interface">é€™è£¡</a>ã€‚</p>
<h3 id="svd"><a class="header" href="#svd">SVD</a></h3>
<p>System View Description æ˜¯ä¸€ç¨® XML æª”æ¡ˆæ ¼å¼ï¼Œç”¨æ–¼æè¿°ç¨‹å¼è¨­è¨ˆè€…å°å¾®æ§åˆ¶å™¨è£ç½®çš„è¦–è§’ã€‚è©³è¦‹ <a href="https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html">ARM CMSIS æ–‡ä»¶ç¶²ç«™</a>ã€‚</p>
<h3 id="uart"><a class="header" href="#uart">UART</a></h3>
<p>é€šç”¨éåŒæ­¥æ”¶ç™¼å™¨ã€‚è©³è¦‹<a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">é€™è£¡</a>ã€‚</p>
<h3 id="usart"><a class="header" href="#usart">USART</a></h3>
<p>é€šç”¨åŒæ­¥èˆ‡éåŒæ­¥æ”¶ç™¼å™¨ã€‚è©³è¦‹<a href="https://en.wikipedia.org/wiki/Universal_synchronous_and_asynchronous_receiver-transmitter">é€™è£¡</a>ã€‚</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
