msgid ""
msgstr ""
"Project-Id-Version: The Embedded Rust Book\n"
"POT-Creation-Date: 2025-12-02T17:24:38Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/peripherals/index.md:1
msgid "Peripherals"
msgstr "周邊"

#: src/peripherals/index.md:3
msgid "What are Peripherals?"
msgstr "什麼是周邊？"

#: src/peripherals/index.md:5
msgid ""
"Most Microcontrollers have more than just a CPU, RAM, or Flash Memory - they "
"contain sections of silicon which are used for interacting with systems "
"outside of the microcontroller, as well as directly and indirectly "
"interacting with their surroundings in the world via sensors, motor "
"controllers, or human interfaces such as a display or keyboard. These "
"components are collectively known as Peripherals."
msgstr ""
"多數微控制器不只有 CPU、RAM 或快閃記憶體，還包含用於與微控制器外部系統互動的"
"矽區塊，也會透過感測器、馬達控制器或顯示器、鍵盤等人機介面，直接或間接地與周"
"遭環境互動。這些元件統稱為周邊。"

#: src/peripherals/index.md:7
msgid ""
"These peripherals are useful because they allow a developer to offload "
"processing to them, avoiding having to handle everything in software. "
"Similar to how a desktop developer would offload graphics processing to a "
"video card, embedded developers can offload some tasks to peripherals "
"allowing the CPU to spend its time doing something else important, or doing "
"nothing in order to save power."
msgstr ""
"這些周邊之所以有用，是因為它們讓開發者可以把處理工作卸載給周邊，避免所有事都"
"由軟體處理。就像桌面開發者會把圖形處理交給顯示卡一樣，嵌入式開發者可把某些工"
"作交給周邊，讓 CPU 可以去做更重要的事，或不做事以節省功耗。"

#: src/peripherals/index.md:9
msgid ""
"If you look at the main circuit board in an old-fashioned home computer from "
"the 1970s or 1980s (and actually, the desktop PCs of yesterday are not so "
"far removed from the embedded systems of today) you would expect to see:"
msgstr ""
"如果你看看 1970 或 1980 年代老式家用電腦的主機板（其實昨日的桌機與今日的嵌入"
"式系統並沒有太大差別），你大概會看到："

#: src/peripherals/index.md:11
msgid "A processor"
msgstr "處理器"

#: src/peripherals/index.md:12
msgid "A RAM chip"
msgstr "RAM 晶片"

#: src/peripherals/index.md:13
msgid "A ROM chip"
msgstr "ROM 晶片"

#: src/peripherals/index.md:14
msgid "An I/O controller"
msgstr "I/O 控制器"

#: src/peripherals/index.md:16
msgid ""
"The RAM chip, ROM chip and I/O controller (the peripheral in this system) "
"would be joined to the processor through a series of parallel traces known "
"as a 'bus'. This bus carries address information, which selects which device "
"on the bus the processor wishes to communicate with, and a data bus which "
"carries the actual data. In our embedded microcontrollers, the same "
"principles apply - it's just that everything is packed on to a single piece "
"of silicon."
msgstr ""
"RAM 晶片、ROM 晶片與 I/O 控制器（此系統中的周邊）會透過一組稱為「匯流排」的平"
"行線路連接到處理器。匯流排負責攜帶位址資訊，用以選擇處理器想要溝通的裝置；以"
"及資料匯流排，用以傳輸實際資料。在嵌入式微控制器中，同樣的原理適用——只是所有"
"東西都被封裝在同一塊矽晶片上。"

#: src/peripherals/index.md:18
msgid ""
"However, unlike graphics cards, which typically have a Software API like "
"Vulkan, Metal, or OpenGL, peripherals are exposed to our Microcontroller "
"with a hardware interface, which is mapped to a chunk of the memory."
msgstr ""
"然而，不同於通常有 Vulkan、Metal 或 OpenGL 等軟體 API 的顯示卡，周邊會以硬體"
"介面呈現給微控制器，並對映到一段記憶體。"

#: src/peripherals/index.md:20
msgid "Linear and Real Memory Space"
msgstr "線性與實體記憶體空間"

#: src/peripherals/index.md:22
msgid ""
"On a microcontroller, writing some data to some other arbitrary address, "
"such as `0x4000_0000` or `0x0000_0000`, may also be a completely valid "
"action."
msgstr ""
"在微控制器上，將資料寫入其他任意位址（如 `0x4000_0000` 或 `0x0000_0000`）可能"
"也是完全合法的動作。"

#: src/peripherals/index.md:24
msgid ""
"On a desktop system, access to memory is tightly controlled by the MMU, or "
"Memory Management Unit. This component has two major responsibilities: "
"enforcing access permission to sections of memory (preventing one process "
"from reading or modifying the memory of another process); and re-mapping "
"segments of the physical memory to virtual memory ranges used in software. "
"Microcontrollers do not typically have an MMU, and instead only use real "
"physical addresses in software."
msgstr ""
"在桌面系統上，記憶體存取由 MMU（Memory Management Unit）嚴格控制。此元件有兩"
"項主要責任：強制記憶體區段的存取權限（防止某行程讀取或修改另一行程的記憶"
"體）；以及將實體記憶體區段重新對映到軟體使用的虛擬記憶體範圍。微控制器通常沒"
"有 MMU，而是只在軟體中使用實體位址。"

#: src/peripherals/index.md:26
msgid ""
"Although 32 bit microcontrollers have a real and linear address space from "
"`0x0000_0000`, and `0xFFFF_FFFF`, they generally only use a few hundred "
"kilobytes of that range for actual memory. This leaves a significant amount "
"of address space remaining. In earlier chapters, we were talking about RAM "
"being located at address `0x2000_0000`. If our RAM was 64 KiB long (i.e. "
"with a maximum address of 0xFFFF) then addresses `0x2000_0000` to "
"`0x2000_FFFF` would correspond to our RAM. When we write to a variable which "
"lives at address `0x2000_1234`, what happens internally is that some logic "
"detects the upper portion of the address (0x2000 in this example) and then "
"activates the RAM so that it can act upon the lower portion of the address "
"(0x1234 in this case). On a Cortex-M we also have our Flash ROM mapped in at "
"address `0x0000_0000` up to, say, address `0x0007_FFFF` (if we have a 512 "
"KiB Flash ROM). Rather than ignore all remaining space between these two "
"regions, Microcontroller designers instead mapped the interface for "
"peripherals in certain memory locations. This ends up looking something like "
"this:"
msgstr ""
"雖然 32 位元微控制器擁有從 `0x0000_0000` 到 `0xFFFF_FFFF` 的實體線性位址空"
"間，但實際記憶體通常只使用其中幾百 KB，留下大量位址空間。前面章節提到 RAM 位"
"於 `0x2000_0000`。若 RAM 為 64 KiB（最大位址 0xFFFF），那麼 `0x2000_0000` 到 "
"`0x2000_FFFF` 就對應到 RAM。當我們寫入位於 `0x2000_1234` 的變數時，內部會有邏"
"輯偵測位址高位（此例為 0x2000），並啟用 RAM 以處理低位址部分（此例為 "
"0x1234）。在 Cortex-M 上，Flash ROM 也會對映在 `0x0000_0000` 到例如 "
"`0x0007_FFFF`（若有 512 KiB Flash ROM）。微控制器設計者不會忽略這兩個區域之間"
"的空間，而是把周邊的介面對映到特定位址，結果看起來像這樣："

#: src/peripherals/index.md:28
msgid "![](../assets/nrf52-memory-map.png)"
msgstr ""

#: src/peripherals/index.md:30 src/peripherals/index.md:40
msgid ""
"[Nordic nRF52832 Datasheet (pdf)](http://infocenter.nordicsemi.com/pdf/"
"nRF52832_PS_v1.1.pdf)"
msgstr ""
"[Nordic nRF52832 規格書（pdf）](http://infocenter.nordicsemi.com/pdf/"
"nRF52832_PS_v1.1.pdf)"

#: src/peripherals/index.md:32
msgid "Memory Mapped Peripherals"
msgstr "記憶體對映周邊"

#: src/peripherals/index.md:34
msgid ""
"Interaction with these peripherals is simple at a first glance - write the "
"right data to the correct address. For example, sending a 32 bit word over a "
"serial port could be as direct as writing that 32 bit word to a certain "
"memory address. The Serial Port Peripheral would then take over and send out "
"the data automatically."
msgstr ""
"乍看之下，與這些周邊互動很簡單——把正確資料寫到正確位址。例如，透過序列埠送出"
"一個 32 位元字，可能就只是將該 32 位元字寫入某個記憶體位址。序列埠周邊會接手"
"並自動送出資料。"

#: src/peripherals/index.md:36
msgid ""
"Configuration of these peripherals works similarly. Instead of calling a "
"function to configure a peripheral, a chunk of memory is exposed which "
"serves as the hardware API. Write `0x8000_0000` to a SPI Frequency "
"Configuration Register, and the SPI port will send data at 8 Megabits per "
"second. Write `0x0200_0000` to the same address, and the SPI port will send "
"data at 125 Kilobits per second. These configuration registers look a little "
"bit like this:"
msgstr ""
"周邊的設定方式也類似。不是呼叫函式來設定周邊，而是有一塊記憶體作為硬體 API。"
"把 `0x8000_0000` 寫到 SPI 頻率設定暫存器，SPI 就會以 8 Mbps 傳輸；把 "
"`0x0200_0000` 寫到同一位址，SPI 就會以 125 Kbps 傳輸。這些設定暫存器看起來像"
"這樣："

#: src/peripherals/index.md:38
msgid "![](../assets/nrf52-spi-frequency-register.png)"
msgstr ""

#: src/peripherals/index.md:42
msgid ""
"This interface is how interactions with the hardware are made, no matter "
"what language is used, whether that language is Assembly, C, or Rust."
msgstr "不論使用何種語言（組合語言、C 或 Rust），都必須透過此介面與硬體互動。"
