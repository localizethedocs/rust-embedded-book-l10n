msgid ""
msgstr ""
"Project-Id-Version: The Embedded Rust Book\n"
"POT-Creation-Date: 2025-12-02T17:24:38Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/intro/no-std.md:1
msgid "A `no_std` Rust Environment"
msgstr ""

#: src/intro/no-std.md:3
msgid ""
"The term Embedded Programming is used for a wide range of different classes "
"of programming. Ranging from programming 8-Bit MCUs (like the [ST72325xx]"
"(https://www.st.com/resource/en/datasheet/st72325j6.pdf)) with just a few KB "
"of RAM and ROM, up to systems like the Raspberry Pi ([Model B 3+](https://en."
"wikipedia.org/wiki/Raspberry_Pi#Specifications)) which has a 32/64-bit 4-"
"core Cortex-A53 @ 1.4 GHz and 1GB of RAM. Different restrictions/limitations "
"will apply when writing code depending on what kind of target and use case "
"you have."
msgstr ""

#: src/intro/no-std.md:10
msgid "There are two general Embedded Programming classifications:"
msgstr ""

#: src/intro/no-std.md:12
msgid "Hosted Environments"
msgstr ""

#: src/intro/no-std.md:13
msgid ""
"These kinds of environments are close to a normal PC environment. What this "
"means is that you are provided with a System Interface [E.G. POSIX](https://"
"en.wikipedia.org/wiki/POSIX) that provides you with primitives to interact "
"with various systems, such as file systems, networking, memory management, "
"threads, etc. Standard libraries in turn usually depend on these primitives "
"to implement their functionality. You may also have some sort of sysroot and "
"restrictions on RAM/ROM-usage, and perhaps some special HW or I/Os. Overall "
"it feels like coding on a special-purpose PC environment."
msgstr ""

#: src/intro/no-std.md:20
msgid "Bare Metal Environments"
msgstr ""

#: src/intro/no-std.md:21
msgid ""
"In a bare metal environment no code has been loaded before your program. "
"Without the software provided by an OS we can not load the standard library. "
"Instead the program, along with the crates it uses, can only use the "
"hardware (bare metal) to run. To prevent rust from loading the standard "
"library use `no_std`. The platform-agnostic parts of the standard library "
"are available through [libcore](https://doc.rust-lang.org/core/). libcore "
"also excludes things which are not always desirable in an embedded "
"environment. One of these things is a memory allocator for dynamic memory "
"allocation. If you require this or any other functionalities there are often "
"crates which provide these."
msgstr ""

#: src/intro/no-std.md:30
msgid "The libstd Runtime"
msgstr ""

#: src/intro/no-std.md:31
msgid ""
"As mentioned before using [libstd](https://doc.rust-lang.org/std/) requires "
"some sort of system integration, but this is not only because [libstd]"
"(https://doc.rust-lang.org/std/) is just providing a common way of accessing "
"OS abstractions, it also provides a runtime. This runtime, among other "
"things, takes care of setting up stack overflow protection, processing "
"command line arguments, and spawning the main thread before a program's main "
"function is invoked. This runtime also won't be available in a `no_std` "
"environment."
msgstr ""

#: src/intro/no-std.md:36
msgid "Summary"
msgstr ""

#: src/intro/no-std.md:37
msgid ""
"`#![no_std]` is a crate-level attribute that indicates that the crate will "
"link to the core-crate instead of the std-crate. The [libcore](https://doc."
"rust-lang.org/core/) crate in turn is a platform-agnostic subset of the std "
"crate which makes no assumptions about the system the program will run on. "
"As such, it provides APIs for language primitives like floats, strings and "
"slices, as well as APIs that expose processor features like atomic "
"operations and SIMD instructions. However it lacks APIs for anything that "
"involves platform integration. Because of these properties no\\_std and "
"[libcore](https://doc.rust-lang.org/core/) code can be used for any kind of "
"bootstrapping (stage 0) code like bootloaders, firmware or kernels."
msgstr ""

#: src/intro/no-std.md:45
msgid "Overview"
msgstr ""

#: src/intro/no-std.md:47
msgid "feature"
msgstr ""

#: src/intro/no-std.md:47
msgid "no\\_std"
msgstr ""

#: src/intro/no-std.md:47
msgid "std"
msgstr ""

#: src/intro/no-std.md:49
msgid "heap (dynamic memory)"
msgstr ""

#: src/intro/no-std.md:49
msgid "\\*"
msgstr ""

#: src/intro/no-std.md:49 src/intro/no-std.md:50 src/intro/no-std.md:51
#: src/intro/no-std.md:52 src/intro/no-std.md:53 src/intro/no-std.md:54
#: src/intro/no-std.md:55
msgid "✓"
msgstr ""

#: src/intro/no-std.md:50
msgid "collections (Vec, BTreeMap, etc)"
msgstr ""

#: src/intro/no-std.md:50
msgid "\\**"
msgstr ""

#: src/intro/no-std.md:51
msgid "stack overflow protection"
msgstr ""

#: src/intro/no-std.md:51 src/intro/no-std.md:52 src/intro/no-std.md:53
#: src/intro/no-std.md:55
msgid "✘"
msgstr ""

#: src/intro/no-std.md:52
msgid "runs init code before main"
msgstr ""

#: src/intro/no-std.md:53
msgid "libstd available"
msgstr ""

#: src/intro/no-std.md:54
msgid "libcore available"
msgstr ""

#: src/intro/no-std.md:55
msgid "writing firmware, kernel, or bootloader code"
msgstr ""

#: src/intro/no-std.md:57
msgid ""
"\\* Only if you use the `alloc` crate and use a suitable allocator like "
"[alloc-cortex-m](https://github.com/rust-embedded/alloc-cortex-m)."
msgstr ""

#: src/intro/no-std.md:59
msgid ""
"\\*\\* Only if you use the `collections` crate and configure a global "
"default allocator."
msgstr ""

#: src/intro/no-std.md:61
msgid ""
"\\*\\* HashMap and HashSet are not available due to a lack of a secure "
"random number generator."
msgstr ""

#: src/intro/no-std.md:65
msgid "See Also"
msgstr ""

#: src/intro/no-std.md:66
msgid ""
"[RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-"
"no_std.md)"
msgstr ""
