msgid ""
msgstr ""
"Project-Id-Version: The Embedded Rust Book\n"
"POT-Creation-Date: 2025-12-02T17:24:38Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/start/qemu.md:1
msgid "QEMU"
msgstr "QEMU"

#: src/start/qemu.md:3
msgid ""
"We'll start writing a program for the [LM3S6965](http://www.ti.com/product/"
"LM3S6965), a Cortex-M3 microcontroller. We have chosen this as our initial "
"target because it [can be emulated](https://wiki.qemu.org/Documentation/"
"Platforms/ARM#Supported_in_qemu-system-arm) using QEMU so you don't need to "
"fiddle with hardware in this section and we can focus on the tooling and the "
"development process."
msgstr ""

#: src/start/qemu.md:10
msgid ""
"**IMPORTANT** We'll use the name \"app\" for the project name in this "
"tutorial. Whenever you see the word \"app\" you should replace it with the "
"name you selected for your project. Or, you could also name your project "
"\"app\" and avoid the substitutions."
msgstr ""

#: src/start/qemu.md:16
msgid "Creating a non standard Rust program"
msgstr ""

#: src/start/qemu.md:18
msgid ""
"We'll use the [`cortex-m-quickstart`](https://github.com/rust-embedded/"
"cortex-m-quickstart) project template to generate a new project from it. The "
"created project will contain a barebone application: a good starting point "
"for a new embedded rust application. In addition, the project will contain "
"an `examples` directory, with several separate applications, highlighting "
"some of the key embedded rust functionality."
msgstr ""

#: src/start/qemu.md:26
msgid "Using `cargo-generate`"
msgstr "使用 `cargo-generate`"

#: src/start/qemu.md:27
msgid "First install cargo-generate"
msgstr "首先安裝 cargo-generate"

#: src/start/qemu.md:31
msgid "Then generate a new project"
msgstr "接著生成新專案"

#: src/start/qemu.md:32
msgid ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"
msgstr ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"

#: src/start/qemu.md:46
msgid "Using `git`"
msgstr "使用 `git`"

#: src/start/qemu.md:48
msgid "Clone the repository"
msgstr ""

#: src/start/qemu.md:50
msgid ""
"```console\n"
"git clone https://github.com/rust-embedded/cortex-m-quickstart app\n"
"cd app\n"
"```"
msgstr ""

#: src/start/qemu.md:55
msgid "And then fill in the placeholders in the `Cargo.toml` file"
msgstr ""

#: src/start/qemu.md:57
msgid ""
"```toml\n"
"[package]\n"
"authors = [\"{{authors}}\"] # \"{{authors}}\" -> \"John Smith\"\n"
"edition = \"2018\"\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"version = \"0.1.0\"\n"
"\n"
"# ..\n"
"\n"
"[[bin]]\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"test = false\n"
"bench = false\n"
"```"
msgstr ""

#: src/start/qemu.md:72
msgid "Using neither"
msgstr ""

#: src/start/qemu.md:74
msgid ""
"Grab the latest snapshot of the `cortex-m-quickstart` template and extract "
"it."
msgstr ""

#: src/start/qemu.md:76
msgid ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/master."
"zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"
msgstr ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/master."
"zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"

#: src/start/qemu.md:83
msgid ""
"Or you can browse to [`cortex-m-quickstart`](https://github.com/rust-"
"embedded/cortex-m-quickstart), click the green \"Clone or download\" button "
"and then click \"Download ZIP\"."
msgstr ""

#: src/start/qemu.md:86
msgid ""
"Then fill in the placeholders in the `Cargo.toml` file as done in the second "
"part of the \"Using `git`\" version."
msgstr ""

#: src/start/qemu.md:89
msgid "Program Overview"
msgstr ""

#: src/start/qemu.md:91
msgid ""
"For convenience here are the most important parts of the source code in `src/"
"main.rs`:"
msgstr ""

#: src/start/qemu.md:104
msgid "// your code goes here\n"
msgstr ""

#: src/start/qemu.md:109
msgid ""
"This program is a bit different from a standard Rust program so let's take a "
"closer look."
msgstr ""

#: src/start/qemu.md:112
msgid ""
"`#![no_std]` indicates that this program will _not_ link to the standard "
"crate, `std`. Instead it will link to its subset: the `core` crate."
msgstr ""

#: src/start/qemu.md:115
msgid ""
"`#![no_main]` indicates that this program won't use the standard `main` "
"interface that most Rust programs use. The main (no pun intended) reason to "
"go with `no_main` is that using the `main` interface in `no_std` context "
"requires nightly."
msgstr ""

#: src/start/qemu.md:120
msgid ""
"`use panic_halt as _;`. This crate provides a `panic_handler` that defines "
"the panicking behavior of the program. We will cover this in more detail in "
"the [Panicking](panicking.md) chapter of the book."
msgstr ""

#: src/start/qemu.md:124
msgid ""
"[`#[entry]`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/"
"attr.entry.html) is an attribute provided by the [`cortex-m-rt`](https://"
"crates.io/crates/cortex-m-rt) crate that's used to mark the entry point of "
"the program. As we are not using the standard `main` interface we need "
"another way to indicate the entry point of the program and that'd be "
"`#[entry]`."
msgstr ""

#: src/start/qemu.md:132
msgid ""
"`fn main() -> !`. Our program will be the _only_ process running on the "
"target hardware so we don't want it to end! We use a [divergent function]"
"(https://doc.rust-lang.org/rust-by-example/fn/diverging.html) (the `-> !` "
"bit in the function signature) to ensure at compile time that'll be the case."
msgstr ""

#: src/start/qemu.md:136
msgid "Cross compiling"
msgstr "交叉編譯"

#: src/start/qemu.md:138
msgid ""
"The next step is to _cross_ compile the program for the Cortex-M3 "
"architecture. That's as simple as running `cargo build --target $TRIPLE` if "
"you know what the compilation target (`$TRIPLE`) should be. Luckily, the `."
"cargo/config.toml` in the template has the answer:"
msgstr ""

#: src/start/qemu.md:147
msgid ""
"```toml\n"
"[build]\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"# target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""

#: src/start/qemu.md:156
msgid ""
"To cross compile for the Cortex-M3 architecture we have to use `thumbv7m-"
"none-eabi`. That target is not automatically installed when installing the "
"Rust toolchain, it would now be a good time to add that target to the "
"toolchain, if you haven't done it yet:"
msgstr ""

#: src/start/qemu.md:163
msgid ""
"Since the `thumbv7m-none-eabi` compilation target has been set as the "
"default in your `.cargo/config.toml` file, the two commands below do the "
"same:"
msgstr ""

#: src/start/qemu.md:171
msgid "Inspecting"
msgstr ""

#: src/start/qemu.md:173
msgid ""
"Now we have a non-native ELF binary in `target/thumbv7m-none-eabi/debug/"
"app`. We can inspect it using `cargo-binutils`."
msgstr ""

#: src/start/qemu.md:176
msgid ""
"With `cargo-readobj` we can print the ELF headers to confirm that this is an "
"ARM binary."
msgstr ""

#: src/start/qemu.md:183
msgid "Note that:"
msgstr ""

#: src/start/qemu.md:184
msgid ""
"`--bin app` is sugar for inspect the binary at `target/$TRIPLE/debug/app`"
msgstr ""

#: src/start/qemu.md:185
msgid "`--bin app` will also (re)compile the binary, if necessary"
msgstr ""

#: src/start/qemu.md:211
msgid "`cargo-size` can print the size of the linker sections of the binary."
msgstr ""

#: src/start/qemu.md:217
msgid "we use `--release` to inspect the optimized version"
msgstr ""

#: src/start/qemu.md:241
msgid "A refresher on ELF linker sections"
msgstr ""

#: src/start/qemu.md:243
msgid "`.text` contains the program instructions"
msgstr ""

#: src/start/qemu.md:244
msgid "`.rodata` contains constant values like strings"
msgstr ""

#: src/start/qemu.md:245
msgid ""
"`.data` contains statically allocated variables whose initial values are "
"_not_ zero"
msgstr ""

#: src/start/qemu.md:247
msgid ""
"`.bss` also contains statically allocated variables whose initial values "
"_are_ zero"
msgstr ""

#: src/start/qemu.md:249
msgid ""
"`.vector_table` is a _non_\\-standard section that we use to store the "
"vector (interrupt) table"
msgstr ""

#: src/start/qemu.md:251
msgid ""
"`.ARM.attributes` and the `.debug_*` sections contain metadata and will "
"_not_ be loaded onto the target when flashing the binary."
msgstr ""

#: src/start/qemu.md:254
msgid ""
"**IMPORTANT**: ELF files contain metadata like debug information so their "
"_size on disk_ does _not_ accurately reflect the space the program will "
"occupy when flashed on a device. _Always_ use `cargo-size` to check how big "
"a binary really is."
msgstr ""

#: src/start/qemu.md:259
msgid "`cargo-objdump` can be used to disassemble the binary."
msgstr ""

#: src/start/qemu.md:265
msgid ""
"**NOTE** if the above command complains about `Unknown command line "
"argument` see the following bug report: https://github.com/rust-embedded/"
"book/issues/269"
msgstr ""

#: src/start/qemu.md:268
msgid ""
"**NOTE** this output can differ on your system. New versions of rustc, LLVM "
"and libraries can generate different assembly. We truncated some of the "
"instructions to keep the snippet small."
msgstr ""

#: src/start/qemu.md:311
msgid "Running"
msgstr ""

#: src/start/qemu.md:313
msgid ""
"Next, let's see how to run an embedded program on QEMU! This time we'll use "
"the `hello` example which actually does something."
msgstr ""

#: src/start/qemu.md:316
msgid "For convenience here's the source code of `examples/hello.rs`:"
msgstr ""

#: src/start/qemu.md:319
msgid "//! Prints \"Hello, world!\" on the host console using semihosting\n"
msgstr ""

#: src/start/qemu.md:331
msgid "\"Hello, world!\""
msgstr ""

#: src/start/qemu.md:333
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
msgstr ""

#: src/start/qemu.md:341
msgid ""
"This program uses something called semihosting to print text to the _host_ "
"console. When using real hardware this requires a debug session but when "
"using QEMU this Just Works."
msgstr ""

#: src/start/qemu.md:345
msgid "Let's start by compiling the example:"
msgstr ""

#: src/start/qemu.md:351
msgid ""
"The output binary will be located at `target/thumbv7m-none-eabi/debug/"
"examples/hello`."
msgstr ""

#: src/start/qemu.md:354
msgid "To run this binary on QEMU run the following command:"
msgstr ""

#: src/start/qemu.md:369
msgid ""
"The command should successfully exit (exit code = 0) after printing the "
"text. On \\*nix you can check that with the following command:"
msgstr ""

#: src/start/qemu.md:380
msgid "Let's break down that QEMU command:"
msgstr ""

#: src/start/qemu.md:382
msgid ""
"`qemu-system-arm`. This is the QEMU emulator. There are a few variants of "
"these QEMU binaries; this one does full _system_ emulation of _ARM_ machines "
"hence the name."
msgstr ""

#: src/start/qemu.md:386
msgid ""
"`-cpu cortex-m3`. This tells QEMU to emulate a Cortex-M3 CPU. Specifying the "
"CPU model lets us catch some miscompilation errors: for example, running a "
"program compiled for the Cortex-M4F, which has a hardware FPU, will make "
"QEMU error during its execution."
msgstr ""

#: src/start/qemu.md:391
msgid ""
"`-machine lm3s6965evb`. This tells QEMU to emulate the LM3S6965EVB, an "
"evaluation board that contains a LM3S6965 microcontroller."
msgstr ""

#: src/start/qemu.md:394
msgid "`-nographic`. This tells QEMU to not launch its GUI."
msgstr ""

#: src/start/qemu.md:396
msgid ""
"`-semihosting-config (..)`. This tells QEMU to enable semihosting. "
"Semihosting lets the emulated device, among other things, use the host "
"stdout, stderr and stdin and create files on the host."
msgstr ""

#: src/start/qemu.md:400
msgid ""
"`-kernel $file`. This tells QEMU which binary to load and run on the "
"emulated machine."
msgstr ""

#: src/start/qemu.md:403
msgid ""
"Typing out that long QEMU command is too much work! We can set a custom "
"runner to simplify the process. `.cargo/config.toml` has a commented out "
"runner that invokes QEMU; let's uncomment it:"
msgstr ""

#: src/start/qemu.md:411
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -"
"semihosting-config enable=on,target=native -kernel\"\n"
"```"
msgstr ""

#: src/start/qemu.md:417
msgid ""
"This runner only applies to the `thumbv7m-none-eabi` target, which is our "
"default compilation target. Now `cargo run` will compile the program and run "
"it on QEMU:"
msgstr ""

#: src/start/qemu.md:425
msgid ""
"```text\n"
"   Compiling app v0.1.0 (file:///tmp/app)\n"
"    Finished release [optimized + debuginfo] target(s) in 0.26s\n"
"     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel target/thumbv7m-none-"
"eabi/release/examples/hello`\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/start/qemu.md:432
msgid "Debugging"
msgstr "除錯"

#: src/start/qemu.md:434
msgid "Debugging is critical to embedded development. Let's see how it's done."
msgstr ""

#: src/start/qemu.md:436
msgid ""
"Debugging an embedded device involves _remote_ debugging as the program that "
"we want to debug won't be running on the machine that's running the debugger "
"program (GDB or LLDB)."
msgstr ""

#: src/start/qemu.md:440
msgid ""
"Remote debugging involves a client and a server. In a QEMU setup, the client "
"will be a GDB (or LLDB) process and the server will be the QEMU process "
"that's also running the embedded program."
msgstr ""

#: src/start/qemu.md:444
msgid "In this section we'll use the `hello` example we already compiled."
msgstr ""

#: src/start/qemu.md:446
msgid "The first debugging step is to launch QEMU in debugging mode:"
msgstr ""

#: src/start/qemu.md:459
msgid ""
"This command won't print anything to the console and will block the "
"terminal. We have passed two extra flags this time:"
msgstr ""

#: src/start/qemu.md:462
msgid ""
"`-gdb tcp::3333`. This tells QEMU to wait for a GDB connection on TCP port "
"3333."
msgstr ""

#: src/start/qemu.md:465
msgid ""
"`-S`. This tells QEMU to freeze the machine at startup. Without this the "
"program would have reached the end of main before we had a chance to launch "
"the debugger!"
msgstr ""

#: src/start/qemu.md:469
msgid ""
"Next we launch GDB in another terminal and tell it to load the debug symbols "
"of the example:"
msgstr ""

#: src/start/qemu.md:476
msgid ""
"**NOTE**: you might need another version of gdb instead of `gdb-multiarch` "
"depending on which one you installed in the installation chapter. This could "
"also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""

#: src/start/qemu.md:480
msgid ""
"Then within the GDB shell we connect to QEMU, which is waiting for a "
"connection on TCP port 3333."
msgstr ""

#: src/start/qemu.md:487
msgid ""
"```text\n"
"Remote debugging using :3333\n"
"Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473\n"
"473     pub unsafe extern \"C\" fn Reset() -> ! {\n"
"```"
msgstr ""

#: src/start/qemu.md:494
msgid ""
"You'll see that the process is halted and that the program counter is "
"pointing to a function named `Reset`. That is the reset handler: what Cortex-"
"M cores execute upon booting."
msgstr ""

#: src/start/qemu.md:498
msgid ""
"Note that on some setup, instead of displaying the line `Reset () at "
"$REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473` as shown above, gdb may print "
"some warnings like :"
msgstr ""

#: src/start/qemu.md:500
msgid ""
"`core::num::bignum::Big32x40::mul_small () at src/libcore/num/bignum.rs:254` "
"`    src/libcore/num/bignum.rs: No such file or directory.`"
msgstr ""

#: src/start/qemu.md:503
msgid ""
"That's a known glitch. You can safely ignore those warnings, you're most "
"likely at Reset()."
msgstr ""

#: src/start/qemu.md:506
msgid ""
"This reset handler will eventually call our main function. Let's skip all "
"the way there using a breakpoint and the `continue` command. To set the "
"breakpoint, let's first take a look where we would like to break in our "
"code, with the `list` command."
msgstr ""

#: src/start/qemu.md:512
msgid "This will show the source code, from the file examples/hello.rs."
msgstr ""

#: src/start/qemu.md:514
msgid ""
"```text\n"
"6       use panic_halt as _;\n"
"7\n"
"8       use cortex_m_rt::entry;\n"
"9       use cortex_m_semihosting::{debug, hprintln};\n"
"10\n"
"11      #[entry]\n"
"12      fn main() -> ! {\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"14\n"
"15          // exit QEMU\n"
"```"
msgstr ""

#: src/start/qemu.md:526
msgid ""
"We would like to add a breakpoint just before the \"Hello, world!\", which "
"is on line 13. We do that with the `break` command:"
msgstr ""

#: src/start/qemu.md:531
msgid ""
"We can now instruct gdb to run up to our main function, with the `continue` "
"command:"
msgstr ""

#: src/start/qemu.md:537
msgid ""
"```text\n"
"Continuing.\n"
"\n"
"Breakpoint 1, hello::__cortex_m_rt_main () at examples\\hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""
"```text\n"
"Continuing.\n"
"\n"
"Breakpoint 1, hello::__cortex_m_rt_main () at examples\\hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"

#: src/start/qemu.md:544
msgid ""
"We are now close to the code that prints \"Hello, world!\". Let's move "
"forward using the `next` command."
msgstr ""

#: src/start/qemu.md:555
msgid ""
"At this point you should see \"Hello, world!\" printed on the terminal "
"that's running `qemu-system-arm`."
msgstr ""

#: src/start/qemu.md:563
msgid "Calling `next` again will terminate the QEMU process."
msgstr ""

#: src/start/qemu.md:573
msgid "You can now exit the GDB session."
msgstr ""
