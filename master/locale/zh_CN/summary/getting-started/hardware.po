msgid ""
msgstr ""
"Project-Id-Version: The Embedded Rust Book\n"
"POT-Creation-Date: 2025-12-02T17:24:38Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/start/hardware.md:1
msgid "Hardware"
msgstr ""

#: src/start/hardware.md:3
msgid ""
"By now you should be somewhat familiar with the tooling and the development "
"process. In this section we'll switch to real hardware; the process will "
"remain largely the same. Let's dive in."
msgstr ""

#: src/start/hardware.md:7
msgid "Know your hardware"
msgstr ""

#: src/start/hardware.md:9
msgid ""
"Before we begin you need to identify some characteristics of the target "
"device as these will be used to configure the project:"
msgstr ""

#: src/start/hardware.md:12
msgid "The ARM core. e.g. Cortex-M3."
msgstr ""

#: src/start/hardware.md:14
msgid ""
"Does the ARM core include an FPU? Cortex-M4**F** and Cortex-M7**F** cores do."
msgstr ""

#: src/start/hardware.md:16
msgid ""
"How much Flash memory and RAM does the target device have? e.g. 256 KiB of "
"Flash and 32 KiB of RAM."
msgstr ""

#: src/start/hardware.md:19
msgid ""
"Where are Flash memory and RAM mapped in the address space? e.g. RAM is "
"commonly located at address `0x2000_0000`."
msgstr ""

#: src/start/hardware.md:22
msgid ""
"You can find this information in the data sheet or the reference manual of "
"your device."
msgstr ""

#: src/start/hardware.md:25
msgid ""
"In this section we'll be using our reference hardware, the STM32F3DISCOVERY. "
"This board contains an STM32F303VCT6 microcontroller. This microcontroller "
"has:"
msgstr ""

#: src/start/hardware.md:28
msgid "A Cortex-M4F core that includes a single precision FPU"
msgstr ""

#: src/start/hardware.md:30
msgid "256 KiB of Flash located at address 0x0800_0000."
msgstr ""

#: src/start/hardware.md:32
msgid ""
"40 KiB of RAM located at address 0x2000_0000. (There's another RAM region "
"but for simplicity we'll ignore it)."
msgstr ""

#: src/start/hardware.md:35
msgid "Configuring"
msgstr ""

#: src/start/hardware.md:37
msgid ""
"We'll start from scratch with a fresh template instance. Refer to the "
"[previous section on QEMU](qemu.md) for a refresher on how to do this "
"without `cargo-generate`."
msgstr ""

#: src/start/hardware.md:43
msgid ""
"```text\n"
"$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
" Project Name: app\n"
" Creating project called `app`...\n"
" Done! New project created /tmp/app\n"
"\n"
"$ cd app\n"
"```"
msgstr ""

#: src/start/hardware.md:52
msgid ""
"Step number one is to set a default compilation target in `.cargo/config."
"toml`."
msgstr ""

#: src/start/hardware.md:58
msgid ""
"```toml\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"# target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""

#: src/start/hardware.md:66
msgid "We'll use `thumbv7em-none-eabihf` as that covers the Cortex-M4F core."
msgstr ""

#: src/start/hardware.md:67
msgid ""
"**NOTE**: As you may remember from the previous chapter, we have to install "
"all targets and this is a new one. So don't forget to run the installation "
"process `rustup target add thumbv7em-none-eabihf` for this target."
msgstr ""

#: src/start/hardware.md:71
msgid ""
"The second step is to enter the memory region information into the `memory."
"x` file."
msgstr ""

#: src/start/hardware.md:84
msgid ""
"**NOTE**: If you for some reason changed the `memory.x` file after you had "
"made the first build of a specific build target, then do `cargo clean` "
"before `cargo build`, because `cargo build` may not track updates of `memory."
"x`."
msgstr ""

#: src/start/hardware.md:88
msgid ""
"We'll start with the hello example again, but first we have to make a small "
"change."
msgstr ""

#: src/start/hardware.md:91
msgid ""
"In `examples/hello.rs`, make sure the `debug::exit()` call is commented out "
"or removed. It is used only for running in QEMU."
msgstr ""

#: src/start/hardware.md:97
msgid "\"Hello, world!\""
msgstr ""

#: src/start/hardware.md:99
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
"    // debug::exit(debug::EXIT_SUCCESS);\n"
msgstr ""

#: src/start/hardware.md:107
msgid ""
"You can now cross compile programs using `cargo build` and inspect the "
"binaries using `cargo-binutils` as you did before. The `cortex-m-rt` crate "
"handles all the magic required to get your chip running, as helpfully, "
"pretty much all Cortex-M CPUs boot in the same fashion."
msgstr ""

#: src/start/hardware.md:116
msgid "Debugging"
msgstr ""

#: src/start/hardware.md:118
msgid ""
"Debugging will look a bit different. In fact, the first steps can look "
"different depending on the target device. In this section we'll show the "
"steps required to debug a program running on the STM32F3DISCOVERY. This is "
"meant to serve as a reference; for device specific information about "
"debugging check out [the Debugonomicon](https://github.com/rust-embedded/"
"debugonomicon)."
msgstr ""

#: src/start/hardware.md:124
msgid ""
"As before we'll do remote debugging and the client will be a GDB process. "
"This time, however, the server will be OpenOCD."
msgstr ""

#: src/start/hardware.md:127
msgid ""
"As done during the [verify](../intro/install/verify.md) section connect the "
"discovery board to your laptop / PC and check that the ST-LINK header is "
"populated."
msgstr ""

#: src/start/hardware.md:132
msgid ""
"On a terminal run `openocd` to connect to the ST-LINK on the discovery "
"board. Run this command from the root of the template; `openocd` will pick "
"up the `openocd.cfg` file which indicates which interface file and target "
"file to use."
msgstr ""

#: src/start/hardware.md:155
msgid ""
"**NOTE** If you found out that you have an older revision of the discovery "
"board during the [verify](../intro/install/verify.md) section then you "
"should modify the `openocd.cfg` file at this point to use `interface/stlink-"
"v2.cfg`."
msgstr ""

#: src/start/hardware.md:159
msgid ""
"```text\n"
"$ openocd\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.913879\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"
msgstr ""

#: src/start/hardware.md:179
msgid "On another terminal run GDB, also from the root of the template."
msgstr ""

#: src/start/hardware.md:185
msgid ""
"**NOTE**: like before you might need another version of gdb instead of `gdb-"
"multiarch` depending on which one you installed in the installation chapter. "
"This could also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""

#: src/start/hardware.md:189
msgid ""
"Next connect GDB to OpenOCD, which is waiting for a TCP connection on port "
"3333."
msgstr ""

#: src/start/hardware.md:197
msgid ""
"Now proceed to _flash_ (load) the program onto the microcontroller using the "
"`load` command."
msgstr ""

#: src/start/hardware.md:209
msgid ""
"The program is now loaded. This program uses semihosting so before we do any "
"semihosting call we have to tell OpenOCD to enable semihosting. You can send "
"commands to OpenOCD using the `monitor` command."
msgstr ""

#: src/start/hardware.md:218
msgid ""
"You can see all the OpenOCD commands by invoking the `monitor help` command."
msgstr ""

#: src/start/hardware.md:220
msgid ""
"Like before we can skip all the way to `main` using a breakpoint and the "
"`continue` command."
msgstr ""

#: src/start/hardware.md:235
msgid ""
"**NOTE** If GDB blocks the terminal instead of hitting the breakpoint after "
"you issue the `continue` command above, you might want to double check that "
"the memory region information in the `memory.x` file is correctly set up for "
"your device (both the starts _and_ lengths)."
msgstr ""

#: src/start/hardware.md:240
msgid "Step into the main function with `step`."
msgstr ""

#: src/start/hardware.md:242
msgid ""
"```console\n"
"(gdb) step\n"
"halted: PC: 0x08000496\n"
"hello::__cortex_m_rt_main () at examples/hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""

#: src/start/hardware.md:249
msgid ""
"After advancing the program with `next` you should see \"Hello, world!\" "
"printed on the OpenOCD console, among other stuff."
msgstr ""

#: src/start/hardware.md:264
msgid ""
"The message is only displayed once as the program is about to enter the "
"infinite loop defined in line 19: `loop {}`"
msgstr ""

#: src/start/hardware.md:266
msgid "You can now exit GDB using the `quit` command."
msgstr ""

#: src/start/hardware.md:277
msgid ""
"Debugging now requires a few more steps so we have packed all those steps "
"into a single GDB script named `openocd.gdb`. The file was created during "
"the `cargo generate` step, and should work without any modifications. Let's "
"have a peek:"
msgstr ""

#: src/start/hardware.md:303
msgid ""
"Now running `<gdb> -x openocd.gdb target/thumbv7em-none-eabihf/debug/"
"examples/hello` will immediately connect GDB to OpenOCD, enable semihosting, "
"load the program and start the process."
msgstr ""

#: src/start/hardware.md:306
msgid ""
"Alternatively, you can turn `<gdb> -x openocd.gdb` into a custom runner to "
"make `cargo run` build a program _and_ start a GDB session. This runner is "
"included in `.cargo/config.toml` but it's commented out."
msgstr ""

#: src/start/hardware.md:314
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"# runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -"
"semihosting-config enable=on,target=native -kernel\"\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"# uncomment ONE of these three option to make `cargo run` start a GDB "
"session\n"
"# which option to pick depends on your system\n"
"runner = \"arm-none-eabi-gdb -x openocd.gdb\"\n"
"# runner = \"gdb-multiarch -x openocd.gdb\"\n"
"# runner = \"gdb -x openocd.gdb\"\n"
"```"
msgstr ""
