msgid ""
msgstr ""
"Project-Id-Version: The Embedded Rust Book\n"
"POT-Creation-Date: 2025-12-02T17:24:39Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/appendix/glossary.md:1
msgid "Appendix A: Glossary"
msgstr "附錄 A：詞彙表"

#: src/appendix/glossary.md:3
msgid ""
"The embedded ecosystem is full of different protocols, hardware components "
"and vendor-specific things that use their own terms and abbreviations. This "
"Glossary attempts to list them with pointers for understanding them better."
msgstr ""
"嵌入式生態系充滿各種協定、硬體元件與廠商特有的事物，且都有各自的術語與縮寫。"
"本詞彙表嘗試列出它們，並提供理解它們的指引。"

#: src/appendix/glossary.md:7
msgid "BSP"
msgstr ""

#: src/appendix/glossary.md:9
msgid ""
"A Board Support Crate provides a high level interface configured for a "
"specific board. It usually depends on a [HAL](#hal) crate. There is a more "
"detailed description on the [memory-mapped registers page](../start/"
"registers.md) or for a broader overview see [this video](https://youtu.be/"
"vLYit_HHPaY)."
msgstr ""
"板級支援套件（Board Support Crate）提供為特定開發板設定好的高階介面。它通常依"
"賴 [HAL](#hal) 套件。更詳細的說明可參考[記憶體對映暫存器頁面](../start/"
"registers.md)，或觀看更廣泛概覽的[這段影片](https://youtu.be/vLYit_HHPaY)。"

#: src/appendix/glossary.md:14
msgid "FPU"
msgstr ""

#: src/appendix/glossary.md:16
msgid ""
"Floating-point Unit. A 'math processor' running only operations on floating-"
"point numbers."
msgstr "浮點運算單元。僅執行浮點數運算的「數學處理器」。"

#: src/appendix/glossary.md:18
msgid "HAL"
msgstr ""

#: src/appendix/glossary.md:20
msgid ""
"A Hardware Abstraction Layer crate provides a developer friendly interface "
"to a microcontroller's features and peripherals. It is usually implemented "
"on top of a [Peripheral Access Crate (PAC)](#pac). It may also implement "
"traits from the [`embedded-hal`](https://crates.io/crates/embedded-hal) "
"crate. There is a more detailed description on the [memory-mapped registers "
"page](../start/registers.md) or for a broader overview see [this video]"
"(https://youtu.be/vLYit_HHPaY)."
msgstr ""
"硬體抽象層（Hardware Abstraction Layer）套件提供對微控制器功能與周邊的開發者"
"友善介面。它通常建立在[周邊存取套件（PAC）](#pac)之上，也可能實作[`embedded-"
"hal`](https://crates.io/crates/embedded-hal) 套件中的 traits。更詳細的說明可"
"參考[記憶體對映暫存器頁面](../start/registers.md)，或觀看更廣泛概覽的[這段影"
"片](https://youtu.be/vLYit_HHPaY)。"

#: src/appendix/glossary.md:26
msgid "I2C"
msgstr ""

#: src/appendix/glossary.md:28
msgid ""
"Sometimes referred to as `I²C` or Inter-IC. It is a protocol meant for "
"hardware communication within a single integrated circuit. See [here]"
"(https://en.wikipedia.org/wiki/I2c) for more details"
msgstr ""
"有時稱為 `I²C` 或 Inter-IC。這是一種用於單一積體電路內硬體通訊的協定。詳見[這"
"裡](https://en.wikipedia.org/wiki/I2c)。"

#: src/appendix/glossary.md:33
msgid "PAC"
msgstr ""

#: src/appendix/glossary.md:35
msgid ""
"A Peripheral Access Crate provides access to a microcontroller's "
"peripherals. It is one of the lower level crates and is usually generated "
"directly from the provided [SVD](#svd), often using [svd2rust](https://"
"github.com/rust-embedded/svd2rust/). The [Hardware Abstraction Layer](#hal) "
"would usually depend on this crate. There is a more detailed description on "
"the [memory-mapped registers page](../start/registers.md) or for a broader "
"overview see [this video](https://youtu.be/vLYit_HHPaY)."
msgstr ""
"周邊存取套件（Peripheral Access Crate）提供對微控制器周邊的存取。它是較底層的"
"套件之一，通常直接由提供的 [SVD](#svd) 產生，常用工具為 [svd2rust](https://"
"github.com/rust-embedded/svd2rust/)。[硬體抽象層](#hal)通常會依賴此套件。更詳"
"細的說明可參考[記憶體對映暫存器頁面](../start/registers.md)，或觀看更廣泛概覽"
"的[這段影片](https://youtu.be/vLYit_HHPaY)。"

#: src/appendix/glossary.md:42
msgid "SPI"
msgstr ""

#: src/appendix/glossary.md:44
msgid ""
"Serial Peripheral Interface. See [here](https://en.wikipedia.org/wiki/"
"Serial_peripheral_interface) for more information."
msgstr ""
"序列周邊介面。詳見[這裡](https://en.wikipedia.org/wiki/"
"Serial_peripheral_interface)。"

#: src/appendix/glossary.md:48
msgid "SVD"
msgstr ""

#: src/appendix/glossary.md:50
msgid ""
"System View Description is an XML file format used to describe the "
"programmers view of a microcontroller device. You can read more about it on "
"[the ARM CMSIS documentation site](https://www.keil.com/pack/doc/CMSIS/SVD/"
"html/index.html)."
msgstr ""
"System View Description 是一種 XML 檔案格式，用於描述程式設計者對微控制器裝置"
"的視角。詳見 [ARM CMSIS 文件網站](https://www.keil.com/pack/doc/CMSIS/SVD/"
"html/index.html)。"

#: src/appendix/glossary.md:54
msgid "UART"
msgstr ""

#: src/appendix/glossary.md:56
msgid ""
"Universal asynchronous receiver-transmitter. See [here](https://en.wikipedia."
"org/wiki/Universal_asynchronous_receiver-transmitter) for more information."
msgstr ""
"通用非同步收發器。詳見[這裡](https://en.wikipedia.org/wiki/"
"Universal_asynchronous_receiver-transmitter)。"

#: src/appendix/glossary.md:60
msgid "USART"
msgstr ""

#: src/appendix/glossary.md:62
msgid ""
"Universal synchronous and asynchronous receiver-transmitter. See [here]"
"(https://en.wikipedia.org/wiki/"
"Universal_synchronous_and_asynchronous_receiver-transmitter) for more "
"information."
msgstr ""
"通用同步與非同步收發器。詳見[這裡](https://en.wikipedia.org/wiki/"
"Universal_synchronous_and_asynchronous_receiver-transmitter)。"

#: src/collections/index.md:1
msgid "Collections"
msgstr "集合"

#: src/collections/index.md:3
msgid ""
"Eventually you'll want to use dynamic data structures (AKA collections) in "
"your program. `std` provides a set of common collections: [`Vec`](https://"
"doc.rust-lang.org/std/vec/struct.Vec.html), [`String`](https://doc.rust-lang."
"org/std/string/struct.String.html), [`HashMap`](https://doc.rust-lang.org/"
"std/collections/struct.HashMap.html), etc. All the collections implemented "
"in `std` use a global dynamic memory allocator (AKA the heap)."
msgstr ""
"最終你會想在程式中使用動態資料結構（亦即集合）。`std` 提供一組常見集合："
"[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html)、[`String`]"
"(https://doc.rust-lang.org/std/string/struct.String.html)、[`HashMap`]"
"(https://doc.rust-lang.org/std/collections/struct.HashMap.html) 等。`std` 中"
"實作的所有集合都使用全域動態記憶體配置器（亦即堆積）。"

#: src/collections/index.md:12
msgid ""
"As `core` is, by definition, free of memory allocations these "
"implementations are not available there, but they can be found in the "
"`alloc` crate that's shipped with the compiler."
msgstr ""
"由於 `core` 定義上不含記憶體配置，因此這些實作在那裡不可用，但可在隨編譯器提"
"供的 `alloc` 套件中找到。"

#: src/collections/index.md:16
msgid ""
"If you need collections, a heap allocated implementation is not your only "
"option. You can also use _fixed capacity_ collections; one such "
"implementation can be found in the [`heapless`](https://crates.io/crates/"
"heapless) crate."
msgstr ""
"如果你需要集合，堆積配置的實作並非唯一選擇。你也可以使用_固定容量_集合；其中"
"一種實作可見於 [`heapless`](https://crates.io/crates/heapless) 套件。"

#: src/collections/index.md:22
msgid "In this section, we'll explore and compare these two implementations."
msgstr "在本節中，我們會探索並比較這兩種實作。"

#: src/collections/index.md:24
msgid "Using `alloc`"
msgstr "使用 `alloc`"

#: src/collections/index.md:26
msgid ""
"The `alloc` crate is shipped with the standard Rust distribution. To import "
"the crate you can directly `use` it _without_ declaring it as a dependency "
"in your `Cargo.toml` file."
msgstr ""
"`alloc` 套件隨標準 Rust 發行版一同提供。要匯入此套件，你可以直接 `use` 它，_"
"不需要_ 在 `Cargo.toml` 中宣告相依。"

#: src/collections/index.md:38
msgid ""
"To be able to use any collection you'll first need use the "
"`global_allocator` attribute to declare the global allocator your program "
"will use. It's required that the allocator you select implements the "
"[`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) "
"trait."
msgstr ""
"要能使用任何集合，你首先需要用 `global_allocator` 屬性宣告程式所使用的全域配"
"置器。你選擇的配置器必須實作 [`GlobalAlloc`](https://doc.rust-lang.org/core/"
"alloc/trait.GlobalAlloc.html) trait。"

#: src/collections/index.md:44
msgid ""
"For completeness and to keep this section as self-contained as possible "
"we'll implement a simple bump pointer allocator and use that as the global "
"allocator. However, we _strongly_ suggest you use a battle tested allocator "
"from crates.io in your program instead of this allocator."
msgstr ""
"為了完整性並盡量讓本節自足，我們會實作一個簡單的指標遞增（bump pointer）配置"
"器並將其作為全域配置器。然而，我們_強烈_建議你在程式中使用 crates.io 上久經考"
"驗的配置器，而不是此配置器。"

#: src/collections/index.md:50
msgid "// Bump pointer allocator implementation\n"
msgstr "// 指標遞增配置器實作\n"

#: src/collections/index.md:57
msgid "// Bump pointer allocator for *single* core systems\n"
msgstr "// 適用於*單核心*系統的指標遞增配置器\n"

#: src/collections/index.md:68
msgid ""
"// `interrupt::free` is a critical section that makes our allocator safe\n"
"        // to use from within interrupts\n"
msgstr ""
"// `interrupt::free` 是臨界區，讓我們的配置器可安全\n"
"        // 在中斷內使用\n"

#: src/collections/index.md:76
msgid "// move start up to the next alignment boundary\n"
msgstr "// 將起點移到下一個對齊邊界\n"

#: src/collections/index.md:80
msgid "// a null pointer signal an Out Of Memory condition\n"
msgstr "// 空指標代表記憶體不足（OOM）\n"

#: src/collections/index.md:90
msgid "// this allocator never deallocates memory\n"
msgstr "// 此配置器從不釋放記憶體\n"

#: src/collections/index.md:93
msgid ""
"// Declaration of the global memory allocator\n"
"// NOTE the user must ensure that the memory region `[0x2000_0100, "
"0x2000_0200]`\n"
"// is not used by other parts of the program\n"
msgstr ""
"// 全域記憶體配置器的宣告\n"
"// 注意：使用者必須確保記憶體區域 `[0x2000_0100, 0x2000_0200]`\n"
"// 未被程式的其他部分使用\n"

#: src/collections/index.md:104
msgid ""
"Apart from selecting a global allocator the user will also have to define "
"how Out Of Memory (OOM) errors are handled using the _unstable_ "
"`alloc_error_handler` attribute."
msgstr ""
"除了選擇全域配置器之外，使用者還必須使用_不穩定_的 `alloc_error_handler` 屬性"
"來定義如何處理記憶體不足（OOM）錯誤。"

#: src/collections/index.md:121
msgid ""
"Once all that is in place, the user can finally use the collections in "
"`alloc`."
msgstr "當上述一切就緒後，使用者終於可以使用 `alloc` 中的集合。"

#: src/collections/index.md:132
msgid "// ..\n"
msgstr ""

#: src/collections/index.md:137
msgid ""
"If you have used the collections in the `std` crate then these will be "
"familiar as they are exact same implementation."
msgstr "如果你用過 `std` 套件的集合，這些會很熟悉，因為實作完全相同。"

#: src/collections/index.md:140
msgid "Using `heapless`"
msgstr "使用 `heapless`"

#: src/collections/index.md:142
msgid ""
"`heapless` requires no setup as its collections don't depend on a global "
"memory allocator. Just `use` its collections and proceed to instantiate them:"
msgstr ""
"`heapless` 不需要任何設定，因為其集合不依賴全域記憶體配置器。只要 `use` 其集"
"合並直接建立實例即可："

#: src/collections/index.md:146
msgid "// heapless version: v0.4.x\n"
msgstr "// heapless 版本：v0.4.x\n"

#: src/collections/index.md:160
msgid ""
"You'll note two differences between these collections and the ones in "
"`alloc`."
msgstr "你會注意到這些集合與 `alloc` 中的集合有兩個差異。"

#: src/collections/index.md:162
msgid ""
"First, you have to declare upfront the capacity of the collection. "
"`heapless` collections never reallocate and have fixed capacities; this "
"capacity is part of the type signature of the collection. In this case we "
"have declared that `xs` has a capacity of 8 elements that is the vector can, "
"at most, hold 8 elements. This is indicated by the `U8` (see [`typenum`]"
"(https://crates.io/crates/typenum)) in the type signature."
msgstr ""
"第一，你必須事先宣告集合容量。`heapless` 集合不會重新配置，且容量固定；容量是"
"集合型別簽名的一部分。在此例中，我們宣告 `xs` 容量為 8 個元素，也就是這個向量"
"最多只能容納 8 個元素。這會在型別簽名中以 `U8` 表示（見[`typenum`](https://"
"crates.io/crates/typenum)）。"

#: src/collections/index.md:170
msgid ""
"Second, the `push` method, and many other methods, return a `Result`. Since "
"the `heapless` collections have fixed capacity all operations that insert "
"elements into the collection can potentially fail. The API reflects this "
"problem by returning a `Result` indicating whether the operation succeeded "
"or not. In contrast, `alloc` collections will reallocate themselves on the "
"heap to increase their capacity."
msgstr ""
"第二，`push` 與許多其他方法會回傳 `Result`。由於 `heapless` 集合容量固定，所"
"有插入元素的操作都有可能失敗。API 透過回傳 `Result` 來反映此問題，以表示操作"
"是否成功。相較之下，`alloc` 集合會在堆積上重新配置以擴增容量。"

#: src/collections/index.md:177
msgid ""
"As of version v0.4.x all `heapless` collections store all their elements "
"inline. This means that an operation like `let x = heapless::Vec::new();` "
"will allocate the collection on the stack, but it's also possible to "
"allocate the collection on a `static` variable, or even on the heap "
"(`Box<Vec<_, _>>`)."
msgstr ""
"截至 v0.4.x 版本，所有 `heapless` 集合都將元素內嵌存放。這意味著像 `let x = "
"heapless::Vec::new();` 這樣的操作會在堆疊上配置集合，但也可以將集合配置在 "
"`static` 變數上，甚至放在堆積上（`Box<Vec<_, _>>`）。"

#: src/collections/index.md:182
msgid "Trade-offs"
msgstr "取捨"

#: src/collections/index.md:184
msgid ""
"Keep these in mind when choosing between heap allocated, relocatable "
"collections and fixed capacity collections."
msgstr "在選擇可在堆積配置、可搬移的集合與固定容量集合時，請記住以下重點。"

#: src/collections/index.md:187
msgid "Out Of Memory and error handling"
msgstr "記憶體不足與錯誤處理"

#: src/collections/index.md:189
msgid ""
"With heap allocations Out Of Memory is always a possibility and can occur in "
"any place where a collection may need to grow: for example, all `alloc::Vec."
"push` invocations can potentially generate an OOM condition. Thus some "
"operations can _implicitly_ fail. Some `alloc` collections expose "
"`try_reserve` methods that let you check for potential OOM conditions when "
"growing the collection but you need be proactive about using them."
msgstr ""
"使用堆積配置時，記憶體不足總是有可能發生，且可能出現在集合需要成長的任何地"
"方：例如所有 `alloc::Vec.push` 都可能引發 OOM。因此某些操作可能會_隱含_失敗。"
"有些 `alloc` 集合提供 `try_reserve` 方法，讓你在擴充集合時檢查可能的 OOM 狀"
"況，但你必須主動使用它們。"

#: src/collections/index.md:196
msgid ""
"If you exclusively use `heapless` collections and you don't use a memory "
"allocator for anything else then an OOM condition is impossible. Instead, "
"you'll have to deal with collections running out of capacity on a case by "
"case basis. That is you'll have deal with _all_ the `Result`s returned by "
"methods like `Vec.push`."
msgstr ""
"若你只使用 `heapless` 集合，且不把記憶體配置器用於其他用途，那麼 OOM 就不可能"
"發生。取而代之，你必須逐案處理集合容量耗盡的情況。也就是說，你必須處理像 "
"`Vec.push` 這類方法回傳的_所有_ `Result`。"

#: src/collections/index.md:202
msgid ""
"OOM failures can be harder to debug than say `unwrap`\\-ing on all `Result`s "
"returned by `heapless::Vec.push` because the observed location of failure "
"may _not_ match with the location of the cause of the problem. For example, "
"even `vec.reserve(1)` can trigger an OOM if the allocator is nearly "
"exhausted because some other collection was leaking memory (memory leaks are "
"possible in safe Rust)."
msgstr ""
"OOM 失敗可能比在 `heapless::Vec.push` 回傳的所有 `Result` 上做 `unwrap` 更難"
"除錯，因為觀察到的失敗位置可能_不_等於問題原因的位置。例如，如果配置器幾乎耗"
"盡，即使 `vec.reserve(1)` 也可能觸發 OOM，原因可能是其他集合在洩漏記憶體（安"
"全 Rust 也可能發生記憶體洩漏）。"

#: src/collections/index.md:209
msgid "Memory usage"
msgstr "記憶體使用"

#: src/collections/index.md:211
msgid ""
"Reasoning about memory usage of heap allocated collections is hard because "
"the capacity of long lived collections can change at runtime. Some "
"operations may implicitly reallocate the collection increasing its memory "
"usage, and some collections expose methods like `shrink_to_fit` that can "
"potentially reduce the memory used by the collection -- ultimately, it's up "
"to the allocator to decide whether to actually shrink the memory allocation "
"or not. Additionally, the allocator may have to deal with memory "
"fragmentation which can increase the _apparent_ memory usage."
msgstr ""
"推論堆積配置集合的記憶體用量很困難，因為長生命週期集合的容量可在執行期變動。"
"有些操作可能會隱含地重新配置集合並增加記憶體用量，有些集合提供像 "
"`shrink_to_fit` 的方法，可能降低集合的記憶體使用量——最終是否實際縮減配置仍取"
"決於配置器。此外，配置器可能還需處理記憶體碎片化，這會增加_表觀_記憶體用量。"

#: src/collections/index.md:220
msgid ""
"On the other hand if you exclusively use fixed capacity collections, store "
"most of them in `static` variables and set a maximum size for the call stack "
"then the linker will detect if you try to use more memory than what's "
"physically available."
msgstr ""
"另一方面，若你只使用固定容量集合、將大多數放在 `static` 變數中，並為呼叫堆疊"
"設定最大大小，那麼連結器會在你嘗試使用超過實體可用記憶體時偵測到。"

#: src/collections/index.md:225
msgid ""
"Furthermore, fixed capacity collections allocated on the stack will be "
"reported by [`-Z emit-stack-sizes`](https://doc.rust-lang.org/beta/unstable-"
"book/compiler-flags/emit-stack-sizes.html) flag which means that tools that "
"analyze stack usage (like [`stack-sizes`](https://crates.io/crates/stack-"
"sizes)) will include them in their analysis."
msgstr ""
"此外，堆疊上配置的固定容量集合會被 [`-Z emit-stack-sizes`](https://doc.rust-"
"lang.org/beta/unstable-book/compiler-flags/emit-stack-sizes.html) 旗標回報，"
"這表示分析堆疊使用量的工具（如 [`stack-sizes`](https://crates.io/crates/"
"stack-sizes)）會將它們納入分析。"

#: src/collections/index.md:232
msgid ""
"However, fixed capacity collections can _not_ be shrunk which can result in "
"lower load factors (the ratio between the size of the collection and its "
"capacity) than what relocatable collections can achieve."
msgstr ""
"然而，固定容量集合_無法_縮小，這可能導致裝載率（集合大小與容量的比例）低於可"
"搬移集合所能達到的程度。"

#: src/collections/index.md:236
msgid "Worst Case Execution Time (WCET)"
msgstr "最壞執行時間（WCET）"

#: src/collections/index.md:238
msgid ""
"If you are building time sensitive applications or hard real time "
"applications then you care, maybe a lot, about the worst case execution time "
"of the different parts of your program."
msgstr ""
"如果你在打造時間敏感或硬即時的應用程式，那麼你會非常在意程式各部分的最壞執行"
"時間。"

#: src/collections/index.md:242
msgid ""
"The `alloc` collections can reallocate so the WCET of operations that may "
"grow the collection will also include the time it takes to reallocate the "
"collection, which itself depends on the _runtime_ capacity of the "
"collection. This makes it hard to determine the WCET of, for example, the "
"`alloc::Vec.push` operation as it depends on both the allocator being used "
"and its runtime capacity."
msgstr ""
"`alloc` 集合可以重新配置，因此可能增長集合的操作，其 WCET 也包含重新配置所需"
"的時間，而這又取決於集合的_執行期_容量。這使得像 `alloc::Vec.push` 這樣的操作"
"難以確定 WCET，因為它取決於使用的配置器與執行期容量。"

#: src/collections/index.md:248
msgid ""
"On the other hand fixed capacity collections never reallocate so all "
"operations have a predictable execution time. For example, `heapless::Vec."
"push` executes in constant time."
msgstr ""
"另一方面，固定容量集合從不重新配置，因此所有操作都有可預測的執行時間。例如，"
"`heapless::Vec.push` 以常數時間執行。"

#: src/collections/index.md:252
msgid "Ease of use"
msgstr "易用性"

#: src/collections/index.md:254
msgid ""
"`alloc` requires setting up a global allocator whereas `heapless` does not. "
"However, `heapless` requires you to pick the capacity of each collection "
"that you instantiate."
msgstr ""
"`alloc` 需要設定全域配置器，而 `heapless` 不需要。然而，`heapless` 需要你為每"
"個實例化的集合選擇容量。"

#: src/collections/index.md:258
msgid ""
"The `alloc` API will be familiar to virtually every Rust developer. The "
"`heapless` API tries to closely mimic the `alloc` API but it will never be "
"exactly the same due to its explicit error handling -- some developers may "
"feel the explicit error handling is excessive or too cumbersome."
msgstr ""
"`alloc` 的 API 幾乎對每位 Rust 開發者都很熟悉。`heapless` 的 API 嘗試緊密模"
"仿 `alloc` API，但因為明確的錯誤處理，它永遠不可能完全相同——有些開發者可能覺"
"得明確的錯誤處理過於冗長或太繁瑣。"

#: src/concurrency/index.md:1
msgid "Concurrency"
msgstr "並行"

#: src/concurrency/index.md:3
msgid ""
"Concurrency happens whenever different parts of your program might execute "
"at different times or out of order. In an embedded context, this includes:"
msgstr ""
"並行會在程式的不同部分可能於不同時間或不同順序執行時發生。在嵌入式情境中，這"
"包括："

#: src/concurrency/index.md:6
msgid ""
"interrupt handlers, which run whenever the associated interrupt happens,"
msgstr "中斷處理器：在相關中斷發生時執行，"

#: src/concurrency/index.md:7
msgid ""
"various forms of multithreading, where your microprocessor regularly swaps "
"between parts of your program,"
msgstr "各種形式的多執行緒：微處理器會定期在程式的不同部分之間切換，"

#: src/concurrency/index.md:9
msgid ""
"and in some systems, multiple-core microprocessors, where each core can be "
"independently running a different part of your program at the same time."
msgstr ""
"以及在某些系統中，多核心微處理器：每個核心都能在同一時間獨立執行程式的不同部"
"分。"

#: src/concurrency/index.md:12
msgid ""
"Since many embedded programs need to deal with interrupts, concurrency will "
"usually come up sooner or later, and it's also where many subtle and "
"difficult bugs can occur. Luckily, Rust provides a number of abstractions "
"and safety guarantees to help us write correct code."
msgstr ""
"由於許多嵌入式程式需要處理中斷，並行遲早會出現，也正是許多細微且難解的錯誤出"
"現之處。幸運的是，Rust 提供多種抽象與安全保證，協助我們寫出正確的程式碼。"

#: src/concurrency/index.md:17
msgid "No Concurrency"
msgstr "無並行"

#: src/concurrency/index.md:19
msgid ""
"The simplest concurrency for an embedded program is no concurrency: your "
"software consists of a single main loop which just keeps running, and there "
"are no interrupts at all. Sometimes this is perfectly suited to the problem "
"at hand! Typically your loop will read some inputs, perform some processing, "
"and write some outputs."
msgstr ""
"嵌入式程式最簡單的並行就是沒有並行：軟體由單一主迴圈構成，持續運行，且完全沒"
"有中斷。有時這非常適合手邊的問題！通常你的迴圈會讀取一些輸入、做一些處理，再"
"輸出一些結果。"

#: src/concurrency/index.md:37
msgid ""
"Since there's no concurrency, there's no need to worry about sharing data "
"between parts of your program or synchronising access to peripherals. If you "
"can get away with such a simple approach this can be a great solution."
msgstr ""
"由於沒有並行，就不需要擔心程式各部分之間的資料共享或周邊存取同步。如果你可以"
"採用這麼簡單的方法，這會是很棒的解決方案。"

#: src/concurrency/index.md:41
msgid "Global Mutable Data"
msgstr "全域可變資料"

#: src/concurrency/index.md:43
msgid ""
"Unlike non-embedded Rust, we will not usually have the luxury of creating "
"heap allocations and passing references to that data into a newly-created "
"thread. Instead, our interrupt handlers might be called at any time and must "
"know how to access whatever shared memory we are using. At the lowest level, "
"this means we must have _statically allocated_ mutable memory, which both "
"the interrupt handler and the main code can refer to."
msgstr ""
"與非嵌入式 Rust 不同，我們通常無法奢望建立堆積配置並把對該資料的參考傳給新建"
"執行緒。相反地，我們的中斷處理器可能在任何時候被呼叫，必須知道如何存取我們正"
"在使用的共享記憶體。在最低層，這代表我們必須擁有_靜態配置_的可變記憶體，讓中"
"斷處理器與主程式碼都能參考。"

#: src/concurrency/index.md:50
msgid ""
"In Rust, such [`static mut`](https://doc.rust-lang.org/book/ch19-01-unsafe-"
"rust.html#accessing-or-modifying-a-mutable-static-variable) variables are "
"always unsafe to read or write, because without taking special care, you "
"might trigger a race condition, where your access to the variable is "
"interrupted halfway through by an interrupt which also accesses that "
"variable."
msgstr ""
"在 Rust 中，這類 [`static mut`](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable) 變數的讀寫"
"永遠是不安全的，因為若不特別小心，你可能觸發資料競爭：對變數的存取途中被同樣"
"會存取該變數的中斷打斷。"

#: src/concurrency/index.md:57
msgid ""
"For an example of how this behaviour can cause subtle errors in your code, "
"consider an embedded program which counts rising edges of some input signal "
"in each one-second period (a frequency counter):"
msgstr ""
"為了示範此行為如何造成程式中的細微錯誤，想像一個嵌入式程式會在每一秒內計算某"
"個輸入訊號的上升沿（頻率計數器）："

#: src/concurrency/index.md:71
msgid "// DANGER - Not actually safe! Could cause data races.\n"
msgstr "// 危險 - 並不安全！可能造成資料競爭。\n"

#: src/concurrency/index.md:84
msgid ""
"Each second, the timer interrupt sets the counter back to 0. Meanwhile, the "
"main loop continually measures the signal, and incremements the counter when "
"it sees a change from low to high. We've had to use `unsafe` to access "
"`COUNTER`, as it's `static mut`, and that means we're promising the compiler "
"we won't cause any undefined behaviour. Can you spot the race condition? The "
"increment on `COUNTER` is _not_ guaranteed to be atomic — in fact, on most "
"embedded platforms, it will be split into a load, then the increment, then a "
"store. If the interrupt fired after the load but before the store, the reset "
"back to 0 would be ignored after the interrupt returns — and we would count "
"twice as many transitions for that period."
msgstr ""
"每一秒，計時器中斷會把計數器設回 0。同時，主迴圈會持續量測訊號，並在看到低轉"
"高時遞增計數器。我們必須用 `unsafe` 存取 `COUNTER`，因為它是 `static mut`，這"
"代表我們向編譯器保證不會造成未定義行為。你能找出資料競爭嗎？`COUNTER` 的遞增_"
"不_保證是原子操作——事實上，在多數嵌入式平台上，它會被拆成載入、遞增、儲存三步"
"驟。如果中斷在載入之後、儲存之前觸發，回到中斷後會忽略重設為 0 的結果——因此該"
"期間的轉換次數會被計兩次。"

#: src/concurrency/index.md:95
msgid "Critical Sections"
msgstr "臨界區"

#: src/concurrency/index.md:97
msgid ""
"So, what can we do about data races? A simple approach is to use _critical "
"sections_, a context where interrupts are disabled. By wrapping the access "
"to `COUNTER` in `main` in a critical section, we can be sure the timer "
"interrupt will not fire until we're finished incrementing `COUNTER`:"
msgstr ""
"那麼，我們能如何處理資料競爭？一個簡單的作法是使用_臨界區_，也就是停用中斷的"
"情境。把 `main` 中對 `COUNTER` 的存取包在臨界區內，我們就能確定在完成遞增"
"`COUNTER` 之前計時器中斷不會觸發："

#: src/concurrency/index.md:112
msgid "// New critical section ensures synchronised access to COUNTER\n"
msgstr "// 新的臨界區確保對 COUNTER 的同步存取\n"

#: src/concurrency/index.md:127
msgid ""
"In this example, we use `cortex_m::interrupt::free`, but other platforms "
"will have similar mechanisms for executing code in a critical section. This "
"is also the same as disabling interrupts, running some code, and then re-"
"enabling interrupts."
msgstr ""
"在此例中，我們使用 `cortex_m::interrupt::free`，但其他平台也會有類似機制可在"
"臨界區中執行程式碼。這等同於停用中斷、執行某段程式碼，然後再重新啟用中斷。"

#: src/concurrency/index.md:132
msgid ""
"Note we didn't need to put a critical section inside the timer interrupt, "
"for two reasons:"
msgstr "注意，我們不需要在計時器中斷內加入臨界區，原因有二："

#: src/concurrency/index.md:135
msgid ""
"Writing 0 to `COUNTER` can't be affected by a race since we don't read it"
msgstr "將 0 寫入 `COUNTER` 不會受競爭影響，因為我們沒有讀取它"

#: src/concurrency/index.md:136
msgid "It will never be interrupted by the `main` thread anyway"
msgstr "反正也不會被 `main` 執行緒打斷"

#: src/concurrency/index.md:138
msgid ""
"If `COUNTER` was being shared by multiple interrupt handlers that might "
"_preempt_ each other, then each one might require a critical section as well."
msgstr ""
"若 `COUNTER` 由多個可能互相_搶占_的中斷處理器共享，則每一個也可能都需要臨界"
"區。"

#: src/concurrency/index.md:141
msgid ""
"This solves our immediate problem, but we're still left writing a lot of "
"unsafe code which we need to carefully reason about, and we might be using "
"critical sections needlessly. Since each critical section temporarily pauses "
"interrupt processing, there is an associated cost of some extra code size "
"and higher interrupt latency and jitter (interrupts may take longer to be "
"processed, and the time until they are processed will be more variable). "
"Whether this is a problem depends on your system, but in general, we'd like "
"to avoid it."
msgstr ""
"這解決了當下問題，但我們仍需撰寫大量 `unsafe` 程式碼並小心推理，而且可能會不"
"必要地使用臨界區。由於每個臨界區會暫停中斷處理，因此會帶來額外的程式碼大小成"
"本，以及更高的中斷延遲與抖動（中斷可能需要更久才被處理，且等待時間更不穩"
"定）。這是否是問題取決於你的系統，但一般而言我們希望避免它。"

#: src/concurrency/index.md:143
msgid ""
"It's worth noting that while a critical section guarantees no interrupts "
"will fire, it does not provide an exclusivity guarantee on multi-core "
"systems!  The other core could be happily accessing the same memory as your "
"core, even without interrupts. You will need stronger synchronisation "
"primitives if you are using multiple cores."
msgstr ""
"值得注意的是，臨界區雖然保證不會有中斷觸發，但在多核心系統上並不提供互斥保"
"證！即使沒有中斷，其他核心也可能同時存取相同記憶體。如果你使用多核心，就需要"
"更強的同步原語。"

#: src/concurrency/index.md:149
msgid "Atomic Access"
msgstr "原子存取"

#: src/concurrency/index.md:151
msgid ""
"On some platforms, special atomic instructions are available, which provide "
"guarantees about read-modify-write operations. Specifically for Cortex-M: "
"`thumbv6` (Cortex-M0, Cortex-M0+) only provide atomic load and store "
"instructions, while `thumbv7` (Cortex-M3 and above) provide full Compare and "
"Swap (CAS) instructions. These CAS instructions give an alternative to the "
"heavy-handed disabling of all interrupts: we can attempt the increment, it "
"will succeed most of the time, but if it was interrupted it will "
"automatically retry the entire increment operation. These atomic operations "
"are safe even across multiple cores."
msgstr ""
"在某些平台上，有特殊的原子指令，可為讀-改-寫操作提供保證。以 Cortex-M 為例："
"`thumbv6`（Cortex-M0、Cortex-M0+）僅提供原子載入與儲存指令，而 `thumbv7`"
"（Cortex-M3 及以上）提供完整的 Compare and Swap（CAS）指令。這些 CAS 指令可作"
"為粗暴停用所有中斷的替代方案：我們可嘗試遞增，大多時候會成功；若被中斷，它會"
"自動重試整個遞增操作。這些原子操作即使跨多核心也安全。"

#: src/concurrency/index.md:173
msgid "// Use `fetch_add` to atomically add 1 to COUNTER\n"
msgstr "// 使用 `fetch_add` 以原子方式將 COUNTER 加 1\n"

#: src/concurrency/index.md:182
msgid "// Use `store` to write 0 directly to COUNTER\n"
msgstr "// 使用 `store` 直接將 0 寫入 COUNTER\n"

#: src/concurrency/index.md:187
msgid ""
"This time `COUNTER` is a safe `static` variable. Thanks to the `AtomicUsize` "
"type `COUNTER` can be safely modified from both the interrupt handler and "
"the main thread without disabling interrupts. When possible, this is a "
"better solution — but it may not be supported on your platform."
msgstr ""
"此時 `COUNTER` 是安全的 `static` 變數。多虧 `AtomicUsize` 型別，`COUNTER`可在"
"不中斷的情況下由中斷處理器與主執行緒安全地修改。若可行，這是更好的解決方案——"
"但你的平台可能不支援。"

#: src/concurrency/index.md:192
msgid ""
"A note on [`Ordering`](https://doc.rust-lang.org/core/sync/atomic/enum."
"Ordering.html): this affects how the compiler and hardware may reorder "
"instructions, and also has consequences on cache visibility. Assuming that "
"the target is a single core platform `Relaxed` is sufficient and the most "
"efficient choice in this particular case. Stricter ordering will cause the "
"compiler to emit memory barriers around the atomic operations; depending on "
"what you're using atomics for you may or may not need this! The precise "
"details of the atomic model are complicated and best described elsewhere."
msgstr ""
"關於 [`Ordering`](https://doc.rust-lang.org/core/sync/atomic/enum.Ordering."
"html)：它會影響編譯器與硬體可能重排序指令的方式，並且會影響快取可見性。假設目"
"標是單核心平台，在此情況下 `Relaxed` 足夠且最有效率。更嚴格的排序會讓編譯器在"
"原子操作周圍插入記憶體屏障；視你使用原子的目的而定，可能需要也可能不需要。原"
"子模型的精確細節相當複雜，最好參考其他資料。"

#: src/concurrency/index.md:200
msgid ""
"For more details on atomics and ordering, see the [nomicon](https://doc.rust-"
"lang.org/nomicon/atomics.html)."
msgstr ""
"更多關於原子操作與排序的細節，請參考 [nomicon](https://doc.rust-lang.org/"
"nomicon/atomics.html)。"

#: src/concurrency/index.md:206
msgid "Abstractions, Send, and Sync"
msgstr "抽象、Send 與 Sync"

#: src/concurrency/index.md:208
msgid ""
"None of the above solutions are especially satisfactory. They require "
"`unsafe` blocks which must be very carefully checked and are not ergonomic. "
"Surely we can do better in Rust!"
msgstr ""
"上述解法都不算理想。它們需要 `unsafe` 區塊，必須非常仔細地檢查，且不夠易用。"
"我們在 Rust 中一定能做得更好！"

#: src/concurrency/index.md:212
msgid ""
"We can abstract our counter into a safe interface which can be safely used "
"anywhere else in our code. For this example, we'll use the critical-section "
"counter, but you could do something very similar with atomics."
msgstr ""
"我們可以把計數器抽象成安全的介面，讓程式其他地方都能安全使用。此例中我們會使"
"用臨界區計數器，但用原子操作也能做出很相似的作法。"

#: src/concurrency/index.md:219
msgid ""
"// Our counter is just a wrapper around UnsafeCell<u32>, which is the heart\n"
"// of interior mutability in Rust. By using interior mutability, we can "
"have\n"
"// COUNTER be `static` instead of `static mut`, but still able to mutate\n"
"// its counter value.\n"
msgstr ""
"// 我們的計數器只是對 UnsafeCell<u32> 的包裝，這是 Rust 內部可變性的核心\n"
"// 透過內部可變性，我們可以讓 COUNTER 成為 `static` 而不是 `static mut`，但\n"
"// 仍可變更其計數值。\n"

#: src/concurrency/index.md:230
msgid ""
"// By requiring a CriticalSection be passed in, we know we must\n"
"        // be operating inside a CriticalSection, and so can confidently\n"
"        // use this unsafe block (required to call UnsafeCell::get).\n"
msgstr ""
"// 透過要求傳入 CriticalSection，我們知道必須\n"
"        // 在臨界區內操作，因此可以放心使用這個 unsafe 區塊（呼叫\n"
"        // UnsafeCell::get 所必需）。\n"

#: src/concurrency/index.md:240
msgid "// Required to allow static CSCounter. See explanation below.\n"
msgstr "// 允許 static CSCounter 所需，詳見下方說明。\n"

#: src/concurrency/index.md:243
msgid ""
"// COUNTER is no longer `mut` as it uses interior mutability;\n"
"// therefore it also no longer requires unsafe blocks to access.\n"
msgstr ""
"// COUNTER 因使用內部可變性而不再是 `mut`；\n"
"// 因此存取它也不再需要 unsafe 區塊。\n"

#: src/concurrency/index.md:255
msgid "// No unsafe here!\n"
msgstr "// 這裡沒有 unsafe！\n"

#: src/concurrency/index.md:264
msgid ""
"// We do need to enter a critical section here just to obtain a valid\n"
"    // cs token, even though we know no other interrupt could pre-empt\n"
"    // this one.\n"
msgstr ""
"// 我們仍需進入臨界區才能取得有效的 cs token，\n"
"    // 即便我們知道沒有其他中斷能搶占這個中斷。\n"

#: src/concurrency/index.md:269
msgid ""
"// We could use unsafe code to generate a fake CriticalSection if we\n"
"    // really wanted to, avoiding the overhead:\n"
"    // let cs = unsafe { interrupt::CriticalSection::new() };\n"
msgstr ""
"// 如果真的想避免開銷，我們可以用 unsafe 產生假的 CriticalSection：\n"
"    // let cs = unsafe { interrupt::CriticalSection::new() };\n"

#: src/concurrency/index.md:275
msgid ""
"We've moved our `unsafe` code to inside our carefully-planned abstraction, "
"and now our application code does not contain any `unsafe` blocks."
msgstr ""
"我們把 `unsafe` 程式碼移到精心設計的抽象內部，現在應用程式碼不再含有任何 "
"`unsafe` 區塊。"

#: src/concurrency/index.md:278
msgid ""
"This design requires that the application pass a `CriticalSection` token in: "
"these tokens are only safely generated by `interrupt::free`, so by requiring "
"one be passed in, we ensure we are operating inside a critical section, "
"without having to actually do the lock ourselves. This guarantee is provided "
"statically by the compiler: there won't be any runtime overhead associated "
"with `cs`. If we had multiple counters, they could all be given the same "
"`cs`, without requiring multiple nested critical sections."
msgstr ""

#: src/concurrency/index.md:286
msgid ""
"This also brings up an important topic for concurrency in Rust: the [`Send` "
"and `Sync`](https://doc.rust-lang.org/nomicon/send-and-sync.html) traits. To "
"summarise the Rust book, a type is Send when it can safely be moved to "
"another thread, while it is Sync when it can be safely shared between "
"multiple threads. In an embedded context, we consider interrupts to be "
"executing in a separate thread to the application code, so variables "
"accessed by both an interrupt and the main code must be Sync."
msgstr ""

#: src/concurrency/index.md:296
msgid ""
"For most types in Rust, both of these traits are automatically derived for "
"you by the compiler. However, because `CSCounter` contains an [`UnsafeCell`]"
"(https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html), it is not "
"Sync, and therefore we could not make a `static CSCounter`: `static` "
"variables _must_ be Sync, since they can be accessed by multiple threads."
msgstr ""

#: src/concurrency/index.md:303
msgid ""
"To tell the compiler we have taken care that the `CSCounter` is in fact safe "
"to share between threads, we implement the Sync trait explicitly. As with "
"the previous use of critical sections, this is only safe on single-core "
"platforms: with multiple cores, you would need to go to greater lengths to "
"ensure safety."
msgstr ""

#: src/concurrency/index.md:308
msgid "Mutexes"
msgstr ""

#: src/concurrency/index.md:310
msgid ""
"We've created a useful abstraction specific to our counter problem, but "
"there are many common abstractions used for concurrency."
msgstr ""

#: src/concurrency/index.md:313
msgid ""
"One such _synchronisation primitive_ is a mutex, short for mutual exclusion. "
"These constructs ensure exclusive access to a variable, such as our counter. "
"A thread can attempt to _lock_ (or _acquire_) the mutex, and either succeeds "
"immediately, or blocks waiting for the lock to be acquired, or returns an "
"error that the mutex could not be locked. While that thread holds the lock, "
"it is granted access to the protected data. When the thread is done, it "
"_unlocks_ (or _releases_) the mutex, allowing another thread to lock it. In "
"Rust, we would usually implement the unlock using the [`Drop`](https://doc."
"rust-lang.org/core/ops/trait.Drop.html) trait to ensure it is always "
"released when the mutex goes out of scope."
msgstr ""

#: src/concurrency/index.md:325
msgid ""
"Using a mutex with interrupt handlers can be tricky: it is not normally "
"acceptable for the interrupt handler to block, and it would be especially "
"disastrous for it to block waiting for the main thread to release a lock, "
"since we would then _deadlock_ (the main thread will never release the lock "
"because execution stays in the interrupt handler). Deadlocking is not "
"considered unsafe: it is possible even in safe Rust."
msgstr ""

#: src/concurrency/index.md:332
msgid ""
"To avoid this behaviour entirely, we could implement a mutex which requires "
"a critical section to lock, just like our counter example. So long as the "
"critical section must last as long as the lock, we can be sure we have "
"exclusive access to the wrapped variable without even needing to track the "
"lock/unlock state of the mutex."
msgstr ""

#: src/concurrency/index.md:338
msgid ""
"This is in fact done for us in the `cortex_m` crate! We could have written "
"our counter using it:"
msgstr ""

#: src/concurrency/index.md:363
msgid ""
"// We still need to enter a critical section here to satisfy the Mutex.\n"
msgstr ""

#: src/concurrency/index.md:368
msgid ""
"We're now using [`Cell`](https://doc.rust-lang.org/core/cell/struct.Cell."
"html), which along with its sibling `RefCell` is used to provide safe "
"interior mutability. We've already seen `UnsafeCell` which is the bottom "
"layer of interior mutability in Rust: it allows you to obtain multiple "
"mutable references to its value, but only with unsafe code. A `Cell` is like "
"an `UnsafeCell` but it provides a safe interface: it only permits taking a "
"copy of the current value or replacing it, not taking a reference, and since "
"it is not Sync, it cannot be shared between threads. These constraints mean "
"it's safe to use, but we couldn't use it directly in a `static` variable as "
"a `static` must be Sync."
msgstr ""

#: src/concurrency/index.md:380
msgid ""
"So why does the example above work? The `Mutex<T>` implements Sync for any "
"`T` which is Send — such as a `Cell`. It can do this safely because it only "
"gives access to its contents during a critical section. We're therefore able "
"to get a safe counter with no unsafe code at all!"
msgstr ""

#: src/concurrency/index.md:385
msgid ""
"This is great for simple types like the `u32` of our counter, but what about "
"more complex types which are not Copy? An extremely common example in an "
"embedded context is a peripheral struct, which generally is not Copy. For "
"that, we can turn to `RefCell`."
msgstr ""

#: src/concurrency/index.md:390
msgid "Sharing Peripherals"
msgstr ""

#: src/concurrency/index.md:392
msgid ""
"Device crates generated using `svd2rust` and similar abstractions provide "
"safe access to peripherals by enforcing that only one instance of the "
"peripheral struct can exist at a time. This ensures safety, but makes it "
"difficult to access a peripheral from both the main thread and an interrupt "
"handler."
msgstr ""

#: src/concurrency/index.md:398
msgid ""
"To safely share peripheral access, we can use the `Mutex` we saw before. "
"We'll also need to use [`RefCell`](https://doc.rust-lang.org/core/cell/"
"struct.RefCell.html), which uses a runtime check to ensure only one "
"reference to a peripheral is given out at a time. This has more overhead "
"than the plain `Cell`, but since we are giving out references rather than "
"copies, we must be sure only one exists at a time."
msgstr ""

#: src/concurrency/index.md:406
msgid ""
"Finally, we'll also have to account for somehow moving the peripheral into "
"the shared variable after it has been initialised in the main code. To do "
"this we can use the `Option` type, initialised to `None` and later set to "
"the instance of the peripheral."
msgstr ""

#: src/concurrency/index.md:421
msgid ""
"// Obtain the peripheral singletons and configure it.\n"
"    // This example is from an svd2rust-generated crate, but\n"
"    // most embedded device crates will be similar.\n"
msgstr ""

#: src/concurrency/index.md:427
msgid ""
"// Some sort of configuration function.\n"
"    // Assume it sets PA0 to an input and PA1 to an output.\n"
msgstr ""

#: src/concurrency/index.md:431
msgid "// Store the GPIOA in the mutex, moving it.\n"
msgstr ""

#: src/concurrency/index.md:433
msgid ""
"// We can no longer use `gpioa` or `dp.GPIOA`, and instead have to\n"
"    // access it via the mutex.\n"
msgstr ""

#: src/concurrency/index.md:436
msgid ""
"// Be careful to enable the interrupt only after setting MY_GPIO:\n"
"    // otherwise the interrupt might fire while it still contains None,\n"
"    // and as-written (with `unwrap()`), it would panic.\n"
msgstr ""

#: src/concurrency/index.md:442
msgid "// We'll now read state as a digital input, via the mutex\n"
msgstr ""

#: src/concurrency/index.md:449
msgid "// Set PA1 high if we've seen a rising edge on PA0.\n"
msgstr ""

#: src/concurrency/index.md:461
msgid "// This time in the interrupt we'll just clear PA0.\n"
msgstr ""

#: src/concurrency/index.md:463
msgid ""
"// We can use `unwrap()` because we know the interrupt wasn't enabled\n"
"        // until after MY_GPIO was set; otherwise we should handle the "
"potential\n"
"        // for a None value.\n"
msgstr ""

#: src/concurrency/index.md:472
msgid "That's quite a lot to take in, so let's break down the important lines."
msgstr ""

#: src/concurrency/index.md:479
msgid ""
"Our shared variable is now a `Mutex` around a `RefCell` which contains an "
"`Option`. The `Mutex` ensures we only have access during a critical section, "
"and therefore makes the variable Sync, even though a plain `RefCell` would "
"not be Sync. The `RefCell` gives us interior mutability with references, "
"which we'll need to use our `GPIOA`. The `Option` lets us initialise this "
"variable to something empty, and only later actually move the variable in. "
"We cannot access the peripheral singleton statically, only at runtime, so "
"this is required."
msgstr ""

#: src/concurrency/index.md:492
msgid ""
"Inside a critical section we can call `borrow()` on the mutex, which gives "
"us a reference to the `RefCell`. We then call `replace()` to move our new "
"value into the `RefCell`."
msgstr ""

#: src/concurrency/index.md:503
msgid ""
"Finally, we use `MY_GPIO` in a safe and concurrent fashion. The critical "
"section prevents the interrupt firing as usual, and lets us borrow the "
"mutex.  The `RefCell` then gives us an `&Option<GPIOA>`, and tracks how long "
"it remains borrowed - once that reference goes out of scope, the `RefCell` "
"will be updated to indicate it is no longer borrowed."
msgstr ""

#: src/concurrency/index.md:509
msgid ""
"Since we can't move the `GPIOA` out of the `&Option`, we need to convert it "
"to an `&Option<&GPIOA>` with `as_ref()`, which we can finally `unwrap()` to "
"obtain the `&GPIOA` which lets us modify the peripheral."
msgstr ""

#: src/concurrency/index.md:513
msgid ""
"If we need a mutable reference to a shared resource, then `borrow_mut` and "
"`deref_mut` should be used instead. The following code shows an example "
"using the TIM2 timer."
msgstr ""

#: src/concurrency/index.md:531
msgid ""
"// Some sort of timer configuration function.\n"
"    // Assume it configures the TIM2 timer, its NVIC interrupt,\n"
"    // and finally starts the timer.\n"
msgstr ""

#: src/concurrency/index.md:556
msgid ""
"Whew! This is safe, but it is also a little unwieldy. Is there anything else "
"we can do?"
msgstr ""

#: src/concurrency/index.md:559
msgid "RTIC"
msgstr ""

#: src/concurrency/index.md:561
msgid ""
"One alternative is the [RTIC framework](https://github.com/rtic-rs/cortex-m-"
"rtic), short for Real Time Interrupt-driven Concurrency. It enforces static "
"priorities and tracks accesses to `static mut` variables (\"resources\") to "
"statically ensure that shared resources are always accessed safely, without "
"requiring the overhead of always entering critical sections and using "
"reference counting (as in `RefCell`). This has a number of advantages such "
"as guaranteeing no deadlocks and giving extremely low time and memory "
"overhead."
msgstr ""

#: src/concurrency/index.md:570
msgid ""
"The framework also includes other features like message passing, which "
"reduces the need for explicit shared state, and the ability to schedule "
"tasks to run at a given time, which can be used to implement periodic tasks. "
"Check out [the documentation](https://rtic.rs) for more information!"
msgstr ""

#: src/concurrency/index.md:577
msgid "Real Time Operating Systems"
msgstr ""

#: src/concurrency/index.md:579
msgid ""
"Another common model for embedded concurrency is the real-time operating "
"system (RTOS). While currently less well explored in Rust, they are widely "
"used in traditional embedded development. Open source examples include "
"[FreeRTOS](https://freertos.org/) and [ChibiOS](http://chibios.org/). These "
"RTOSs provide support for running multiple application threads which the CPU "
"swaps between, either when the threads yield control (called cooperative "
"multitasking) or based on a regular timer or interrupts (preemptive "
"multitasking). The RTOS typically provide mutexes and other synchronisation "
"primitives, and often interoperate with hardware features such as DMA "
"engines."
msgstr ""

#: src/concurrency/index.md:591
msgid ""
"At the time of writing, there are not many Rust RTOS examples to point to, "
"but it's an interesting area so watch this space!"
msgstr ""

#: src/concurrency/index.md:594
msgid "Multiple Cores"
msgstr ""

#: src/concurrency/index.md:596
msgid ""
"It is becoming more common to have two or more cores in embedded processors, "
"which adds an extra layer of complexity to concurrency. All the examples "
"using a critical section (including the `cortex_m::interrupt::Mutex`) assume "
"the only other execution thread is the interrupt thread, but on a multi-core "
"system that's no longer true. Instead, we'll need synchronisation primitives "
"designed for multiple cores (also called SMP, for symmetric multi-"
"processing)."
msgstr ""

#: src/concurrency/index.md:603
msgid ""
"These typically use the atomic instructions we saw earlier, since the "
"processing system will ensure that atomicity is maintained over all cores."
msgstr ""

#: src/concurrency/index.md:606
msgid ""
"Covering these topics in detail is currently beyond the scope of this book, "
"but the general patterns are the same as for the single-core case."
msgstr ""

#: src/design-patterns/index.md:1
msgid "Design Patterns"
msgstr "設計模式"

#: src/design-patterns/index.md:3
msgid ""
"This chapter aims to collect various useful design patterns for embedded "
"Rust."
msgstr ""

#: src/design-patterns/hal/index.md:1
msgid "HAL Design Patterns"
msgstr "HAL 設計模式"

#: src/design-patterns/hal/index.md:3
msgid ""
"This is a set of common and recommended patterns for writing hardware "
"abstraction layers (HALs) for microcontrollers in Rust. These patterns are "
"intended to be used in addition to the existing [Rust API Guidelines]"
"(https://rust-lang.github.io/api-guidelines/) when writing HALs for "
"microcontrollers."
msgstr ""

#: src/design-patterns/hal/index.md:10
msgid "[Checklist](checklist.md)"
msgstr ""

#: src/design-patterns/hal/index.md:12
msgid "[Naming](naming.md)"
msgstr ""

#: src/design-patterns/hal/index.md:13
msgid "[Interoperability](interoperability.md)"
msgstr ""

#: src/design-patterns/hal/index.md:14
msgid "[Predictability](predictability.md)"
msgstr ""

#: src/design-patterns/hal/index.md:15
msgid "[GPIO](gpio.md)"
msgstr ""

#: src/design-patterns/hal/checklist.md:1
msgid "HAL Design Patterns Checklist"
msgstr ""

#: src/design-patterns/hal/checklist.md:3
msgid "**Naming** _(crate aligns with Rust naming conventions)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:4
msgid ""
"The crate is named appropriately ([C-CRATE-NAME](naming.html#c-crate-name))"
msgstr ""

#: src/design-patterns/hal/checklist.md:5
msgid ""
"**Interoperability** _(crate interacts nicely with other library "
"functionality)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:6
msgid ""
"Wrapper types provide a destructor method ([C-FREE](interoperability.html#c-"
"free))"
msgstr ""

#: src/design-patterns/hal/checklist.md:7
msgid ""
"HALs reexport their register access crate ([C-REEXPORT-PAC](interoperability."
"html#c-reexport-pac))"
msgstr ""

#: src/design-patterns/hal/checklist.md:8
msgid ""
"Types implement the `embedded-hal` traits ([C-HAL-TRAITS](interoperability."
"html#c-hal-traits))"
msgstr ""

#: src/design-patterns/hal/checklist.md:9
msgid ""
"**Predictability** _(crate enables legible code that acts how it looks)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:10
msgid ""
"Constructors are used instead of extension traits ([C-CTOR](predictability."
"html#c-ctor))"
msgstr ""

#: src/design-patterns/hal/checklist.md:11
msgid "**GPIO Interfaces** _(GPIO Interfaces follow a common pattern)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:12
msgid "Pin types are zero-sized by default ([C-ZST-PIN](gpio.md#c-zst-pin))"
msgstr ""

#: src/design-patterns/hal/checklist.md:13
msgid ""
"Pin types provide methods to erase pin and port ([C-ERASED-PIN](gpio.md#c-"
"erased-pin))"
msgstr ""

#: src/design-patterns/hal/checklist.md:14
msgid ""
"Pin state should be encoded as type parameters ([C-PIN-STATE](gpio.md#c-pin-"
"state))"
msgstr ""

#: src/design-patterns/hal/gpio.md:1
msgid "Recommendations for GPIO Interfaces"
msgstr ""

#: src/design-patterns/hal/gpio.md:3
msgid "<a id=\"c-zst-pin\"></a>"
msgstr ""

#: src/design-patterns/hal/gpio.md:4
msgid "Pin types are zero-sized by default (C-ZST-PIN)"
msgstr ""

#: src/design-patterns/hal/gpio.md:6
msgid ""
"GPIO Interfaces exposed by the HAL should provide dedicated zero-sized types "
"for each pin on every interface or port, resulting in a zero-cost GPIO "
"abstraction when all pin assignments are statically known."
msgstr ""

#: src/design-patterns/hal/gpio.md:10
msgid ""
"Each GPIO Interface or Port should implement a `split` method returning a "
"struct with every pin."
msgstr ""

#: src/design-patterns/hal/gpio.md:13 src/design-patterns/hal/gpio.md:45
#: src/design-patterns/hal/gpio.md:127
msgid "Example:"
msgstr ""

#: src/design-patterns/hal/gpio.md:17 src/design-patterns/hal/gpio.md:27
#: src/design-patterns/hal/gpio.md:35 src/design-patterns/hal/gpio.md:138
msgid "// ...\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:39
msgid "<a id=\"c-erased-pin\"></a>"
msgstr ""

#: src/design-patterns/hal/gpio.md:40
msgid "Pin types provide methods to erase pin and port (C-ERASED-PIN)"
msgstr ""

#: src/design-patterns/hal/gpio.md:42
msgid ""
"Pins should provide type erasure methods that move their properties from "
"compile time to runtime, and allow more flexibility in applications."
msgstr ""

#: src/design-patterns/hal/gpio.md:48
msgid "/// Port A, pin 0.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:56
msgid "/// A pin on port A.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:59
msgid "/// The pin number.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:75
msgid "// (these fields can be packed to reduce the memory footprint)\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:86
msgid "<a id=\"c-pin-state\"></a>"
msgstr ""

#: src/design-patterns/hal/gpio.md:87
msgid "Pin state should be encoded as type parameters (C-PIN-STATE)"
msgstr ""

#: src/design-patterns/hal/gpio.md:89
msgid ""
"Pins may be configured as input or output with different characteristics "
"depending on the chip or family. This state should be encoded in the type "
"system to prevent use of pins in incorrect states."
msgstr ""

#: src/design-patterns/hal/gpio.md:93
msgid ""
"Additional, chip-specific state (eg. drive strength) may also be encoded in "
"this way, using additional type parameters."
msgstr ""

#: src/design-patterns/hal/gpio.md:96
msgid ""
"Methods for changing the pin state should be provided as `into_input` and "
"`into_output` methods."
msgstr ""

#: src/design-patterns/hal/gpio.md:99
msgid ""
"Additionally, `with_{input,output}_state` methods should be provided that "
"temporarily reconfigure a pin in a different state without moving it."
msgstr ""

#: src/design-patterns/hal/gpio.md:102
msgid ""
"The following methods should be provided for every pin type (that is, both "
"erased and non-erased pin types should provide the same API):"
msgstr ""

#: src/design-patterns/hal/gpio.md:105
msgid "`pub fn into_input<N: InputState>(self, input: N) -> Pin<N>`"
msgstr ""

#: src/design-patterns/hal/gpio.md:106
msgid "`pub fn into_output<N: OutputState>(self, output: N) -> Pin<N>`"
msgstr ""

#: src/design-patterns/hal/gpio.md:123
msgid ""
"Pin state should be bounded by sealed traits. Users of the HAL should have "
"no need to add their own state. The traits can provide HAL-specific methods "
"required to implement the pin state API."
msgstr ""

#: src/design-patterns/hal/gpio.md:203
msgid "// Same for `PA` and `Pin`, and other pin types.\n"
msgstr ""

#: src/design-patterns/hal/interoperability.md:1
msgid "Interoperability"
msgstr "互通性"

#: src/design-patterns/hal/interoperability.md:4
msgid "<a id=\"c-free\"></a>"
msgstr ""

#: src/design-patterns/hal/interoperability.md:5
msgid "Wrapper types provide a destructor method (C-FREE)"
msgstr ""

#: src/design-patterns/hal/interoperability.md:7
msgid ""
"Any non-`Copy` wrapper type provided by the HAL should provide a `free` "
"method that consumes the wrapper and returns back the raw peripheral (and "
"possibly other objects) it was created from."
msgstr ""

#: src/design-patterns/hal/interoperability.md:11
msgid ""
"The method should shut down and reset the peripheral if necessary. Calling "
"`new` with the raw peripheral returned by `free` should not fail due to an "
"unexpected state of the peripheral."
msgstr ""

#: src/design-patterns/hal/interoperability.md:15
msgid ""
"If the HAL type requires other non-`Copy` objects to be constructed (for "
"example I/O pins), any such object should be released and returned by `free` "
"as well. `free` should return a tuple in that case."
msgstr ""

#: src/design-patterns/hal/interoperability.md:19
msgid "For example:"
msgstr ""

#: src/design-patterns/hal/interoperability.md:36
msgid "<a id=\"c-reexport-pac\"></a>"
msgstr ""

#: src/design-patterns/hal/interoperability.md:37
msgid "HALs reexport their register access crate (C-REEXPORT-PAC)"
msgstr ""

#: src/design-patterns/hal/interoperability.md:39
msgid ""
"HALs can be written on top of [svd2rust](https://github.com/rust-embedded/"
"svd2rust)\\-generated PACs, or on top of other crates that provide raw "
"register access. HALs should always reexport the register access crate they "
"are based on in their crate root."
msgstr ""

#: src/design-patterns/hal/interoperability.md:43
msgid ""
"A PAC should be reexported under the name `pac`, regardless of the actual "
"name of the crate, as the name of the HAL should already make it clear what "
"PAC is being accessed."
msgstr ""

#: src/design-patterns/hal/interoperability.md:49
msgid "<a id=\"c-hal-traits\"></a>"
msgstr ""

#: src/design-patterns/hal/interoperability.md:50
msgid "Types implement the `embedded-hal` traits (C-HAL-TRAITS)"
msgstr ""

#: src/design-patterns/hal/interoperability.md:52
msgid ""
"Types provided by the HAL should implement all applicable traits provided by "
"the [`embedded-hal`](https://github.com/rust-embedded/embedded-hal) crate."
msgstr ""

#: src/design-patterns/hal/interoperability.md:55
msgid "Multiple traits may be implemented for the same type."
msgstr ""

#: src/design-patterns/hal/naming.md:1
msgid "Naming"
msgstr "命名"

#: src/design-patterns/hal/naming.md:4
msgid "<a id=\"c-crate-name\"></a>"
msgstr ""

#: src/design-patterns/hal/naming.md:5
msgid "The crate is named appropriately (C-CRATE-NAME)"
msgstr ""

#: src/design-patterns/hal/naming.md:7
msgid ""
"HAL crates should be named after the chip or family of chips they aim to "
"support. Their name should end with `-hal` to distinguish them from register "
"access crates. The name should not contain underscores (use dashes instead)."
msgstr ""

#: src/SUMMARY.md:47
msgid "Predictability"
msgstr "可預測性"

#: src/design-patterns/hal/predictability.md:4
msgid "<a id=\"c-ctor\"></a>"
msgstr ""

#: src/design-patterns/hal/predictability.md:5
msgid "Constructors are used instead of extension traits (C-CTOR)"
msgstr ""

#: src/design-patterns/hal/predictability.md:7
msgid ""
"All peripherals to which the HAL adds functionality should be wrapped in a "
"new type, even if no additional fields are required for that functionality."
msgstr ""

#: src/design-patterns/hal/predictability.md:10
msgid "Extension traits implemented for the raw peripheral should be avoided."
msgstr ""

#: src/design-patterns/hal/predictability.md:12
msgid "<a id=\"c-inline\"></a>"
msgstr ""

#: src/design-patterns/hal/predictability.md:13
msgid "Methods are decorated with `#[inline]` where appropriate (C-INLINE)"
msgstr ""

#: src/design-patterns/hal/predictability.md:15
msgid ""
"The Rust compiler does not by default perform full inlining across crate "
"boundaries. As embedded applications are sensitive to unexpected code size "
"increases, `#[inline]` should be used to guide the compiler as follows:"
msgstr ""

#: src/design-patterns/hal/predictability.md:19
msgid ""
"All \"small\" functions should be marked `#[inline]`. What qualifies as "
"\"small\" is subjective, but generally all functions that are expected to "
"compile down to single-digit instruction sequences qualify as small."
msgstr ""

#: src/design-patterns/hal/predictability.md:22
msgid ""
"Functions that are very likely to take constant values as parameters should "
"be marked as `#[inline]`. This enables the compiler to compute even "
"complicated initialization logic at compile time, provided the function "
"inputs are known."
msgstr ""

#: src/start/index.md:1
msgid "Getting Started"
msgstr "開始上手"

#: src/start/index.md:3
msgid ""
"In this section we'll walk you through the process of writing, building, "
"flashing and debugging embedded programs. You will be able to try most of "
"the examples without any special hardware as we will show you the basics "
"using QEMU, a popular open-source hardware emulator. The only section where "
"hardware is required is, naturally enough, the [Hardware](./hardware.md) "
"section, where we use OpenOCD to program an [STM32F3DISCOVERY](http://www.st."
"com/en/evaluation-tools/stm32f3discovery.html)."
msgstr ""
"在本節中，我們將帶你走過撰寫、建置、燒錄與除錯嵌入式程式的流程。你可以在不需"
"特殊硬體的情況下嘗試大多數範例，因為我們會使用 QEMU（常見的開源硬體模擬器）展"
"示基礎。唯有[硬體](./hardware.md)章節需要實體硬體，我們會使用 OpenOCD 對 "
"[STM32F3DISCOVERY](http://www.st.com/en/evaluation-tools/stm32f3discovery."
"html) 進行燒錄。"

#: src/SUMMARY.md:27
msgid "Exceptions"
msgstr "例外"

#: src/start/exceptions.md:3
msgid ""
"Exceptions, and interrupts, are a hardware mechanism by which the processor "
"handles asynchronous events and fatal errors (e.g. executing an invalid "
"instruction). Exceptions imply preemption and involve exception handlers, "
"subroutines executed in response to the signal that triggered the event."
msgstr ""

#: src/start/exceptions.md:8
msgid ""
"The `cortex-m-rt` crate provides an [`exception`](https://docs.rs/cortex-m-"
"rt-macros/latest/cortex_m_rt_macros/attr.exception.html) attribute to "
"declare exception handlers."
msgstr ""

#: src/start/exceptions.md:14
msgid "// Exception handler for the SysTick (System Timer) exception\n"
msgstr ""

#: src/start/exceptions.md:21
msgid ""
"Other than the `exception` attribute exception handlers look like plain "
"functions but there's one more difference: `exception` handlers can _not_ be "
"called by software. Following the previous example, the statement `SysTick();"
"` would result in a compilation error."
msgstr ""

#: src/start/exceptions.md:26
msgid ""
"This behavior is pretty much intended and it's required to provide a "
"feature: `static mut` variables declared _inside_ `exception` handlers are "
"_safe_ to use."
msgstr ""

#: src/start/exceptions.md:34
msgid "// `COUNT` has transformed to type `&mut u32` and it's safe to use\n"
msgstr ""

#: src/start/exceptions.md:39
msgid ""
"As you may know, using `static mut` variables in a function makes it [_non-"
"reentrant_](https://en.wikipedia.org/wiki/Reentrancy_(computing)). It's "
"undefined behavior to call a non-reentrant function, directly or indirectly, "
"from more than one exception / interrupt handler or from `main` and one or "
"more exception / interrupt handlers."
msgstr ""

#: src/start/exceptions.md:44
msgid ""
"Safe Rust must never result in undefined behavior so non-reentrant functions "
"must be marked as `unsafe`. Yet I just told that `exception` handlers can "
"safely use `static mut` variables. How is this possible? This is possible "
"because `exception` handlers can _not_ be called by software thus reentrancy "
"is not possible. These handlers are called by the hardware itself which is "
"assumed to be physically non-concurrent."
msgstr ""

#: src/start/exceptions.md:50
msgid ""
"As a result, in the context of exception handlers in embedded systems, the "
"absence of concurrent invocations of the same handler ensures that there are "
"no reentrancy issues, even if the handler uses static mutable variables."
msgstr ""

#: src/start/exceptions.md:52
msgid ""
"In a multicore system, where multiple processor cores are executing code "
"concurrently, the potential for reentrancy issues becomes relevant again, "
"even within exception handlers. While each core may have its own set of "
"exception handlers, there can still be scenarios where multiple cores "
"attempt to execute the same exception handler simultaneously.  \n"
"To address this concern in a multicore environment, proper synchronization "
"mechanisms need to be employed within the exception handlers to ensure that "
"access to shared resources is properly coordinated among the cores. This "
"typically involves the use of techniques such as locks, semaphores, or "
"atomic operations to prevent data races and maintain data integrity"
msgstr ""

#: src/start/exceptions.md:55
msgid ""
"Note that the `exception` attribute transforms definitions of static "
"variables inside the function by wrapping them into `unsafe` blocks and "
"providing us with new appropriate variables of type `&mut` of the same name. "
"Thus we can dereference the reference via `*` to access the values of the "
"variables without needing to wrap them in an `unsafe` block."
msgstr ""

#: src/start/exceptions.md:61
msgid "A complete example"
msgstr ""

#: src/start/exceptions.md:63
msgid ""
"Here's an example that uses the system timer to raise a `SysTick` exception "
"roughly every second. The `SysTick` exception handler keeps track of how "
"many times it has been called in the `COUNT` variable and then prints the "
"value of `COUNT` to the host console using semihosting."
msgstr ""

#: src/start/exceptions.md:68
msgid ""
"**NOTE**: You can run this example on any Cortex-M device; you can also run "
"it on QEMU"
msgstr ""

#: src/start/exceptions.md:92
msgid ""
"// configures the system timer to trigger a SysTick exception every second\n"
msgstr ""

#: src/start/exceptions.md:94
msgid ""
"// this is configured for the LM3S6965 which has a default CPU clock of 12 "
"MHz\n"
msgstr ""

#: src/start/exceptions.md:110
msgid "// Lazy initialization\n"
msgstr ""

#: src/start/exceptions.md:116
msgid "\"{}\""
msgstr ""

#: src/start/exceptions.md:119
msgid ""
"// IMPORTANT omit this `if` block if running on real hardware or your\n"
"    // debugger will end in an inconsistent state\n"
msgstr ""

#: src/start/exceptions.md:122
msgid "// This will terminate the QEMU process\n"
msgstr ""

#: src/start/exceptions.md:132
msgid ""
"```toml\n"
"[dependencies]\n"
"cortex-m = \"0.5.7\"\n"
"cortex-m-rt = \"0.6.3\"\n"
"panic-halt = \"0.2.0\"\n"
"cortex-m-semihosting = \"0.3.1\"\n"
"```"
msgstr ""

#: src/start/exceptions.md:146
msgid ""
"If you run this on the Discovery board you'll see the output on the OpenOCD "
"console. Also, the program will _not_ stop when the count reaches 9."
msgstr ""

#: src/start/exceptions.md:149
msgid "The default exception handler"
msgstr ""

#: src/start/exceptions.md:151
msgid ""
"What the `exception` attribute actually does is _override_ the default "
"exception handler for a specific exception. If you don't override the "
"handler for a particular exception it will be handled by the "
"`DefaultHandler` function, which defaults to:"
msgstr ""

#: src/start/exceptions.md:162
msgid ""
"This function is provided by the `cortex-m-rt` crate and marked as "
"`#[no_mangle]` so you can put a breakpoint on \"DefaultHandler\" and catch "
"_unhandled_ exceptions."
msgstr ""

#: src/start/exceptions.md:166
msgid ""
"It's possible to override this `DefaultHandler` using the `exception` "
"attribute:"
msgstr ""

#: src/start/exceptions.md:171
msgid "// custom default handler\n"
msgstr ""

#: src/start/exceptions.md:175
msgid ""
"The `irqn` argument indicates which exception is being serviced. A negative "
"value indicates that a Cortex-M exception is being serviced; and zero or a "
"positive value indicate that a device specific exception, AKA interrupt, is "
"being serviced."
msgstr ""

#: src/start/exceptions.md:180
msgid "The hard fault handler"
msgstr ""

#: src/start/exceptions.md:182
msgid ""
"The `HardFault` exception is a bit special. This exception is fired when the "
"program enters an invalid state so its handler can _not_ return as that "
"could result in undefined behavior. Also, the runtime crate does a bit of "
"work before the user defined `HardFault` handler is invoked to improve "
"debuggability."
msgstr ""

#: src/start/exceptions.md:187
msgid ""
"The result is that the `HardFault` handler must have the following "
"signature: `fn(&ExceptionFrame) -> !`. The argument of the handler is a "
"pointer to registers that were pushed into the stack by the exception. These "
"registers are a snapshot of the processor state at the moment the exception "
"was triggered and are useful to diagnose a hard fault."
msgstr ""

#: src/start/exceptions.md:193
msgid ""
"Here's an example that performs an illegal operation: a read to a "
"nonexistent memory location."
msgstr ""

#: src/start/exceptions.md:196
msgid ""
"**NOTE**: This program won't work, i.e. it won't crash, on QEMU because "
"`qemu-system-arm -machine lm3s6965evb` doesn't check memory loads and will "
"happily return `0 `on reads to invalid memory."
msgstr ""

#: src/start/exceptions.md:214
msgid "// read a nonexistent memory location\n"
msgstr ""

#: src/start/exceptions.md:225
msgid "\"{:#?}\""
msgstr ""

#: src/start/exceptions.md:232
msgid ""
"The `HardFault` handler prints the `ExceptionFrame` value. If you run this "
"you'll see something like this on the OpenOCD console."
msgstr ""

#: src/start/exceptions.md:250
msgid ""
"The `pc` value is the value of the Program Counter at the time of the "
"exception and it points to the instruction that triggered the exception."
msgstr ""

#: src/start/exceptions.md:253
msgid "If you look at the disassembly of the program:"
msgstr ""

#: src/start/exceptions.md:266
msgid ""
"You can lookup the value of the program counter `0x0800094a` in the "
"disassembly. You'll see that a load operation (`ldr r0, [r0]` ) caused the "
"exception. The `r0` field of `ExceptionFrame` will tell you the value of "
"register `r0` was `0x3fff_fffe` at that time."
msgstr ""

#: src/start/hardware.md:1
msgid "Hardware"
msgstr "硬體"

#: src/start/hardware.md:3
msgid ""
"By now you should be somewhat familiar with the tooling and the development "
"process. In this section we'll switch to real hardware; the process will "
"remain largely the same. Let's dive in."
msgstr ""

#: src/start/hardware.md:7
msgid "Know your hardware"
msgstr ""

#: src/start/hardware.md:9
msgid ""
"Before we begin you need to identify some characteristics of the target "
"device as these will be used to configure the project:"
msgstr ""

#: src/start/hardware.md:12
msgid "The ARM core. e.g. Cortex-M3."
msgstr ""

#: src/start/hardware.md:14
msgid ""
"Does the ARM core include an FPU? Cortex-M4**F** and Cortex-M7**F** cores do."
msgstr ""

#: src/start/hardware.md:16
msgid ""
"How much Flash memory and RAM does the target device have? e.g. 256 KiB of "
"Flash and 32 KiB of RAM."
msgstr ""

#: src/start/hardware.md:19
msgid ""
"Where are Flash memory and RAM mapped in the address space? e.g. RAM is "
"commonly located at address `0x2000_0000`."
msgstr ""

#: src/start/hardware.md:22
msgid ""
"You can find this information in the data sheet or the reference manual of "
"your device."
msgstr ""

#: src/start/hardware.md:25
msgid ""
"In this section we'll be using our reference hardware, the STM32F3DISCOVERY. "
"This board contains an STM32F303VCT6 microcontroller. This microcontroller "
"has:"
msgstr ""

#: src/start/hardware.md:28
msgid "A Cortex-M4F core that includes a single precision FPU"
msgstr ""

#: src/start/hardware.md:30
msgid "256 KiB of Flash located at address 0x0800_0000."
msgstr ""

#: src/start/hardware.md:32
msgid ""
"40 KiB of RAM located at address 0x2000_0000. (There's another RAM region "
"but for simplicity we'll ignore it)."
msgstr ""

#: src/start/hardware.md:35
msgid "Configuring"
msgstr ""

#: src/start/hardware.md:37
msgid ""
"We'll start from scratch with a fresh template instance. Refer to the "
"[previous section on QEMU](qemu.md) for a refresher on how to do this "
"without `cargo-generate`."
msgstr ""

#: src/start/hardware.md:43
msgid ""
"```text\n"
"$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
" Project Name: app\n"
" Creating project called `app`...\n"
" Done! New project created /tmp/app\n"
"\n"
"$ cd app\n"
"```"
msgstr ""

#: src/start/hardware.md:52
msgid ""
"Step number one is to set a default compilation target in `.cargo/config."
"toml`."
msgstr ""

#: src/start/hardware.md:58
msgid ""
"```toml\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"# target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""

#: src/start/hardware.md:66
msgid "We'll use `thumbv7em-none-eabihf` as that covers the Cortex-M4F core."
msgstr ""

#: src/start/hardware.md:67
msgid ""
"**NOTE**: As you may remember from the previous chapter, we have to install "
"all targets and this is a new one. So don't forget to run the installation "
"process `rustup target add thumbv7em-none-eabihf` for this target."
msgstr ""

#: src/start/hardware.md:71
msgid ""
"The second step is to enter the memory region information into the `memory."
"x` file."
msgstr ""

#: src/start/hardware.md:84
msgid ""
"**NOTE**: If you for some reason changed the `memory.x` file after you had "
"made the first build of a specific build target, then do `cargo clean` "
"before `cargo build`, because `cargo build` may not track updates of `memory."
"x`."
msgstr ""

#: src/start/hardware.md:88
msgid ""
"We'll start with the hello example again, but first we have to make a small "
"change."
msgstr ""

#: src/start/hardware.md:91
msgid ""
"In `examples/hello.rs`, make sure the `debug::exit()` call is commented out "
"or removed. It is used only for running in QEMU."
msgstr ""

#: src/start/hardware.md:97
msgid "\"Hello, world!\""
msgstr ""

#: src/start/hardware.md:99
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
"    // debug::exit(debug::EXIT_SUCCESS);\n"
msgstr ""

#: src/start/hardware.md:107
msgid ""
"You can now cross compile programs using `cargo build` and inspect the "
"binaries using `cargo-binutils` as you did before. The `cortex-m-rt` crate "
"handles all the magic required to get your chip running, as helpfully, "
"pretty much all Cortex-M CPUs boot in the same fashion."
msgstr ""

#: src/start/qemu.md:432
msgid "Debugging"
msgstr "除錯"

#: src/start/hardware.md:118
msgid ""
"Debugging will look a bit different. In fact, the first steps can look "
"different depending on the target device. In this section we'll show the "
"steps required to debug a program running on the STM32F3DISCOVERY. This is "
"meant to serve as a reference; for device specific information about "
"debugging check out [the Debugonomicon](https://github.com/rust-embedded/"
"debugonomicon)."
msgstr ""

#: src/start/hardware.md:124
msgid ""
"As before we'll do remote debugging and the client will be a GDB process. "
"This time, however, the server will be OpenOCD."
msgstr ""

#: src/start/hardware.md:127
msgid ""
"As done during the [verify](../intro/install/verify.md) section connect the "
"discovery board to your laptop / PC and check that the ST-LINK header is "
"populated."
msgstr ""

#: src/start/hardware.md:132
msgid ""
"On a terminal run `openocd` to connect to the ST-LINK on the discovery "
"board. Run this command from the root of the template; `openocd` will pick "
"up the `openocd.cfg` file which indicates which interface file and target "
"file to use."
msgstr ""

#: src/start/hardware.md:155
msgid ""
"**NOTE** If you found out that you have an older revision of the discovery "
"board during the [verify](../intro/install/verify.md) section then you "
"should modify the `openocd.cfg` file at this point to use `interface/stlink-"
"v2.cfg`."
msgstr ""

#: src/start/hardware.md:159
msgid ""
"```text\n"
"$ openocd\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.913879\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"
msgstr ""

#: src/start/hardware.md:179
msgid "On another terminal run GDB, also from the root of the template."
msgstr ""

#: src/start/hardware.md:185
msgid ""
"**NOTE**: like before you might need another version of gdb instead of `gdb-"
"multiarch` depending on which one you installed in the installation chapter. "
"This could also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""

#: src/start/hardware.md:189
msgid ""
"Next connect GDB to OpenOCD, which is waiting for a TCP connection on port "
"3333."
msgstr ""

#: src/start/hardware.md:197
msgid ""
"Now proceed to _flash_ (load) the program onto the microcontroller using the "
"`load` command."
msgstr ""

#: src/start/hardware.md:209
msgid ""
"The program is now loaded. This program uses semihosting so before we do any "
"semihosting call we have to tell OpenOCD to enable semihosting. You can send "
"commands to OpenOCD using the `monitor` command."
msgstr ""

#: src/start/hardware.md:218
msgid ""
"You can see all the OpenOCD commands by invoking the `monitor help` command."
msgstr ""

#: src/start/hardware.md:220
msgid ""
"Like before we can skip all the way to `main` using a breakpoint and the "
"`continue` command."
msgstr ""

#: src/start/hardware.md:235
msgid ""
"**NOTE** If GDB blocks the terminal instead of hitting the breakpoint after "
"you issue the `continue` command above, you might want to double check that "
"the memory region information in the `memory.x` file is correctly set up for "
"your device (both the starts _and_ lengths)."
msgstr ""

#: src/start/hardware.md:240
msgid "Step into the main function with `step`."
msgstr ""

#: src/start/hardware.md:242
msgid ""
"```console\n"
"(gdb) step\n"
"halted: PC: 0x08000496\n"
"hello::__cortex_m_rt_main () at examples/hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""
"```console\n"
"(gdb) step\n"
"halted: PC: 0x08000496\n"
"hello::__cortex_m_rt_main () at examples/hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"

#: src/start/hardware.md:249
msgid ""
"After advancing the program with `next` you should see \"Hello, world!\" "
"printed on the OpenOCD console, among other stuff."
msgstr ""

#: src/start/hardware.md:264
msgid ""
"The message is only displayed once as the program is about to enter the "
"infinite loop defined in line 19: `loop {}`"
msgstr ""

#: src/start/hardware.md:266
msgid "You can now exit GDB using the `quit` command."
msgstr "您現在可以使用 `quit` 命令退出 GDB。"

#: src/start/hardware.md:277
msgid ""
"Debugging now requires a few more steps so we have packed all those steps "
"into a single GDB script named `openocd.gdb`. The file was created during "
"the `cargo generate` step, and should work without any modifications. Let's "
"have a peek:"
msgstr ""

#: src/start/hardware.md:303
msgid ""
"Now running `<gdb> -x openocd.gdb target/thumbv7em-none-eabihf/debug/"
"examples/hello` will immediately connect GDB to OpenOCD, enable semihosting, "
"load the program and start the process."
msgstr ""

#: src/start/hardware.md:306
msgid ""
"Alternatively, you can turn `<gdb> -x openocd.gdb` into a custom runner to "
"make `cargo run` build a program _and_ start a GDB session. This runner is "
"included in `.cargo/config.toml` but it's commented out."
msgstr ""

#: src/start/hardware.md:314
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"# runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -"
"semihosting-config enable=on,target=native -kernel\"\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"# uncomment ONE of these three option to make `cargo run` start a GDB "
"session\n"
"# which option to pick depends on your system\n"
"runner = \"arm-none-eabi-gdb -x openocd.gdb\"\n"
"# runner = \"gdb-multiarch -x openocd.gdb\"\n"
"# runner = \"gdb -x openocd.gdb\"\n"
"```"
msgstr ""

#: src/start/interrupts.md:1
msgid "Interrupts"
msgstr "中斷"

#: src/start/interrupts.md:3
msgid ""
"Interrupts differ from exceptions in a variety of ways but their operation "
"and use is largely similar and they are also handled by the same interrupt "
"controller. Whereas exceptions are defined by the Cortex-M architecture, "
"interrupts are always vendor (and often even chip) specific implementations, "
"both in naming and functionality."
msgstr ""

#: src/start/interrupts.md:9
msgid ""
"Interrupts do allow for a lot of flexibility which needs to be accounted for "
"when attempting to use them in an advanced way. We will not cover those uses "
"in this book, however it is a good idea to keep the following in mind:"
msgstr ""

#: src/start/interrupts.md:13
msgid ""
"Interrupts have programmable priorities which determine their handlers' "
"execution order"
msgstr ""

#: src/start/interrupts.md:14
msgid ""
"Interrupts can nest and preempt, i.e. execution of an interrupt handler "
"might be interrupted by another higher-priority interrupt"
msgstr ""

#: src/start/interrupts.md:15
msgid ""
"In general the reason causing the interrupt to trigger needs to be cleared "
"to prevent re-entering the interrupt handler endlessly"
msgstr ""

#: src/start/interrupts.md:17
msgid "The general initialization steps at runtime are always the same:"
msgstr ""

#: src/start/interrupts.md:18
msgid ""
"Setup the peripheral(s) to generate interrupts requests at the desired "
"occasions"
msgstr ""

#: src/start/interrupts.md:19
msgid ""
"Set the desired priority of the interrupt handler in the interrupt controller"
msgstr ""

#: src/start/interrupts.md:20
msgid "Enable the interrupt handler in the interrupt controller"
msgstr ""

#: src/start/interrupts.md:22
msgid ""
"Similarly to exceptions, the cortex-m-rt crate exposes an [`interrupt`]"
"(https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/attr.interrupt."
"html) attribute for declaring interrupt handlers. However, this attribute is "
"only available when the device feature is enabled. That said, this attribute "
"is not intended to be used directly—doing so will result in a compilation "
"error."
msgstr ""

#: src/start/interrupts.md:26
msgid ""
"Instead, you should use the re-exported version of the interrupt attribute "
"provided by the device crate (usually generated using svd2rust). This "
"ensures that the compiler can verify that the interrupt actually exists on "
"the target device. The list of available interrupts—and their position in "
"the interrupt vector table—is typically auto-generated from an SVD file by "
"svd2rust."
msgstr ""

#: src/start/interrupts.md:33
msgid "// Re-exported attribute from the device crate\n"
msgstr ""

#: src/start/interrupts.md:34
msgid "// Interrupt handler for the Timer2 interrupt\n"
msgstr ""

#: src/start/interrupts.md:38
msgid ""
"// ..\n"
"    // Clear reason for the generated interrupt request\n"
msgstr ""

#: src/start/interrupts.md:43
msgid ""
"Interrupt handlers look like plain functions (except for the lack of "
"arguments) similar to exception handlers. However they can not be called "
"directly by other parts of the firmware due to the special calling "
"conventions. It is however possible to generate interrupt requests in "
"software to trigger a diversion to the interrupt handler."
msgstr ""

#: src/start/interrupts.md:49
msgid ""
"Similar to exception handlers it is also possible to declare `static mut` "
"variables inside the interrupt handlers for _safe_ state keeping."
msgstr ""

#: src/start/interrupts.md:57
msgid "// `COUNT` has type `&mut u32` and it's safe to use\n"
msgstr ""

#: src/start/interrupts.md:62
msgid ""
"For a more detailed description about the mechanisms demonstrated here "
"please refer to the [exceptions section](./exceptions.md)."
msgstr ""

#: src/SUMMARY.md:29
msgid "IO"
msgstr "I/O"

#: src/start/io.md:3
msgid "**TODO** Cover memory mapped I/O using registers."
msgstr ""

#: src/start/registers.md:1
msgid "Memory Mapped Registers"
msgstr ""

#: src/start/registers.md:3
msgid ""
"Embedded systems can only get so far by executing normal Rust code and "
"moving data around in RAM. If we want to get any information into or out of "
"our system (be that blinking an LED, detecting a button press or "
"communicating with an off-chip peripheral on some sort of bus) we're going "
"to have to dip into the world of Peripherals and their 'memory mapped "
"registers'."
msgstr ""

#: src/start/registers.md:5
msgid ""
"You may well find that the code you need to access the peripherals in your "
"micro-controller has already been written, at one of the following levels:"
msgstr ""

#: src/start/registers.md:10
msgid ""
"Micro-architecture Crate - This sort of crate handles any useful routines "
"common to the processor core your microcontroller is using, as well as any "
"peripherals that are common to all micro-controllers that use that "
"particular type of processor core. For example the [cortex-m](https://crates."
"io/crates/cortex-m) crate gives you functions to enable and disable "
"interrupts, which are the same for all Cortex-M based micro-controllers. It "
"also gives you access to the 'SysTick' peripheral included with all Cortex-M "
"based micro-controllers."
msgstr ""

#: src/start/registers.md:11
msgid ""
"Peripheral Access Crate (PAC) - This sort of crate is a thin wrapper over "
"the various memory-wrapper registers defined for your particular part-number "
"of micro-controller you are using. For example, [tm4c123x](https://crates.io/"
"crates/tm4c123x) for the Texas Instruments Tiva-C TM4C123 series, or "
"[stm32f30x](https://crates.io/crates/stm32f30x) for the ST-Micro STM32F30x "
"series. Here, you'll be interacting with the registers directly, following "
"each peripheral's operating instructions given in your micro-controller's "
"Technical Reference Manual."
msgstr ""

#: src/start/registers.md:12
msgid ""
"HAL Crate - These crates offer a more user-friendly API for your particular "
"processor, often by implementing some common traits defined in [embedded-hal]"
"(https://crates.io/crates/embedded-hal). For example, this crate might offer "
"a `Serial` struct, with a constructor that takes an appropriate set of GPIO "
"pins and a baud rate, and offers some sort of `write_byte` function for "
"sending data. See the chapter on [Portability](../portability/index.md) for "
"more information on [embedded-hal](https://crates.io/crates/embedded-hal)."
msgstr ""

#: src/start/registers.md:13
msgid ""
"Board Crate - These crates go one step further than a HAL Crate by pre-"
"configuring various peripherals and GPIO pins to suit the specific developer "
"kit or board you are using, such as [stm32f3-discovery](https://crates.io/"
"crates/stm32f3-discovery) for the STM32F3DISCOVERY board."
msgstr ""

#: src/start/registers.md:23
msgid "Board Crate"
msgstr ""

#: src/start/registers.md:25
msgid ""
"A board crate is the perfect starting point, if you're new to embedded Rust. "
"They nicely abstract the HW details that might be overwhelming when starting "
"studying this subject, and makes standard tasks easy, like turning a LED on "
"or off. The functionality it exposes varies a lot between boards. Since this "
"book aims at staying hardware agnostic, the board crates won't be covered by "
"this book."
msgstr ""

#: src/start/registers.md:27
msgid ""
"If you want to experiment with the STM32F3DISCOVERY board, it is highly "
"recommended to take a look at the [stm32f3-discovery](https://crates.io/"
"crates/stm32f3-discovery) board crate, which provides functionality to blink "
"the board LEDs, access its compass, bluetooth and more. The [Discovery]"
"(https://rust-embedded.github.io/discovery/) book offers a great "
"introduction to the use of a board crate."
msgstr ""

#: src/start/registers.md:29
msgid ""
"But if you're working on a system that doesn't yet have dedicated board "
"crate, or you need functionality not provided by existing crates, read on as "
"we start from the bottom, with the micro-architecture crates."
msgstr ""

#: src/start/registers.md:31
msgid "Micro-architecture crate"
msgstr ""

#: src/start/registers.md:33
msgid ""
"Let's look at the SysTick peripheral that's common to all Cortex-M based "
"micro-controllers. We can find a pretty low-level API in the [cortex-m]"
"(https://crates.io/crates/cortex-m) crate, and we can use it like this:"
msgstr ""

#: src/start/registers.md:51
msgid "// Loop\n"
msgstr ""

#: src/start/registers.md:57
msgid ""
"The functions on the `SYST` struct map pretty closely to the functionality "
"defined by the ARM Technical Reference Manual for this peripheral. There's "
"nothing in this API about 'delaying for X milliseconds' - we have to crudely "
"implement that ourselves using a `while` loop. Note that we can't access our "
"`SYST` struct until we have called `Peripherals::take()` - this is a special "
"routine that guarantees that there is only one `SYST` structure in our "
"entire program. For more on that, see the [Peripherals](../peripherals/index."
"md) section."
msgstr ""

#: src/start/registers.md:61
msgid "Using a Peripheral Access Crate (PAC)"
msgstr ""

#: src/start/registers.md:63
msgid ""
"We won't get very far with our embedded software development if we restrict "
"ourselves to only the basic peripherals included with every Cortex-M. At "
"some point, we're going to need to write some code that's specific to the "
"particular micro-controller we're using. In this example, let's assume we "
"have an Texas Instruments TM4C123 - a middling 80MHz Cortex-M4 with 256 KiB "
"of Flash. We're going to pull in the [tm4c123x](https://crates.io/crates/"
"tm4c123x) crate to make use of this chip."
msgstr ""

#: src/start/registers.md:69 src/start/registers.md:145
msgid "// panic handler\n"
msgstr ""

#: src/start/registers.md:81
msgid "// Mode = 1 => Count up/down mode\n"
msgstr ""

#: src/start/registers.md:84
msgid ""
"// 528 cycles (264 up and down) = 4 loops per video line (2112 cycles)\n"
msgstr ""

#: src/start/registers.md:92
msgid ""
"We've accessed the `PWM0` peripheral in exactly the same way as we accessed "
"the `SYST` peripheral earlier, except we called `tm4c123x::Peripherals::"
"take()`. As this crate was auto-generated using [svd2rust](https://crates.io/"
"crates/svd2rust), the access functions for our register fields take a "
"closure, rather than a numeric argument. While this looks like a lot of "
"code, the Rust compiler can use it to perform a bunch of checks for us, but "
"then generate machine-code which is pretty close to hand-written assembler! "
"Where the auto-generated code isn't able to determine that all possible "
"arguments to a particular accessor function are valid (for example, if the "
"SVD defines the register as 32-bit but doesn't say if some of those 32-bit "
"values have a special meaning), then the function is marked as `unsafe`. We "
"can see this in the example above when setting the `load` and `compa` sub-"
"fields using the `bits()` function."
msgstr ""

#: src/start/registers.md:94
msgid "Reading"
msgstr ""

#: src/start/registers.md:96
msgid ""
"The `read()` function returns an object which gives read-only access to the "
"various sub-fields within this register, as defined by the manufacturer's "
"SVD file for this chip. You can find all the functions available on special "
"`R` return type for this particular register, in this particular peripheral, "
"on this particular chip, in the [tm4c123x documentation](https://docs.rs/"
"tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html)."
msgstr ""

#: src/start/registers.md:100
msgid "// Do a thing\n"
msgstr ""

#: src/start/registers.md:104
msgid "Writing"
msgstr ""

#: src/start/registers.md:106
msgid ""
"The `write()` function takes a closure with a single argument. Typically we "
"call this `w`. This argument then gives read-write access to the various sub-"
"fields within this register, as defined by the manufacturer's SVD file for "
"this chip. Again, you can find all the functions available on the 'w' for "
"this particular register, in this particular peripheral, on this particular "
"chip, in the [tm4c123x documentation](https://docs.rs/tm4c123x/0.7.0/"
"tm4c123x/pwm0/ctl/struct.W.html). Note that all of the sub-fields that we do "
"not set will be set to a default value for us - any existing content in the "
"register will be lost."
msgstr ""

#: src/start/registers.md:112
msgid "Modifying"
msgstr ""

#: src/start/registers.md:114
msgid ""
"If we wish to change only one particular sub-field in this register and "
"leave the other sub-fields unchanged, we can use the `modify` function. This "
"function takes a closure with two arguments - one for reading and one for "
"writing. Typically we call these `r` and `w` respectively. The `r` argument "
"can be used to inspect the current contents of the register, and the `w` "
"argument can be used to modify the register contents."
msgstr ""

#: src/start/registers.md:120
msgid ""
"The `modify` function really shows the power of closures here. In C, we'd "
"have to read into some temporary value, modify the correct bits and then "
"write the value back. This means there's considerable scope for error:"
msgstr ""

#: src/start/registers.md:128
msgid "// Uh oh! Wrong variable!\n"
msgstr ""

#: src/start/registers.md:135
msgid "Using a HAL crate"
msgstr ""

#: src/start/registers.md:137
msgid ""
"The HAL crate for a chip typically works by implementing a custom Trait for "
"the raw structures exposed by the PAC. Often this trait will define a "
"function called `constrain()` for single peripherals or `split()` for things "
"like GPIO ports with multiple pins. This function will consume the "
"underlying raw peripheral structure and return a new object with a higher-"
"level API. This API may also do things like have the Serial port `new` "
"function require a borrow on some `Clock` structure, which can only be "
"generated by calling the function which configures the PLLs and sets up all "
"the clock frequencies. In this way, it is statically impossible to create a "
"Serial port object without first having configured the clock rates, or for "
"the Serial port object to misconvert the baud rate into clock ticks. Some "
"crates even define special traits for the states each GPIO pin can be in, "
"requiring the user to put a pin into the correct state (say, by selecting "
"the appropriate Alternate Function Mode) before passing the pin into "
"Peripheral. All with no run-time cost!"
msgstr ""

#: src/start/registers.md:139
msgid "Let's see an example:"
msgstr ""

#: src/start/registers.md:158
msgid "// Wrap up the SYSCTL struct into an object with a higher-layer API\n"
msgstr ""

#: src/start/registers.md:160
msgid "// Pick our oscillation settings\n"
msgstr ""

#: src/start/registers.md:165
msgid "// Configure the PLL with those settings\n"
msgstr ""

#: src/start/registers.md:168
msgid ""
"// Wrap up the GPIO_PORTA struct into an object with a higher-layer API.\n"
"    // Note it needs to borrow `sc.power_control` so it can power up the "
"GPIO\n"
"    // peripheral automatically.\n"
msgstr ""

#: src/start/registers.md:173
msgid "// Activate the UART.\n"
msgstr ""

#: src/start/registers.md:176
msgid "// The transmit pin\n"
msgstr ""

#: src/start/registers.md:180
msgid "// The receive pin\n"
msgstr ""

#: src/start/registers.md:184
msgid "// No RTS or CTS required\n"
msgstr ""

#: src/start/registers.md:187
msgid "// The baud rate\n"
msgstr ""

#: src/start/registers.md:189
msgid "// Output handling\n"
msgstr ""

#: src/start/registers.md:191
msgid "// We need the clock rates to calculate the baud rate divisors\n"
msgstr ""

#: src/start/registers.md:193
msgid "// We need this to power up the UART peripheral\n"
msgstr ""

#: src/start/registers.md:198
msgid "\"Hello, World!\\r\\n\""
msgstr ""

#: src/start/panicking.md:1
msgid "Panicking"
msgstr "恐慌處理"

#: src/start/panicking.md:3
msgid ""
"Panicking is a core part of the Rust language. Built-in operations like "
"indexing are runtime checked for memory safety. When out of bounds indexing "
"is attempted this results in a panic."
msgstr ""

#: src/start/panicking.md:7
msgid ""
"In the standard library panicking has a defined behavior: it unwinds the "
"stack of the panicking thread, unless the user opted for aborting the "
"program on panics."
msgstr ""

#: src/start/panicking.md:11
msgid ""
"In programs without standard library, however, the panicking behavior is "
"left undefined. A behavior can be chosen by declaring a `#[panic_handler]` "
"function. This function must appear exactly _once_ in the dependency graph "
"of a program, and must have the following signature: `fn(&PanicInfo) -> !`, "
"where [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo."
"html) is a struct containing information about the location of the panic."
msgstr ""

#: src/start/panicking.md:19
msgid ""
"Given that embedded systems range from user facing to safety critical "
"(cannot crash) there's no one size fits all panicking behavior but there are "
"plenty of commonly used behaviors. These common behaviors have been packaged "
"into crates that define the `#[panic_handler]` function. Some examples "
"include:"
msgstr ""

#: src/start/panicking.md:24
msgid ""
"[`panic-abort`](https://crates.io/crates/panic-abort). A panic causes the "
"abort instruction to be executed."
msgstr ""

#: src/start/panicking.md:25
msgid ""
"[`panic-halt`](https://crates.io/crates/panic-halt). A panic causes the "
"program, or the current thread, to halt by entering an infinite loop."
msgstr ""

#: src/start/panicking.md:27
msgid ""
"[`panic-itm`](https://crates.io/crates/panic-itm). The panicking message is "
"logged using the ITM, an ARM Cortex-M specific peripheral."
msgstr ""

#: src/start/panicking.md:29
msgid ""
"[`panic-semihosting`](https://crates.io/crates/panic-semihosting). The "
"panicking message is logged to the host using the semihosting technique."
msgstr ""

#: src/start/panicking.md:37
msgid ""
"You may be able to find even more crates searching for the [`panic-handler`]"
"(https://crates.io/keywords/panic-handler) keyword on crates.io."
msgstr ""

#: src/start/panicking.md:42
msgid ""
"A program can pick one of these behaviors simply by linking to the "
"corresponding crate. The fact that the panicking behavior is expressed in "
"the source of an application as a single line of code is not only useful as "
"documentation but can also be used to change the panicking behavior "
"according to the compilation profile. For example:"
msgstr ""

#: src/start/panicking.md:51
msgid ""
"// dev profile: easier to debug panics; can put a breakpoint on "
"`rust_begin_unwind`\n"
msgstr ""

#: src/start/panicking.md:55
msgid "// release profile: minimize the binary size of the application\n"
msgstr ""

#: src/start/panicking.md:63
msgid ""
"In this example the crate links to the `panic-halt` crate when built with "
"the dev profile (`cargo build`), but links to the `panic-abort` crate when "
"built with the release profile (`cargo build --release`)."
msgstr ""

#: src/start/panicking.md:67
msgid ""
"The `use panic_abort as _;` form of the `use` statement is used to ensure "
"the `panic_abort` panic handler is included in our final executable while "
"making it clear to the compiler that we won't explicitly use anything from "
"the crate. Without the `as _` rename, the compiler would warn that we have "
"an unused import. Sometimes you might see `extern crate panic_abort` "
"instead, which is an older style used before the 2018 edition of Rust, and "
"should now only be used for \"sysroot\" crates (those distributed with Rust "
"itself) such as `proc_macro`, `alloc`, `std`, and `test`."
msgstr ""

#: src/start/panicking.md:74
msgid "An example"
msgstr ""

#: src/start/panicking.md:76
msgid ""
"Here's an example that tries to index an array beyond its length. The "
"operation results in a panic."
msgstr ""

#: src/start/panicking.md:91
msgid "// out of bounds access\n"
msgstr ""

#: src/start/panicking.md:97
msgid ""
"This example chose the `panic-semihosting` behavior which prints the panic "
"message to the host console using semihosting."
msgstr ""

#: src/start/panicking.md:106
msgid ""
"You can try changing the behavior to `panic-halt` and confirm that no "
"message is printed in that case."
msgstr ""

#: src/start/qemu.md:1
msgid "QEMU"
msgstr "QEMU"

#: src/start/qemu.md:3
msgid ""
"We'll start writing a program for the [LM3S6965](http://www.ti.com/product/"
"LM3S6965), a Cortex-M3 microcontroller. We have chosen this as our initial "
"target because it [can be emulated](https://wiki.qemu.org/Documentation/"
"Platforms/ARM#Supported_in_qemu-system-arm) using QEMU so you don't need to "
"fiddle with hardware in this section and we can focus on the tooling and the "
"development process."
msgstr ""

#: src/start/qemu.md:10
msgid ""
"**IMPORTANT** We'll use the name \"app\" for the project name in this "
"tutorial. Whenever you see the word \"app\" you should replace it with the "
"name you selected for your project. Or, you could also name your project "
"\"app\" and avoid the substitutions."
msgstr ""

#: src/start/qemu.md:16
msgid "Creating a non standard Rust program"
msgstr ""

#: src/start/qemu.md:18
msgid ""
"We'll use the [`cortex-m-quickstart`](https://github.com/rust-embedded/"
"cortex-m-quickstart) project template to generate a new project from it. The "
"created project will contain a barebone application: a good starting point "
"for a new embedded rust application. In addition, the project will contain "
"an `examples` directory, with several separate applications, highlighting "
"some of the key embedded rust functionality."
msgstr ""

#: src/start/qemu.md:26
msgid "Using `cargo-generate`"
msgstr "使用 `cargo-generate`"

#: src/start/qemu.md:27
msgid "First install cargo-generate"
msgstr "首先安裝 cargo-generate"

#: src/start/qemu.md:31
msgid "Then generate a new project"
msgstr "接著生成新專案"

#: src/start/qemu.md:32
msgid ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"
msgstr ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"

#: src/start/qemu.md:46
msgid "Using `git`"
msgstr "使用 `git`"

#: src/start/qemu.md:48
msgid "Clone the repository"
msgstr ""

#: src/start/qemu.md:50
msgid ""
"```console\n"
"git clone https://github.com/rust-embedded/cortex-m-quickstart app\n"
"cd app\n"
"```"
msgstr ""

#: src/start/qemu.md:55
msgid "And then fill in the placeholders in the `Cargo.toml` file"
msgstr ""

#: src/start/qemu.md:57
msgid ""
"```toml\n"
"[package]\n"
"authors = [\"{{authors}}\"] # \"{{authors}}\" -> \"John Smith\"\n"
"edition = \"2018\"\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"version = \"0.1.0\"\n"
"\n"
"# ..\n"
"\n"
"[[bin]]\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"test = false\n"
"bench = false\n"
"```"
msgstr ""

#: src/start/qemu.md:72
msgid "Using neither"
msgstr ""

#: src/start/qemu.md:74
msgid ""
"Grab the latest snapshot of the `cortex-m-quickstart` template and extract "
"it."
msgstr ""

#: src/start/qemu.md:76
msgid ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/master."
"zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"
msgstr ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/master."
"zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"

#: src/start/qemu.md:83
msgid ""
"Or you can browse to [`cortex-m-quickstart`](https://github.com/rust-"
"embedded/cortex-m-quickstart), click the green \"Clone or download\" button "
"and then click \"Download ZIP\"."
msgstr ""

#: src/start/qemu.md:86
msgid ""
"Then fill in the placeholders in the `Cargo.toml` file as done in the second "
"part of the \"Using `git`\" version."
msgstr ""

#: src/start/qemu.md:89
msgid "Program Overview"
msgstr ""

#: src/start/qemu.md:91
msgid ""
"For convenience here are the most important parts of the source code in `src/"
"main.rs`:"
msgstr ""

#: src/start/qemu.md:104
msgid "// your code goes here\n"
msgstr ""

#: src/start/qemu.md:109
msgid ""
"This program is a bit different from a standard Rust program so let's take a "
"closer look."
msgstr ""

#: src/start/qemu.md:112
msgid ""
"`#![no_std]` indicates that this program will _not_ link to the standard "
"crate, `std`. Instead it will link to its subset: the `core` crate."
msgstr ""

#: src/start/qemu.md:115
msgid ""
"`#![no_main]` indicates that this program won't use the standard `main` "
"interface that most Rust programs use. The main (no pun intended) reason to "
"go with `no_main` is that using the `main` interface in `no_std` context "
"requires nightly."
msgstr ""

#: src/start/qemu.md:120
msgid ""
"`use panic_halt as _;`. This crate provides a `panic_handler` that defines "
"the panicking behavior of the program. We will cover this in more detail in "
"the [Panicking](panicking.md) chapter of the book."
msgstr ""

#: src/start/qemu.md:124
msgid ""
"[`#[entry]`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/"
"attr.entry.html) is an attribute provided by the [`cortex-m-rt`](https://"
"crates.io/crates/cortex-m-rt) crate that's used to mark the entry point of "
"the program. As we are not using the standard `main` interface we need "
"another way to indicate the entry point of the program and that'd be "
"`#[entry]`."
msgstr ""

#: src/start/qemu.md:132
msgid ""
"`fn main() -> !`. Our program will be the _only_ process running on the "
"target hardware so we don't want it to end! We use a [divergent function]"
"(https://doc.rust-lang.org/rust-by-example/fn/diverging.html) (the `-> !` "
"bit in the function signature) to ensure at compile time that'll be the case."
msgstr ""

#: src/start/qemu.md:136
msgid "Cross compiling"
msgstr "交叉編譯"

#: src/start/qemu.md:138
msgid ""
"The next step is to _cross_ compile the program for the Cortex-M3 "
"architecture. That's as simple as running `cargo build --target $TRIPLE` if "
"you know what the compilation target (`$TRIPLE`) should be. Luckily, the `."
"cargo/config.toml` in the template has the answer:"
msgstr ""

#: src/start/qemu.md:147
msgid ""
"```toml\n"
"[build]\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"# target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""

#: src/start/qemu.md:156
msgid ""
"To cross compile for the Cortex-M3 architecture we have to use `thumbv7m-"
"none-eabi`. That target is not automatically installed when installing the "
"Rust toolchain, it would now be a good time to add that target to the "
"toolchain, if you haven't done it yet:"
msgstr ""

#: src/start/qemu.md:163
msgid ""
"Since the `thumbv7m-none-eabi` compilation target has been set as the "
"default in your `.cargo/config.toml` file, the two commands below do the "
"same:"
msgstr ""

#: src/start/qemu.md:171
msgid "Inspecting"
msgstr ""

#: src/start/qemu.md:173
msgid ""
"Now we have a non-native ELF binary in `target/thumbv7m-none-eabi/debug/"
"app`. We can inspect it using `cargo-binutils`."
msgstr ""

#: src/start/qemu.md:176
msgid ""
"With `cargo-readobj` we can print the ELF headers to confirm that this is an "
"ARM binary."
msgstr ""

#: src/start/qemu.md:183
msgid "Note that:"
msgstr ""

#: src/start/qemu.md:184
msgid ""
"`--bin app` is sugar for inspect the binary at `target/$TRIPLE/debug/app`"
msgstr ""

#: src/start/qemu.md:185
msgid "`--bin app` will also (re)compile the binary, if necessary"
msgstr ""

#: src/start/qemu.md:211
msgid "`cargo-size` can print the size of the linker sections of the binary."
msgstr ""

#: src/start/qemu.md:217
msgid "we use `--release` to inspect the optimized version"
msgstr ""

#: src/start/qemu.md:241
msgid "A refresher on ELF linker sections"
msgstr ""

#: src/start/qemu.md:243
msgid "`.text` contains the program instructions"
msgstr ""

#: src/start/qemu.md:244
msgid "`.rodata` contains constant values like strings"
msgstr ""

#: src/start/qemu.md:245
msgid ""
"`.data` contains statically allocated variables whose initial values are "
"_not_ zero"
msgstr ""

#: src/start/qemu.md:247
msgid ""
"`.bss` also contains statically allocated variables whose initial values "
"_are_ zero"
msgstr ""

#: src/start/qemu.md:249
msgid ""
"`.vector_table` is a _non_\\-standard section that we use to store the "
"vector (interrupt) table"
msgstr ""

#: src/start/qemu.md:251
msgid ""
"`.ARM.attributes` and the `.debug_*` sections contain metadata and will "
"_not_ be loaded onto the target when flashing the binary."
msgstr ""

#: src/start/qemu.md:254
msgid ""
"**IMPORTANT**: ELF files contain metadata like debug information so their "
"_size on disk_ does _not_ accurately reflect the space the program will "
"occupy when flashed on a device. _Always_ use `cargo-size` to check how big "
"a binary really is."
msgstr ""

#: src/start/qemu.md:259
msgid "`cargo-objdump` can be used to disassemble the binary."
msgstr ""

#: src/start/qemu.md:265
msgid ""
"**NOTE** if the above command complains about `Unknown command line "
"argument` see the following bug report: https://github.com/rust-embedded/"
"book/issues/269"
msgstr ""

#: src/start/qemu.md:268
msgid ""
"**NOTE** this output can differ on your system. New versions of rustc, LLVM "
"and libraries can generate different assembly. We truncated some of the "
"instructions to keep the snippet small."
msgstr ""

#: src/start/qemu.md:311
msgid "Running"
msgstr ""

#: src/start/qemu.md:313
msgid ""
"Next, let's see how to run an embedded program on QEMU! This time we'll use "
"the `hello` example which actually does something."
msgstr ""

#: src/start/qemu.md:316
msgid "For convenience here's the source code of `examples/hello.rs`:"
msgstr ""

#: src/start/qemu.md:319
msgid "//! Prints \"Hello, world!\" on the host console using semihosting\n"
msgstr ""

#: src/start/qemu.md:333
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
msgstr ""

#: src/start/qemu.md:341
msgid ""
"This program uses something called semihosting to print text to the _host_ "
"console. When using real hardware this requires a debug session but when "
"using QEMU this Just Works."
msgstr ""

#: src/start/qemu.md:345
msgid "Let's start by compiling the example:"
msgstr ""

#: src/start/qemu.md:351
msgid ""
"The output binary will be located at `target/thumbv7m-none-eabi/debug/"
"examples/hello`."
msgstr ""

#: src/start/qemu.md:354
msgid "To run this binary on QEMU run the following command:"
msgstr ""

#: src/start/qemu.md:369
msgid ""
"The command should successfully exit (exit code = 0) after printing the "
"text. On \\*nix you can check that with the following command:"
msgstr ""

#: src/start/qemu.md:380
msgid "Let's break down that QEMU command:"
msgstr ""

#: src/start/qemu.md:382
msgid ""
"`qemu-system-arm`. This is the QEMU emulator. There are a few variants of "
"these QEMU binaries; this one does full _system_ emulation of _ARM_ machines "
"hence the name."
msgstr ""

#: src/start/qemu.md:386
msgid ""
"`-cpu cortex-m3`. This tells QEMU to emulate a Cortex-M3 CPU. Specifying the "
"CPU model lets us catch some miscompilation errors: for example, running a "
"program compiled for the Cortex-M4F, which has a hardware FPU, will make "
"QEMU error during its execution."
msgstr ""

#: src/start/qemu.md:391
msgid ""
"`-machine lm3s6965evb`. This tells QEMU to emulate the LM3S6965EVB, an "
"evaluation board that contains a LM3S6965 microcontroller."
msgstr ""

#: src/start/qemu.md:394
msgid "`-nographic`. This tells QEMU to not launch its GUI."
msgstr ""

#: src/start/qemu.md:396
msgid ""
"`-semihosting-config (..)`. This tells QEMU to enable semihosting. "
"Semihosting lets the emulated device, among other things, use the host "
"stdout, stderr and stdin and create files on the host."
msgstr ""

#: src/start/qemu.md:400
msgid ""
"`-kernel $file`. This tells QEMU which binary to load and run on the "
"emulated machine."
msgstr ""

#: src/start/qemu.md:403
msgid ""
"Typing out that long QEMU command is too much work! We can set a custom "
"runner to simplify the process. `.cargo/config.toml` has a commented out "
"runner that invokes QEMU; let's uncomment it:"
msgstr ""

#: src/start/qemu.md:411
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -"
"semihosting-config enable=on,target=native -kernel\"\n"
"```"
msgstr ""

#: src/start/qemu.md:417
msgid ""
"This runner only applies to the `thumbv7m-none-eabi` target, which is our "
"default compilation target. Now `cargo run` will compile the program and run "
"it on QEMU:"
msgstr ""

#: src/start/qemu.md:425
msgid ""
"```text\n"
"   Compiling app v0.1.0 (file:///tmp/app)\n"
"    Finished release [optimized + debuginfo] target(s) in 0.26s\n"
"     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel target/thumbv7m-none-"
"eabi/release/examples/hello`\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/start/qemu.md:434
msgid "Debugging is critical to embedded development. Let's see how it's done."
msgstr ""

#: src/start/qemu.md:436
msgid ""
"Debugging an embedded device involves _remote_ debugging as the program that "
"we want to debug won't be running on the machine that's running the debugger "
"program (GDB or LLDB)."
msgstr ""

#: src/start/qemu.md:440
msgid ""
"Remote debugging involves a client and a server. In a QEMU setup, the client "
"will be a GDB (or LLDB) process and the server will be the QEMU process "
"that's also running the embedded program."
msgstr ""

#: src/start/qemu.md:444
msgid "In this section we'll use the `hello` example we already compiled."
msgstr ""

#: src/start/qemu.md:446
msgid "The first debugging step is to launch QEMU in debugging mode:"
msgstr ""

#: src/start/qemu.md:459
msgid ""
"This command won't print anything to the console and will block the "
"terminal. We have passed two extra flags this time:"
msgstr ""

#: src/start/qemu.md:462
msgid ""
"`-gdb tcp::3333`. This tells QEMU to wait for a GDB connection on TCP port "
"3333."
msgstr ""

#: src/start/qemu.md:465
msgid ""
"`-S`. This tells QEMU to freeze the machine at startup. Without this the "
"program would have reached the end of main before we had a chance to launch "
"the debugger!"
msgstr ""

#: src/start/qemu.md:469
msgid ""
"Next we launch GDB in another terminal and tell it to load the debug symbols "
"of the example:"
msgstr ""

#: src/start/qemu.md:476
msgid ""
"**NOTE**: you might need another version of gdb instead of `gdb-multiarch` "
"depending on which one you installed in the installation chapter. This could "
"also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""

#: src/start/qemu.md:480
msgid ""
"Then within the GDB shell we connect to QEMU, which is waiting for a "
"connection on TCP port 3333."
msgstr ""

#: src/start/qemu.md:487
msgid ""
"```text\n"
"Remote debugging using :3333\n"
"Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473\n"
"473     pub unsafe extern \"C\" fn Reset() -> ! {\n"
"```"
msgstr ""

#: src/start/qemu.md:494
msgid ""
"You'll see that the process is halted and that the program counter is "
"pointing to a function named `Reset`. That is the reset handler: what Cortex-"
"M cores execute upon booting."
msgstr ""

#: src/start/qemu.md:498
msgid ""
"Note that on some setup, instead of displaying the line `Reset () at "
"$REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473` as shown above, gdb may print "
"some warnings like :"
msgstr ""

#: src/start/qemu.md:500
msgid ""
"`core::num::bignum::Big32x40::mul_small () at src/libcore/num/bignum.rs:254` "
"`    src/libcore/num/bignum.rs: No such file or directory.`"
msgstr ""

#: src/start/qemu.md:503
msgid ""
"That's a known glitch. You can safely ignore those warnings, you're most "
"likely at Reset()."
msgstr ""

#: src/start/qemu.md:506
msgid ""
"This reset handler will eventually call our main function. Let's skip all "
"the way there using a breakpoint and the `continue` command. To set the "
"breakpoint, let's first take a look where we would like to break in our "
"code, with the `list` command."
msgstr ""

#: src/start/qemu.md:512
msgid "This will show the source code, from the file examples/hello.rs."
msgstr ""

#: src/start/qemu.md:514
msgid ""
"```text\n"
"6       use panic_halt as _;\n"
"7\n"
"8       use cortex_m_rt::entry;\n"
"9       use cortex_m_semihosting::{debug, hprintln};\n"
"10\n"
"11      #[entry]\n"
"12      fn main() -> ! {\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"14\n"
"15          // exit QEMU\n"
"```"
msgstr ""

#: src/start/qemu.md:526
msgid ""
"We would like to add a breakpoint just before the \"Hello, world!\", which "
"is on line 13. We do that with the `break` command:"
msgstr ""

#: src/start/qemu.md:531
msgid ""
"We can now instruct gdb to run up to our main function, with the `continue` "
"command:"
msgstr ""

#: src/start/qemu.md:537
msgid ""
"```text\n"
"Continuing.\n"
"\n"
"Breakpoint 1, hello::__cortex_m_rt_main () at examples\\hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""
"```text\n"
"Continuing.\n"
"\n"
"Breakpoint 1, hello::__cortex_m_rt_main () at examples\\hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"

#: src/start/qemu.md:544
msgid ""
"We are now close to the code that prints \"Hello, world!\". Let's move "
"forward using the `next` command."
msgstr ""

#: src/start/qemu.md:555
msgid ""
"At this point you should see \"Hello, world!\" printed on the terminal "
"that's running `qemu-system-arm`."
msgstr ""

#: src/start/qemu.md:563
msgid "Calling `next` again will terminate the QEMU process."
msgstr ""

#: src/start/qemu.md:573
msgid "You can now exit the GDB session."
msgstr ""

#: src/start/semihosting.md:1
msgid "Semihosting"
msgstr "半主機"

#: src/start/semihosting.md:3
msgid ""
"Semihosting is a mechanism that lets embedded devices do I/O on the host and "
"is mainly used to log messages to the host console. Semihosting requires a "
"debug session and pretty much nothing else (no extra wires!) so it's super "
"convenient to use. The downside is that it's super slow: each write "
"operation can take several milliseconds depending on the hardware debugger "
"(e.g. ST-Link) you use."
msgstr ""

#: src/start/semihosting.md:9
msgid ""
"The [`cortex-m-semihosting`](https://crates.io/crates/cortex-m-semihosting) "
"crate provides an API to do semihosting operations on Cortex-M devices. The "
"program below is the semihosting version of \"Hello, world!\":"
msgstr ""

#: src/start/semihosting.md:32
msgid ""
"If you run this program on hardware you'll see the \"Hello, world!\" message "
"within the OpenOCD logs."
msgstr ""

#: src/start/semihosting.md:42
msgid "You do need to enable semihosting in OpenOCD from GDB first:"
msgstr ""

#: src/start/semihosting.md:48
msgid ""
"QEMU understands semihosting operations so the above program will also work "
"with `qemu-system-arm` without having to start a debug session. Note that "
"you'll need to pass the `-semihosting-config` flag to QEMU to enable "
"semihosting support; these flags are already included in the `.cargo/config."
"toml` file of the template."
msgstr ""

#: src/start/semihosting.md:61
msgid ""
"There's also an `exit` semihosting operation that can be used to terminate "
"the QEMU process. Important: do **not** use `debug::exit` on hardware; this "
"function can corrupt your OpenOCD session and you will not be able to debug "
"more programs until you restart it."
msgstr ""

#: src/start/semihosting.md:77 src/start/semihosting.md:115
msgid "\"blue\""
msgstr ""

#: src/start/semihosting.md:79 src/start/semihosting.md:117
msgid "\"red\""
msgstr ""

#: src/start/semihosting.md:97
msgid ""
"One last tip: you can set the panicking behavior to `exit(EXIT_FAILURE)`. "
"This will let you write `no_std` run-pass tests that you can run on QEMU."
msgstr ""

#: src/start/semihosting.md:100
msgid ""
"For convenience, the `panic-semihosting` crate has an \"exit\" feature that "
"when enabled invokes `exit(EXIT_FAILURE)` after logging the panic message to "
"the host stderr."
msgstr ""

#: src/start/semihosting.md:108
msgid "// features = [\"exit\"]\n"
msgstr ""

#: src/start/semihosting.md:123
msgid ""
"```text\n"
"$ cargo run\n"
"     Running `qemu-system-arm (..)\n"
"panicked at 'assertion failed: `(left == right)`\n"
"  left: `\"blue\"`,\n"
" right: `\"red\"`', examples/hello.rs:15:5\n"
"\n"
"$ echo $?\n"
"1\n"
"```"
msgstr ""

#: src/start/semihosting.md:134
msgid ""
"**NOTE**: To enable this feature on `panic-semihosting`, edit your `Cargo."
"toml` dependencies section where `panic-semihosting` is specified with:"
msgstr ""

#: src/start/semihosting.md:137
msgid ""
"```toml\n"
"panic-semihosting = { version = \"VERSION\", features = [\"exit\"] }\n"
"```"
msgstr ""

#: src/start/semihosting.md:141
msgid ""
"where `VERSION` is the version desired. For more information on dependencies "
"features check the [`specifying dependencies`](https://doc.rust-lang.org/"
"cargo/reference/specifying-dependencies.html) section of the Cargo book."
msgstr ""

#: src/interoperability/index.md:3
msgid ""
"Interoperability between Rust and C code is always dependent on transforming "
"data between the two languages. For this purpose, there is a dedicated "
"module in the `stdlib` called [`std::ffi`](https://doc.rust-lang.org/std/ffi/"
"index.html)."
msgstr ""

#: src/interoperability/index.md:9
msgid ""
"`std::ffi` provides type definitions for C primitive types, such as `char`, "
"`int`, and `long`. It also provides some utility for converting more complex "
"types such as strings, mapping both `&str` and `String` to C types that are "
"easier and safer to handle."
msgstr ""

#: src/interoperability/index.md:15
msgid ""
"As of Rust 1.30, functionalities of `std::ffi` are available in either "
"`core::ffi` or `alloc::ffi` depending on whether or not memory allocation is "
"involved. The [`cty`](https://crates.io/crates/cty) crate and the "
"[`cstr_core`](https://crates.io/crates/cstr_core) crate also offer similar "
"functionalities."
msgstr ""

#: src/interoperability/index.md:25
msgid "Rust type"
msgstr ""

#: src/interoperability/index.md:25
msgid "Intermediate"
msgstr ""

#: src/interoperability/index.md:25
msgid "C type"
msgstr ""

#: src/interoperability/index.md:27
msgid "`String`"
msgstr ""

#: src/interoperability/index.md:27
msgid "`CString`"
msgstr ""

#: src/interoperability/index.md:27
msgid "`char *`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`&str`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`CStr`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`const char *`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`()`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`c_void`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`void`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`u32` or `u64`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`c_uint`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`unsigned int`"
msgstr ""

#: src/interoperability/index.md:31
msgid "etc"
msgstr ""

#: src/interoperability/index.md:31
msgid "..."
msgstr ""

#: src/interoperability/index.md:33
msgid ""
"A value of a C primitive type can be used as one of the corresponding Rust "
"type and vice versa, since the former is simply a type alias of the latter. "
"For example, the following code compiles on platforms where `unsigned int` "
"is 32-bit long."
msgstr ""

#: src/interoperability/index.md:46
msgid "Interoperability with other build systems"
msgstr ""

#: src/interoperability/index.md:48
msgid ""
"A common requirement for including Rust in your embedded project is "
"combining Cargo with your existing build system, such as make or cmake."
msgstr ""

#: src/interoperability/index.md:51
msgid ""
"We are collecting examples and use cases for this on our issue tracker in "
"[issue #61](https://github.com/rust-embedded/book/issues/61)."
msgstr ""

#: src/interoperability/index.md:56
msgid "Interoperability with RTOSs"
msgstr ""

#: src/interoperability/index.md:58
msgid ""
"Integrating Rust with an RTOS such as FreeRTOS or ChibiOS is still a work in "
"progress; especially calling RTOS functions from Rust can be tricky."
msgstr ""

#: src/interoperability/index.md:61
msgid ""
"We are collecting examples and use cases for this on our issue tracker in "
"[issue #62](https://github.com/rust-embedded/book/issues/62)."
msgstr ""

#: src/SUMMARY.md:52
msgid "A little C with your Rust"
msgstr "在 Rust 中用點 C"

#: src/interoperability/c-with-rust.md:3
msgid "Using C or C++ inside of a Rust project consists of two major parts:"
msgstr ""

#: src/interoperability/c-with-rust.md:5
msgid "Wrapping the exposed C API for use with Rust"
msgstr ""

#: src/interoperability/c-with-rust.md:6
msgid "Building your C or C++ code to be integrated with the Rust code"
msgstr ""

#: src/interoperability/c-with-rust.md:8
msgid ""
"As C++ does not have a stable ABI for the Rust compiler to target, it is "
"recommended to use the `C` ABI when combining Rust with C or C++."
msgstr ""

#: src/interoperability/c-with-rust.md:10
msgid "Defining the interface"
msgstr ""

#: src/interoperability/c-with-rust.md:12
msgid ""
"Before consuming C or C++ code from Rust, it is necessary to define (in "
"Rust) what data types and function signatures exist in the linked code. In C "
"or C++, you would include a header (`.h` or `.hpp`) file which defines this "
"data. In Rust, it is necessary to either manually translate these "
"definitions to Rust, or use a tool to generate these definitions."
msgstr ""

#: src/interoperability/c-with-rust.md:14
msgid ""
"First, we will cover manually translating these definitions from C/C++ to "
"Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:16
msgid "Wrapping C functions and Datatypes"
msgstr ""

#: src/interoperability/c-with-rust.md:18
msgid ""
"Typically, libraries written in C or C++ will provide a header file defining "
"all types and functions used in public interfaces. An example file may look "
"like this:"
msgstr ""

#: src/interoperability/c-with-rust.md:21
msgid "/* File: cool.h */"
msgstr ""

#: src/interoperability/c-with-rust.md:30
msgid "When translated to Rust, this interface would look as such:"
msgstr ""

#: src/interoperability/c-with-rust.md:33
msgid "/* File: cool_bindings.rs */"
msgstr ""

#: src/interoperability/c-with-rust.md:40
#: src/interoperability/c-with-rust.md:66
msgid "\"C\""
msgstr ""

#: src/interoperability/c-with-rust.md:49
msgid ""
"Let's take a look at this definition one piece at a time, to explain each of "
"the parts."
msgstr ""

#: src/interoperability/c-with-rust.md:56
msgid ""
"By default, Rust does not guarantee order, padding, or the size of data "
"included in a `struct`. In order to guarantee compatibility with C code, we "
"include the `#[repr(C)]` attribute, which instructs the Rust compiler to "
"always use the same rules C does for organizing data within a struct."
msgstr ""

#: src/interoperability/c-with-rust.md:63
msgid ""
"Due to the flexibility of how C or C++ defines an `int` or `char`, it is "
"recommended to use primitive data types defined in `cty`, which will map "
"types from C to types in Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:69
msgid ""
"This statement defines the signature of a function that uses the C ABI, "
"called `cool_function`. By defining the signature without defining the body "
"of the function, the definition of this function will need to be provided "
"elsewhere, or linked into the final library or binary from a static library."
msgstr ""

#: src/interoperability/c-with-rust.md:77
msgid ""
"Similar to our datatype above, we define the datatypes of the function "
"arguments using C-compatible definitions. We also retain the same argument "
"names, for clarity."
msgstr ""

#: src/interoperability/c-with-rust.md:79
msgid ""
"We have one new type here, `*mut CoolStruct`. As C does not have a concept "
"of Rust's references, which would look like this: `&mut CoolStruct`, we "
"instead have a raw pointer. As dereferencing this pointer is `unsafe`, and "
"the pointer may in fact be a `null` pointer, care must be taken to ensure "
"the guarantees typical of Rust when interacting with C or C++ code."
msgstr ""

#: src/interoperability/c-with-rust.md:81
msgid "Automatically generating the interface"
msgstr ""

#: src/interoperability/c-with-rust.md:83
msgid ""
"Rather than manually generating these interfaces, which may be tedious and "
"error prone, there is a tool called [bindgen](https://github.com/rust-lang/"
"rust-bindgen) which will perform these conversions automatically. For "
"instructions of the usage of [bindgen](https://github.com/rust-lang/rust-"
"bindgen), please refer to the [bindgen user's manual](https://rust-lang."
"github.io/rust-bindgen/), however the typical process consists of the "
"following:"
msgstr ""

#: src/interoperability/c-with-rust.md:85
msgid ""
"Gather all C or C++ headers defining interfaces or datatypes you would like "
"to use with Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:86
msgid ""
"Write a `bindings.h` file, which `#include \"...\"`'s each of the files you "
"gathered in step one."
msgstr ""

#: src/interoperability/c-with-rust.md:87
msgid ""
"Feed this `bindings.h` file, along with any compilation flags used to "
"compile your code into `bindgen`. Tip: use `Builder."
"ctypes_prefix(\"cty\")` / `--ctypes-prefix=cty` and `Builder.use_core()` / "
"`--use-core` to make the generated code `#![no_std]` compatible."
msgstr ""

#: src/interoperability/c-with-rust.md:90
msgid ""
"`bindgen` will produce the generated Rust code to the output of the terminal "
"window. This output may be piped to a file in your project, such as "
"`bindings.rs`. You may use this file in your Rust project to interact with C/"
"C++ code compiled and linked as an external library. Tip: don't forget to "
"use the [`cty`](https://crates.io/crates/cty) crate if your types in the "
"generated bindings are prefixed with `cty`."
msgstr ""

#: src/interoperability/c-with-rust.md:95
msgid "Building your C/C++ code"
msgstr "建置您的 C/C++ 程式碼"

#: src/interoperability/c-with-rust.md:97
msgid ""
"As the Rust compiler does not directly know how to compile C or C++ code (or "
"code from any other language, which presents a C interface), it is necessary "
"to compile your non-Rust code ahead of time."
msgstr ""

#: src/interoperability/c-with-rust.md:99
msgid ""
"For embedded projects, this most commonly means compiling the C/C++ code to "
"a static archive (such as `cool-library.a`), which can then be combined with "
"your Rust code at the final linking step."
msgstr ""

#: src/interoperability/c-with-rust.md:101
msgid ""
"If the library you would like to use is already distributed as a static "
"archive, it is not necessary to rebuild your code. Just convert the provided "
"interface header file as described above, and include the static archive at "
"compile/link time."
msgstr ""

#: src/interoperability/c-with-rust.md:103
msgid ""
"If your code exists as a source project, it will be necessary to compile "
"your C/C++ code to a static library, either by triggering your existing "
"build system (such as `make`, `CMake`, etc.), or by porting the necessary "
"compilation steps to use a tool called the `cc` crate. For both of these "
"steps, it is necessary to use a `build.rs` script."
msgstr ""

#: src/interoperability/c-with-rust.md:105
msgid "Rust `build.rs` build scripts"
msgstr ""

#: src/interoperability/c-with-rust.md:107
msgid ""
"A `build.rs` script is a file written in Rust syntax, that is executed on "
"your compilation machine, AFTER dependencies of your project have been "
"built, but BEFORE your project is built."
msgstr ""

#: src/interoperability/c-with-rust.md:109
msgid ""
"The full reference may be found [here](https://doc.rust-lang.org/cargo/"
"reference/build-scripts.html). `build.rs` scripts are useful for generating "
"code (such as via [bindgen](https://github.com/rust-lang/rust-bindgen)), "
"calling out to external build systems such as `Make`, or directly compiling "
"C/C++ through use of the `cc` crate."
msgstr ""

#: src/interoperability/c-with-rust.md:111
msgid "Triggering external build systems"
msgstr ""

#: src/interoperability/c-with-rust.md:113
msgid ""
"For projects with complex external projects or build systems, it may be "
"easiest to use [`std::process::Command`](https://doc.rust-lang.org/std/"
"process/struct.Command.html) to \"shell out\" to your other build systems by "
"traversing relative paths, calling a fixed command (such as `make library`), "
"and then copying the resulting static library to the proper location in the "
"`target` build directory."
msgstr ""

#: src/interoperability/c-with-rust.md:115
msgid ""
"While your crate may be targeting a `no_std` embedded platform, your `build."
"rs` executes only on machines compiling your crate. This means you may use "
"any Rust crates which will run on your compilation host."
msgstr ""

#: src/interoperability/c-with-rust.md:119
msgid "Building C/C++ code with the `cc` crate"
msgstr ""

#: src/interoperability/c-with-rust.md:121
msgid ""
"For projects with limited dependencies or complexity, or for projects where "
"it is difficult to modify the build system to produce a static library "
"(rather than a final binary or executable), it may be easier to instead "
"utilize the [`cc` crate](https://github.com/alexcrichton/cc-rs), which "
"provides an idiomatic Rust interface to the compiler provided by the host."
msgstr ""

#: src/interoperability/c-with-rust.md:125
msgid ""
"In the simplest case of compiling a single C file as a dependency to a "
"static library, an example `build.rs` script using the [`cc` crate](https://"
"github.com/alexcrichton/cc-rs) would look like this:"
msgstr ""

#: src/interoperability/c-with-rust.md:130
msgid "\"src/foo.c\""
msgstr ""

#: src/interoperability/c-with-rust.md:131
msgid "\"foo\""
msgstr ""

#: src/interoperability/c-with-rust.md:135
msgid ""
"The `build.rs` is placed at the root of the package. Then `cargo build` will "
"compile and execute it before the build of the package. A static archive "
"named `libfoo.a` is generated and placed in the `target` directory."
msgstr ""

#: src/interoperability/rust-with-c.md:1
msgid "A little Rust with your C"
msgstr "在 C 中用點 Rust"

#: src/interoperability/rust-with-c.md:3
msgid "Using Rust code inside a C or C++ project mostly consists of two parts."
msgstr ""

#: src/interoperability/rust-with-c.md:5
msgid "Creating a C-friendly API in Rust"
msgstr ""

#: src/interoperability/rust-with-c.md:6
msgid "Embedding your Rust project into an external build system"
msgstr ""

#: src/interoperability/rust-with-c.md:8
msgid ""
"Apart from `cargo` and `meson`, most build systems don't have native Rust "
"support. So you're most likely best off just using `cargo` for compiling "
"your crate and any dependencies."
msgstr ""

#: src/interoperability/rust-with-c.md:12
msgid "Setting up a project"
msgstr ""

#: src/interoperability/rust-with-c.md:14
msgid "Create a new `cargo` project as usual."
msgstr ""

#: src/interoperability/rust-with-c.md:16
msgid ""
"There are flags to tell `cargo` to emit a systems library, instead of its "
"regular rust target. This also allows you to set a different output name for "
"your library, if you want it to differ from the rest of your crate."
msgstr ""

#: src/interoperability/rust-with-c.md:21
msgid ""
"```toml\n"
"[lib]\n"
"name = \"your_crate\"\n"
"crate-type = [\"cdylib\"]      # Creates dynamic lib\n"
"# crate-type = [\"staticlib\"] # Creates static lib\n"
"```"
msgstr ""

#: src/interoperability/rust-with-c.md:28
msgid "Building a `C` API"
msgstr ""

#: src/interoperability/rust-with-c.md:30
msgid ""
"Because C++ has no stable ABI for the Rust compiler to target, we use `C` "
"for any interoperability between different languages. This is no exception "
"when using Rust inside of C and C++ code."
msgstr ""

#: src/interoperability/rust-with-c.md:34
msgid "`#[no_mangle]`"
msgstr ""

#: src/interoperability/rust-with-c.md:36
msgid ""
"The Rust compiler mangles symbol names differently than native code linkers "
"expect. As such, any function that Rust exports to be used outside of Rust "
"needs to be told not to be mangled by the compiler."
msgstr ""

#: src/interoperability/rust-with-c.md:40
msgid "`extern \"C\"`"
msgstr ""

#: src/interoperability/rust-with-c.md:42
msgid ""
"By default, any function you write in Rust will use the Rust ABI (which is "
"also not stabilized). Instead, when building outwards facing FFI APIs we "
"need to tell the compiler to use the system ABI."
msgstr ""

#: src/interoperability/rust-with-c.md:47
msgid ""
"Depending on your platform, you might want to target a specific ABI version, "
"which are documented [here](https://doc.rust-lang.org/reference/items/"
"external-blocks.html)."
msgstr ""

#: src/interoperability/rust-with-c.md:52
msgid ""
"Putting these parts together, you get a function that looks roughly like "
"this."
msgstr ""

#: src/interoperability/rust-with-c.md:61
msgid ""
"Just as when using `C` code in your Rust project you now need to transform "
"data from and to a form that the rest of the application will understand."
msgstr ""

#: src/interoperability/rust-with-c.md:64
msgid "Linking and greater project context."
msgstr ""

#: src/interoperability/rust-with-c.md:66
msgid ""
"So then, that's one half of the problem solved. How do you use this now?"
msgstr ""

#: src/interoperability/rust-with-c.md:69
msgid "**This very much depends on your project and/or build system**"
msgstr ""

#: src/interoperability/rust-with-c.md:71
msgid ""
"`cargo` will create a `my_lib.so`/`my_lib.dll` or `my_lib.a` file, depending "
"on your platform and settings. This library can simply be linked by your "
"build system."
msgstr ""

#: src/interoperability/rust-with-c.md:75
msgid ""
"However, calling a Rust function from C requires a header file to declare "
"the function signatures."
msgstr ""

#: src/interoperability/rust-with-c.md:78
msgid ""
"Every function in your Rust-ffi API needs to have a corresponding header "
"function."
msgstr ""

#: src/interoperability/rust-with-c.md:85
msgid "would then become"
msgstr ""

#: src/interoperability/rust-with-c.md:91
msgid "etc."
msgstr ""

#: src/interoperability/rust-with-c.md:93
msgid ""
"There is a tool to automate this process, called [cbindgen](https://github."
"com/eqrion/cbindgen) which analyses your Rust code and then generates "
"headers for your C and C++ projects from it."
msgstr ""

#: src/interoperability/rust-with-c.md:99
msgid ""
"At this point, using the Rust functions from C is as simple as including the "
"header and calling them!"
msgstr ""

#: src/interoperability/rust-with-c.md:103
msgid "\"my-rust-project.h\""
msgstr ""

#: src/intro/index.md:1
msgid "Introduction"
msgstr "介紹"

#: src/intro/index.md:3
msgid ""
"Welcome to The Embedded Rust Book: An introductory book about using the Rust "
"Programming Language on \"Bare Metal\" embedded systems, such as "
"Microcontrollers."
msgstr ""
"歡迎來到《嵌入式 Rust 手冊》：一本介紹如何在「裸機」嵌入式系統（如微控制器）"
"上使用 Rust 程式語言的入門書。"

#: src/intro/index.md:6
msgid "Who Embedded Rust is For"
msgstr "嵌入式 Rust 的適用對象"

#: src/intro/index.md:7
msgid ""
"Embedded Rust is for everyone who wants to do embedded programming while "
"taking advantage of the higher-level concepts and safety guarantees the Rust "
"language provides. (See also [Who Rust Is For](https://doc.rust-lang.org/"
"book/ch00-00-introduction.html))"
msgstr ""
"嵌入式 Rust 適合想進行嵌入式開發、同時享受 Rust 語言提供的高階概念與安全保證"
"的人。（另見 [Rust 的適用對象](https://doc.rust-lang.org/book/ch00-00-"
"introduction.html)）"

#: src/intro/index.md:10
msgid "Scope"
msgstr "範疇"

#: src/intro/index.md:12
msgid "The goals of this book are:"
msgstr "本書的目標是："

#: src/intro/index.md:14
msgid ""
"Get developers up to speed with embedded Rust development. i.e. How to set "
"up a development environment."
msgstr "讓開發者快速上手嵌入式 Rust 開發。例如：如何設定開發環境。"

#: src/intro/index.md:17
msgid ""
"Share _current_ best practices about using Rust for embedded development. i."
"e. How to best use Rust language features to write more correct embedded "
"software."
msgstr ""
"分享使用 Rust 進行嵌入式開發的_當前_最佳實務。例如：如何善用 Rust 語言特性來"
"寫出更正確的嵌入式軟體。"

#: src/intro/index.md:21
msgid ""
"Serve as a cookbook in some cases. e.g. How do I mix C and Rust in a single "
"project?"
msgstr "在某些情況下作為食譜。例如：如何在單一專案中混用 C 與 Rust？"

#: src/intro/index.md:24
msgid ""
"This book tries to be as general as possible but to make things easier for "
"both the readers and the writers it uses the ARM Cortex-M architecture in "
"all its examples. However, the book doesn't assume that the reader is "
"familiar with this particular architecture and explains details particular "
"to this architecture where required."
msgstr ""
"本書力求通用，但為了讓讀者與作者更容易上手，所有範例都採用 ARM Cortex-M 架"
"構。不過，本書不假設讀者熟悉該架構，並在需要時解釋其特定細節。"

#: src/intro/index.md:30
msgid "Who This Book is For"
msgstr "本書的讀者"

#: src/intro/index.md:31
msgid ""
"This book caters towards people with either some embedded background or some "
"Rust background, however we believe everybody curious about embedded Rust "
"programming can get something out of this book. For those without any prior "
"knowledge we suggest you read the \"Assumptions and Prerequisites\" section "
"and catch up on missing knowledge to get more out of the book and improve "
"your reading experience. You can check out the \"Other Resources\" section "
"to find resources on topics you might want to catch up on."
msgstr ""
"本書面向具備嵌入式或 Rust 背景的人，但我們相信所有對嵌入式 Rust 感到好奇的人"
"都能從本書中有所收穫。若你沒有相關先備知識，我們建議先閱讀「假設與先備條件」"
"章節並補足不足，讓你從本書獲益更多並提升閱讀體驗。你也可查看「其他資源」章"
"節，尋找你想補充的主題。"

#: src/intro/index.md:37
msgid "Assumptions and Prerequisites"
msgstr "假設與先備條件"

#: src/intro/index.md:39
msgid ""
"You are comfortable using the Rust Programming Language, and have written, "
"run, and debugged Rust applications on a desktop environment. You should "
"also be familiar with the idioms of the [2018 edition](https://doc.rust-lang."
"org/edition-guide/) as this book targets Rust 2018."
msgstr ""
"你已能熟練使用 Rust 程式語言，並在桌面環境撰寫、執行與除錯 Rust 應用程式。你"
"也應熟悉 [2018 edition](https://doc.rust-lang.org/edition-guide/) 的慣例，因"
"為本書以 Rust 2018 為目標。"

#: src/intro/index.md:46
msgid ""
"You are comfortable developing and debugging embedded systems in another "
"language such as C, C++, or Ada, and are familiar with concepts such as:"
msgstr ""
"你能以 C、C++ 或 Ada 等其他語言進行嵌入式系統開發與除錯，並熟悉以下概念："

#: src/intro/index.md:48
msgid "Cross Compilation"
msgstr "交叉編譯"

#: src/intro/index.md:49
msgid "Memory Mapped Peripherals"
msgstr "記憶體對映周邊"

#: src/intro/index.md:51
msgid "Common interfaces such as I2C, SPI, Serial, etc."
msgstr "I2C、SPI、序列埠等常見介面"

#: src/intro/index.md:53
msgid "Other Resources"
msgstr "其他資源"

#: src/intro/index.md:54
msgid ""
"If you are unfamiliar with anything mentioned above or if you want more "
"information about a specific topic mentioned in this book you might find "
"some of these resources helpful."
msgstr ""
"如果你對上述內容不熟悉，或想了解本書提及的特定主題，以下資源可能會有幫助。"

#: src/intro/index.md:56
msgid "Topic"
msgstr "話題"

#: src/intro/index.md:56
msgid "Resource"
msgstr "資源"

#: src/intro/index.md:56
msgid "Description"
msgstr "描述"

#: src/intro/index.md:58
msgid "Rust"
msgstr ""

#: src/intro/index.md:58
msgid "[Rust Book](https://doc.rust-lang.org/book/)"
msgstr "[Rust 手冊](https://doc.rust-lang.org/book/)"

#: src/intro/index.md:58
msgid ""
"If you are not yet comfortable with Rust, we highly suggest reading this "
"book."
msgstr "若你尚未熟悉 Rust，我們強烈建議先閱讀此書。"

#: src/intro/index.md:59 src/intro/index.md:60 src/intro/index.md:61
#: src/intro/index.md:62 src/intro/index.md:63
msgid "Rust, Embedded"
msgstr "Rust、嵌入式"

#: src/intro/index.md:59
msgid "[Discovery Book](https://docs.rust-embedded.org/discovery/)"
msgstr "[Discovery 手冊](https://docs.rust-embedded.org/discovery/)"

#: src/intro/index.md:59
msgid ""
"If you have never done any embedded programming, this book might be a better "
"start"
msgstr "若你從未做過嵌入式開發，這本書可能是更好的起點"

#: src/intro/index.md:60
msgid "[Embedded Rust Bookshelf](https://docs.rust-embedded.org)"
msgstr ""

#: src/intro/index.md:60
msgid ""
"Here you can find several other resources provided by Rust's Embedded "
"Working Group."
msgstr "在這裡可以找到 Rust 嵌入式工作群提供的其他資源。"

#: src/intro/index.md:61
msgid "[Embedonomicon](https://docs.rust-embedded.org/embedonomicon/)"
msgstr ""

#: src/intro/index.md:61
msgid "The nitty gritty details when doing embedded programming in Rust."
msgstr "使用 Rust 進行嵌入式開發時的繁瑣細節。"

#: src/intro/index.md:62
msgid "[embedded FAQ](https://docs.rust-embedded.org/faq.html)"
msgstr "[嵌入式 FAQ](https://docs.rust-embedded.org/faq.html)"

#: src/intro/index.md:62
msgid "Frequently asked questions about Rust in an embedded context."
msgstr "關於嵌入式情境中的 Rust 常見問題。"

#: src/intro/index.md:63
msgid ""
"[Comprehensive Rust 🦀: Bare Metal](https://google.github.io/comprehensive-"
"rust/bare-metal.html)"
msgstr ""
"[Comprehensive Rust 🦀：裸機](https://google.github.io/comprehensive-rust/"
"bare-metal.html)"

#: src/intro/index.md:63
msgid "Teaching material for a 1-day class on bare-metal Rust development"
msgstr "裸機 Rust 開發 1 日課程的教學教材"

#: src/intro/index.md:64
msgid "[Interrupt](https://en.wikipedia.org/wiki/Interrupt)"
msgstr "[中斷](https://en.wikipedia.org/wiki/Interrupt)"

#: src/intro/index.md:64 src/intro/index.md:65 src/intro/index.md:66
msgid "\\-"
msgstr ""

#: src/intro/index.md:65
msgid "Memory-mapped IO/Peripherals"
msgstr "記憶體對映 I/O/周邊"

#: src/intro/index.md:65
msgid "[Memory-mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O)"
msgstr "[記憶體對映 I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O)"

#: src/intro/index.md:66
msgid "SPI, UART, RS232, USB, I2C, TTL"
msgstr "SPI、UART、RS232、USB、I2C、TTL"

#: src/intro/index.md:66
msgid ""
"[Stack Exchange about SPI, UART, and other interfaces](https://electronics."
"stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-ttl-etc-what-"
"are-all-of-these-and-how-do-th)"
msgstr ""
"[關於 SPI、UART 與其他介面的 Stack Exchange 討論](https://electronics."
"stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-ttl-etc-what-"
"are-all-of-these-and-how-do-th)"

#: src/intro/index.md:68
msgid "Translations"
msgstr "翻譯"

#: src/intro/index.md:70
msgid ""
"This book has been translated by generous volunteers. If you would like your "
"translation listed here, please open a PR to add it."
msgstr "本書由熱心志工翻譯完成。若你希望你的翻譯列在此處，請開 PR 加入。"

#: src/intro/index.md:73
msgid ""
"[Japanese](https://tomoyuki-nakabayashi.github.io/book/) ([repository]"
"(https://github.com/tomoyuki-nakabayashi/book))"
msgstr ""
"[日文](https://tomoyuki-nakabayashi.github.io/book/)（[儲存庫](https://"
"github.com/tomoyuki-nakabayashi/book)）"

#: src/intro/index.md:76
msgid ""
"[Chinese](https://xxchang.github.io/book/) ([repository](https://github.com/"
"XxChang/book))"
msgstr ""
"[中文](https://xxchang.github.io/book/)（[儲存庫](https://github.com/XxChang/"
"book)）"

#: src/intro/index.md:79
msgid "How to Use This Book"
msgstr "如何使用這本手冊"

#: src/intro/index.md:81
msgid ""
"This book generally assumes that you’re reading it front-to-back. Later "
"chapters build on concepts in earlier chapters, and earlier chapters may not "
"dig into details on a topic, revisiting the topic in a later chapter."
msgstr ""
"該手冊一般假設你從前往後閱讀。後續章節會建立在前面章節的概念之上，而前面章節"
"可能不會深入某些話題，並在後續章節再回頭詳述。"

#: src/intro/index.md:85
msgid ""
"This book will be using the [STM32F3DISCOVERY](http://www.st.com/en/"
"evaluation-tools/stm32f3discovery.html) development board from "
"STMicroelectronics for the majority of the examples contained within. This "
"board is based on the ARM Cortex-M architecture, and while basic "
"functionality is the same across most CPUs based on this architecture, "
"peripherals and other implementation details of Microcontrollers are "
"different between different vendors, and often even different between "
"Microcontroller families from the same vendor."
msgstr ""
"本書多數範例會使用 STMicroelectronics 的 [STM32F3DISCOVERY](http://www.st."
"com/en/evaluation-tools/stm32f3discovery.html) 開發板。此開發板基於 ARM "
"Cortex-M 架構，雖然此架構的多數 CPU 基本功能相同，但不同廠商的微控制器周邊與"
"其他實作細節各不相同，甚至同一廠商不同家族也可能不同。"

#: src/intro/index.md:93
msgid ""
"For this reason, we suggest purchasing the [STM32F3DISCOVERY](http://www.st."
"com/en/evaluation-tools/stm32f3discovery.html) development board for the "
"purpose of following the examples in this book."
msgstr ""
"因此，我們建議購買 [STM32F3DISCOVERY](http://www.st.com/en/evaluation-tools/"
"stm32f3discovery.html) 開發板來跟著本書範例操作。"

#: src/intro/index.md:98
msgid "Contributing to This Book"
msgstr "為本書做出貢獻"

#: src/intro/index.md:100
msgid ""
"The work on this book is coordinated in [this repository](https://github.com/"
"rust-embedded/book) and is mainly developed by the [resources team](https://"
"github.com/rust-embedded/wg#the-resources-team)."
msgstr ""
"本書的工作由[此儲存庫](https://github.com/rust-embedded/book) 協調，主要由[資"
"源團隊](https://github.com/rust-embedded/wg#the-resources-team) 開發。"

#: src/intro/index.md:106
msgid ""
"If you have trouble following the instructions in this book or find that "
"some section of the book is not clear enough or hard to follow then that's a "
"bug and it should be reported in [the issue tracker](https://github.com/rust-"
"embedded/book/issues/) of this book."
msgstr ""
"如果你在跟著本書指引時遇到困難，或發現某些章節不夠清楚或難以理解，那就是問"
"題，應在本書的[議題追蹤器](https://github.com/rust-embedded/book/issues/) 回"
"報。"

#: src/intro/index.md:112
msgid "Pull requests fixing typos and adding new content are very welcome!"
msgstr "非常歡迎修正錯字與新增內容的 Pull Request！"

#: src/intro/index.md:114
msgid "Re-using this material"
msgstr "重複使用本資料"

#: src/intro/index.md:116
msgid "This book is distributed under the following licenses:"
msgstr "本書以以下授權條款釋出："

#: src/intro/index.md:118
msgid ""
"The code samples and free-standing Cargo projects contained within this book "
"are licensed under the terms of both the [MIT License](https://opensource."
"org/licenses/MIT) and the [Apache License v2.0](http://www.apache.org/"
"licenses/LICENSE-2.0)."
msgstr ""
"本書包含的程式碼範例與獨立的 Cargo 專案同時採用 [MIT 授權](https://"
"opensource.org/licenses/MIT) 與 [Apache License v2.0](http://www.apache.org/"
"licenses/LICENSE-2.0) 授權。"

#: src/intro/index.md:119
msgid ""
"The written prose, pictures and diagrams contained within this book are "
"licensed under the terms of the Creative Commons [CC-BY-SA v4.0](https://"
"creativecommons.org/licenses/by-sa/4.0/legalcode) license."
msgstr ""
"本書的文字、圖片與圖表採用 Creative Commons [CC-BY-SA v4.0](https://"
"creativecommons.org/licenses/by-sa/4.0/legalcode) 授權。"

#: src/intro/index.md:125
msgid "TL;DR: If you want to use our text or images in your work, you need to:"
msgstr "TL;DR：若你想在作品中使用我們的文字或圖片，你需要："

#: src/intro/index.md:127
msgid ""
"Give the appropriate credit (i.e. mention this book on your slide, and "
"provide a link to the relevant page)"
msgstr "給予適當的引用（例如在投影片中提到本書，並提供相關頁面的連結）"

#: src/intro/index.md:128
msgid ""
"Provide a link to the [CC-BY-SA v4.0](https://creativecommons.org/licenses/"
"by-sa/4.0/legalcode) licence"
msgstr ""
"提供 [CC-BY-SA v4.0](https://creativecommons.org/licenses/by-sa/4.0/"
"legalcode) 授權連結"

#: src/intro/index.md:129
msgid ""
"Indicate if you have changed the material in any way, and make any changes "
"to our material available under the same licence"
msgstr "說明是否對素材做過任何變更，並將你對素材的修改以相同授權釋出"

#: src/intro/index.md:131
msgid "Also, please do let us know if you find this book useful!"
msgstr "如果你覺得本書有幫助，也請務必讓我們知道！"

#: src/intro/hardware.md:1
msgid "Meet Your Hardware"
msgstr ""

#: src/intro/hardware.md:3
msgid "Let's get familiar with the hardware we'll be working with."
msgstr ""

#: src/intro/hardware.md:5
msgid "STM32F3DISCOVERY (the \"F3\")"
msgstr ""

#: src/intro/hardware.md:11
msgid "What does this board contain?"
msgstr ""

#: src/intro/hardware.md:13
msgid ""
"A [STM32F303VCT6](https://www.st.com/en/microcontrollers/stm32f303vc.html) "
"microcontroller. This microcontroller has"
msgstr ""

#: src/intro/hardware.md:14
msgid ""
"A single-core ARM Cortex-M4F processor with hardware support for single-"
"precision floating point operations and a maximum clock frequency of 72 MHz."
msgstr ""

#: src/intro/hardware.md:17
msgid "256 KiB of \"Flash\" memory. (1 KiB = 10**24** bytes)"
msgstr ""

#: src/intro/hardware.md:19
msgid "48 KiB of RAM."
msgstr ""

#: src/intro/hardware.md:21
msgid "A variety of integrated peripherals such as timers, I2C, SPI and USART."
msgstr ""

#: src/intro/hardware.md:23
msgid ""
"General purpose Input Output (GPIO) and other types of pins accessible "
"through the two rows of headers along side the board."
msgstr ""

#: src/intro/hardware.md:25
msgid "A USB interface accessible through the USB port labeled \"USB USER\"."
msgstr ""

#: src/intro/hardware.md:27
msgid ""
"An [accelerometer](https://en.wikipedia.org/wiki/Accelerometer) as part of "
"the [LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"chip."
msgstr ""

#: src/intro/hardware.md:29
msgid ""
"A [magnetometer](https://en.wikipedia.org/wiki/Magnetometer) as part of the "
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) chip."
msgstr ""

#: src/intro/hardware.md:31
msgid ""
"A [gyroscope](https://en.wikipedia.org/wiki/Gyroscope) as part of the "
"[L3GD20](https://www.pololu.com/file/0J563/L3GD20.pdf) chip."
msgstr ""

#: src/intro/hardware.md:33
msgid "8 user LEDs arranged in the shape of a compass."
msgstr ""

#: src/intro/hardware.md:35
msgid ""
"A second microcontroller: a [STM32F103](https://www.st.com/en/"
"microcontrollers/stm32f103cb.html). This microcontroller is actually part of "
"an on-board programmer / debugger and is connected to the USB port named "
"\"USB ST-LINK\"."
msgstr ""

#: src/intro/hardware.md:37
msgid ""
"For a more detailed list of features and further specifications of the board "
"take a look at the [STMicroelectronics](https://www.st.com/en/evaluation-"
"tools/stm32f3discovery.html) website."
msgstr ""

#: src/intro/hardware.md:39
msgid ""
"A word of caution: be careful if you want to apply external signals to the "
"board. The microcontroller STM32F303VCT6 pins take a nominal voltage of 3.3 "
"volts. For further information consult the [6.2 Absolute maximum ratings "
"section in the manual](https://www.st.com/resource/en/datasheet/stm32f303vc."
"pdf)"
msgstr ""

#: src/intro/install.md:1
msgid "Installing the tools"
msgstr "安裝工具"

#: src/intro/install.md:3
msgid ""
"This page contains OS-agnostic installation instructions for a few of the "
"tools:"
msgstr ""

#: src/intro/install.md:5
msgid "Rust Toolchain"
msgstr "Rust 工具鏈"

#: src/intro/install.md:7
msgid ""
"Install rustup by following the instructions at [https://rustup.rs](https://"
"rustup.rs)."
msgstr ""

#: src/intro/install.md:9
msgid ""
"**NOTE** Make sure you have a compiler version equal to or newer than "
"`1.31`. `rustc -V` should return a date newer than the one shown below."
msgstr ""

#: src/intro/install.md:17
msgid ""
"For bandwidth and disk usage concerns the default installation only supports "
"native compilation. To add cross compilation support for the ARM Cortex-M "
"architectures choose one of the following compilation targets. For the "
"STM32F3DISCOVERY board used for the examples in this book, use the "
"`thumbv7em-none-eabihf` target. [Find the best Cortex-M for you.](https://"
"developer.arm.com/ip-products/processors/cortex-"
"m#c-7d3b69ce-5b17-4c9e-8f06-59b605713133)"
msgstr ""

#: src/intro/install.md:23
msgid "Cortex-M0, M0+, and M1 (ARMv6-M architecture):"
msgstr ""

#: src/intro/install.md:28
msgid "Cortex-M3 (ARMv7-M architecture):"
msgstr ""

#: src/intro/install.md:33
msgid ""
"Cortex-M4 and M7 without hardware floating point (ARMv7E-M architecture):"
msgstr ""

#: src/intro/install.md:38
msgid ""
"Cortex-M4F and M7F with hardware floating point (ARMv7E-M architecture):"
msgstr ""

#: src/intro/install.md:43
msgid "Cortex-M23 (ARMv8-M architecture):"
msgstr ""

#: src/intro/install.md:48
msgid "Cortex-M33 and M35P (ARMv8-M architecture):"
msgstr ""

#: src/intro/install.md:53
msgid ""
"Cortex-M33F and M35PF with hardware floating point (ARMv8-M architecture):"
msgstr ""

#: src/intro/install.md:59
msgid "`cargo-binutils`"
msgstr ""

#: src/intro/install.md:66
msgid ""
"WINDOWS: prerequisite C++ Build Tools for Visual Studio 2019 is installed. "
"https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?"
"sku=BuildTools&rel=16"
msgstr ""

#: src/intro/install.md:67
msgid "`cargo-generate`"
msgstr ""

#: src/intro/install.md:69
msgid "We'll use this later to generate a project from a template."
msgstr ""

#: src/intro/install.md:75
msgid ""
"Note: on some Linux distros (e.g. Ubuntu) you may need to install the "
"packages `libssl-dev` and `pkg-config` prior to installing cargo-generate."
msgstr ""

#: src/intro/install.md:77
msgid "OS-Specific Instructions"
msgstr ""

#: src/intro/install.md:79
msgid "Now follow the instructions specific to the OS you are using:"
msgstr ""

#: src/intro/install.md:81
msgid "[Linux](install/linux.md)"
msgstr "[Linux](install/linux.md)"

#: src/intro/install.md:82
msgid "[Windows](install/windows.md)"
msgstr "[Windows](install/windows.md)"

#: src/intro/install.md:83
msgid "[macOS](install/macos.md)"
msgstr "[macOS](install/macos.md)"

#: src/intro/install/linux.md:1
msgid "Linux"
msgstr ""

#: src/intro/install/linux.md:3
msgid "Here are the installation commands for a few Linux distributions."
msgstr ""

#: src/intro/install/linux.md:5
msgid "Packages"
msgstr "軟體包"

#: src/intro/install/linux.md:7
msgid "Ubuntu 18.04 or newer / Debian stretch or newer"
msgstr ""

#: src/intro/install/linux.md:9
msgid ""
"**NOTE** `gdb-multiarch` is the GDB command you'll use to debug your ARM "
"Cortex-M programs"
msgstr ""

#: src/intro/install/linux.md:26
msgid "Ubuntu 14.04 and 16.04"
msgstr ""

#: src/intro/install/linux.md:28
msgid ""
"**NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug your ARM "
"Cortex-M programs"
msgstr ""

#: src/intro/install/linux.md:40
msgid "Fedora 27 or newer"
msgstr ""

#: src/intro/install/linux.md:51
msgid "Arch Linux"
msgstr ""

#: src/intro/install/linux.md:53
msgid ""
"**NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug ARM "
"Cortex-M programs"
msgstr ""

#: src/intro/install/linux.md:60
msgid "udev rules"
msgstr ""

#: src/intro/install/linux.md:62
msgid ""
"This rule lets you use OpenOCD with the Discovery board without root "
"privilege."
msgstr ""

#: src/intro/install/linux.md:64
msgid ""
"Create the file `/etc/udev/rules.d/70-st-link.rules` with the contents shown "
"below."
msgstr ""

#: src/intro/install/linux.md:66
msgid ""
"```text\n"
"# STM32F3DISCOVERY rev A/B - ST-LINK/V2\n"
"ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3748\", TAG+=\"uaccess\"\n"
"\n"
"# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1\n"
"ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"374b\", TAG+=\"uaccess\"\n"
"```"
msgstr ""

#: src/intro/install/linux.md:74
msgid "Then reload all the udev rules with:"
msgstr ""

#: src/intro/install/linux.md:80
msgid ""
"If you had the board plugged to your laptop, unplug it and then plug it "
"again."
msgstr ""

#: src/intro/install/linux.md:82
msgid "You can check the permissions by running this command:"
msgstr ""

#: src/intro/install/linux.md:88
msgid "Which should show something like"
msgstr ""

#: src/intro/install/linux.md:96
msgid ""
"Take note of the bus and device numbers. Use those numbers to create a path "
"like `/dev/bus/usb/<bus>/<device>`. Then use this path like so:"
msgstr ""

#: src/intro/install/linux.md:116
msgid ""
"The `+` appended to permissions indicates the existence of an extended "
"permission. The `getfacl` command tells the user `you` can make use of this "
"device."
msgstr ""

#: src/intro/install/linux.md:120
msgid "Now, go to the [next section](verify.md)."
msgstr ""

#: src/intro/install/macos.md:1
msgid "macOS"
msgstr ""

#: src/intro/install/macos.md:3
msgid ""
"All the tools can be installed using [Homebrew](http://brew.sh/) or "
"[MacPorts](https://www.macports.org/):"
msgstr ""

#: src/intro/install/macos.md:8
msgid "Install tools with [Homebrew](http://brew.sh/)"
msgstr ""

#: src/intro/install/macos.md:21
msgid ""
"**NOTE** If OpenOCD crashes you may need to install the latest version using:"
msgstr ""

#: src/intro/install/macos.md:26
msgid "Install tools with [MacPorts](https://www.macports.org/)"
msgstr ""

#: src/intro/install/macos.md:41
msgid "That's all! Go to the [next section](verify.md)."
msgstr ""

#: src/intro/install/verify.md:1
msgid "Verify Installation"
msgstr "驗證安裝"

#: src/intro/install/verify.md:3
msgid ""
"In this section we check that some of the required tools / drivers have been "
"correctly installed and configured."
msgstr ""

#: src/intro/install/verify.md:6
msgid ""
"Connect your laptop / PC to the discovery board using a Mini-USB USB cable. "
"The discovery board has two USB connectors; use the one labeled \"USB ST-"
"LINK\" that sits on the center of the edge of the board."
msgstr ""

#: src/intro/install/verify.md:10
msgid ""
"Also check that the ST-LINK header is populated. See the picture below; the "
"ST-LINK header is highlighted."
msgstr ""

#: src/intro/install/verify.md:17
msgid "Now run the following command:"
msgstr ""

#: src/intro/install/verify.md:23
msgid ""
"**NOTE**: Old versions of openocd, including the 0.10.0 release from 2017, "
"do not contain the new (and preferable) `interface/stlink.cfg` file; instead "
"you may need to use `interface/stlink-v2.cfg` or `interface/stlink-v2-1.cfg`."
msgstr ""

#: src/intro/install/verify.md:27
msgid ""
"You should get the following output and the program should block the console:"
msgstr ""

#: src/intro/install/verify.md:29
msgid ""
"```text\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.919881\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"
msgstr ""
"```text\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.919881\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"

#: src/intro/install/verify.md:48
msgid ""
"The contents may not match exactly but you should get the last line about "
"breakpoints and watchpoints. If you got it then terminate the OpenOCD "
"process and move to the [next section](../../start/index.md)."
msgstr ""

#: src/intro/install/verify.md:54
msgid ""
"If you didn't get the \"breakpoints\" line then try one of the following "
"commands."
msgstr ""

#: src/intro/install/verify.md:64
msgid ""
"If one of those commands works it means you got an old hardware revision of "
"the discovery board. That won't be a problem but commit that fact to memory "
"as you'll need to configure things a bit differently later on. You can move "
"to the [next section](../../start/index.md)."
msgstr ""

#: src/intro/install/verify.md:69
msgid ""
"If none of the commands work as a normal user then try to run them with root "
"permission (e.g. `sudo openocd ..`). If the commands do work with root "
"permission then check that the [udev rules](linux.md#udev-rules) have been "
"correctly set."
msgstr ""

#: src/intro/install/verify.md:75
msgid ""
"If you have reached this point and OpenOCD is not working please open [an "
"issue](https://github.com/rust-embedded/book/issues) and we'll help you out!"
msgstr ""

#: src/intro/install/windows.md:1
msgid "Windows"
msgstr "Windows"

#: src/intro/install/windows.md:3
msgid "`arm-none-eabi-gdb`"
msgstr "`arm-none-eabi-gdb`"

#: src/intro/install/windows.md:5
msgid ""
"ARM provides `.exe` installers for Windows. Grab one from [here](https://"
"developer.arm.com/downloads/-/arm-gnu-toolchain-downloads), and follow the "
"instructions. Just before the installation process finishes tick/select the "
"\"Add path to environment variable\" option. Then verify that the tools are "
"in your `%PATH%`:"
msgstr ""

#: src/intro/install/windows.md:17
msgid "OpenOCD"
msgstr "OpenOCD"

#: src/intro/install/windows.md:19
msgid ""
"There's no official binary release of OpenOCD for Windows but if you're not "
"in the mood to compile it yourself, the xPack project provides a binary "
"distribution, [here](https://xpack.github.io/openocd/). Follow the provided "
"installation instructions. Then update your `%PATH%` environment variable to "
"include the path where the binaries were installed. (`C:"
"\\Users\\USERNAME\\AppData\\Roaming\\xPacks\\@xpack-dev-"
"tools\\openocd\\0.10.0-13.1\\.content\\bin\\`, if you've been using the easy "
"install)"
msgstr ""

#: src/intro/install/windows.md:27
msgid "Verify that OpenOCD is in your `%PATH%` with:"
msgstr ""

#: src/intro/install/windows.md:37
msgid ""
"Grab QEMU from [the official website](https://www.qemu.org/download/"
"#windows)."
msgstr ""

#: src/intro/install/windows.md:41
msgid "ST-LINK USB driver"
msgstr ""

#: src/intro/install/windows.md:43
msgid ""
"You'll also need to install [this USB driver](http://www.st.com/en/embedded-"
"software/stsw-link009.html) or OpenOCD won't work. Follow the installer "
"instructions and make sure you install the right version (32-bit or 64-bit) "
"of the driver."
msgstr ""

#: src/intro/no-std.md:1
msgid "A `no_std` Rust Environment"
msgstr "`no_std` Rust 環境"

#: src/intro/no-std.md:3
msgid ""
"The term Embedded Programming is used for a wide range of different classes "
"of programming. Ranging from programming 8-Bit MCUs (like the [ST72325xx]"
"(https://www.st.com/resource/en/datasheet/st72325j6.pdf)) with just a few KB "
"of RAM and ROM, up to systems like the Raspberry Pi ([Model B 3+](https://en."
"wikipedia.org/wiki/Raspberry_Pi#Specifications)) which has a 32/64-bit 4-"
"core Cortex-A53 @ 1.4 GHz and 1GB of RAM. Different restrictions/limitations "
"will apply when writing code depending on what kind of target and use case "
"you have."
msgstr ""

#: src/intro/no-std.md:10
msgid "There are two general Embedded Programming classifications:"
msgstr ""

#: src/intro/no-std.md:12
msgid "Hosted Environments"
msgstr ""

#: src/intro/no-std.md:13
msgid ""
"These kinds of environments are close to a normal PC environment. What this "
"means is that you are provided with a System Interface [E.G. POSIX](https://"
"en.wikipedia.org/wiki/POSIX) that provides you with primitives to interact "
"with various systems, such as file systems, networking, memory management, "
"threads, etc. Standard libraries in turn usually depend on these primitives "
"to implement their functionality. You may also have some sort of sysroot and "
"restrictions on RAM/ROM-usage, and perhaps some special HW or I/Os. Overall "
"it feels like coding on a special-purpose PC environment."
msgstr ""

#: src/intro/no-std.md:20
msgid "Bare Metal Environments"
msgstr ""

#: src/intro/no-std.md:21
msgid ""
"In a bare metal environment no code has been loaded before your program. "
"Without the software provided by an OS we can not load the standard library. "
"Instead the program, along with the crates it uses, can only use the "
"hardware (bare metal) to run. To prevent rust from loading the standard "
"library use `no_std`. The platform-agnostic parts of the standard library "
"are available through [libcore](https://doc.rust-lang.org/core/). libcore "
"also excludes things which are not always desirable in an embedded "
"environment. One of these things is a memory allocator for dynamic memory "
"allocation. If you require this or any other functionalities there are often "
"crates which provide these."
msgstr ""

#: src/intro/no-std.md:30
msgid "The libstd Runtime"
msgstr ""

#: src/intro/no-std.md:31
msgid ""
"As mentioned before using [libstd](https://doc.rust-lang.org/std/) requires "
"some sort of system integration, but this is not only because [libstd]"
"(https://doc.rust-lang.org/std/) is just providing a common way of accessing "
"OS abstractions, it also provides a runtime. This runtime, among other "
"things, takes care of setting up stack overflow protection, processing "
"command line arguments, and spawning the main thread before a program's main "
"function is invoked. This runtime also won't be available in a `no_std` "
"environment."
msgstr ""

#: src/intro/no-std.md:36
msgid "Summary"
msgstr "摘要"

#: src/intro/no-std.md:37
msgid ""
"`#![no_std]` is a crate-level attribute that indicates that the crate will "
"link to the core-crate instead of the std-crate. The [libcore](https://doc."
"rust-lang.org/core/) crate in turn is a platform-agnostic subset of the std "
"crate which makes no assumptions about the system the program will run on. "
"As such, it provides APIs for language primitives like floats, strings and "
"slices, as well as APIs that expose processor features like atomic "
"operations and SIMD instructions. However it lacks APIs for anything that "
"involves platform integration. Because of these properties no\\_std and "
"[libcore](https://doc.rust-lang.org/core/) code can be used for any kind of "
"bootstrapping (stage 0) code like bootloaders, firmware or kernels."
msgstr ""

#: src/intro/no-std.md:45
msgid "Overview"
msgstr "概覽"

#: src/intro/no-std.md:47
msgid "feature"
msgstr ""

#: src/intro/no-std.md:47
msgid "no\\_std"
msgstr ""

#: src/intro/no-std.md:47
msgid "std"
msgstr ""

#: src/intro/no-std.md:49
msgid "heap (dynamic memory)"
msgstr ""

#: src/intro/no-std.md:49
msgid "\\*"
msgstr ""

#: src/intro/no-std.md:49 src/intro/no-std.md:50 src/intro/no-std.md:51
#: src/intro/no-std.md:52 src/intro/no-std.md:53 src/intro/no-std.md:54
#: src/intro/no-std.md:55
msgid "✓"
msgstr ""

#: src/intro/no-std.md:50
msgid "collections (Vec, BTreeMap, etc)"
msgstr ""

#: src/intro/no-std.md:50
msgid "\\**"
msgstr ""

#: src/intro/no-std.md:51
msgid "stack overflow protection"
msgstr ""

#: src/intro/no-std.md:51 src/intro/no-std.md:52 src/intro/no-std.md:53
#: src/intro/no-std.md:55
msgid "✘"
msgstr ""

#: src/intro/no-std.md:52
msgid "runs init code before main"
msgstr ""

#: src/intro/no-std.md:53
msgid "libstd available"
msgstr ""

#: src/intro/no-std.md:54
msgid "libcore available"
msgstr ""

#: src/intro/no-std.md:55
msgid "writing firmware, kernel, or bootloader code"
msgstr ""

#: src/intro/no-std.md:57
msgid ""
"\\* Only if you use the `alloc` crate and use a suitable allocator like "
"[alloc-cortex-m](https://github.com/rust-embedded/alloc-cortex-m)."
msgstr ""

#: src/intro/no-std.md:59
msgid ""
"\\*\\* Only if you use the `collections` crate and configure a global "
"default allocator."
msgstr ""

#: src/intro/no-std.md:61
msgid ""
"\\*\\* HashMap and HashSet are not available due to a lack of a secure "
"random number generator."
msgstr ""

#: src/intro/no-std.md:65
msgid "See Also"
msgstr ""

#: src/intro/no-std.md:66
msgid ""
"[RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-"
"no_std.md)"
msgstr ""

#: src/SUMMARY.md:15
msgid "Tooling"
msgstr "工具"

#: src/intro/tooling.md:3
msgid ""
"Dealing with microcontrollers involves using several different tools as "
"we'll be dealing with an architecture different than your laptop's and we'll "
"have to run and debug programs on a _remote_ device."
msgstr ""

#: src/intro/tooling.md:7
msgid ""
"We'll use all the tools listed below. Any recent version should work when a "
"minimum version is not specified, but we have listed the versions we have "
"tested."
msgstr ""

#: src/intro/tooling.md:11
msgid ""
"Rust 1.31, 1.31-beta, or a newer toolchain PLUS ARM Cortex-M compilation "
"support."
msgstr ""

#: src/intro/tooling.md:13
msgid ""
"[`cargo-binutils`](https://github.com/rust-embedded/cargo-binutils) ~0.1.4"
msgstr ""

#: src/intro/tooling.md:14
msgid "[`qemu-system-arm`](https://www.qemu.org/). Tested versions: 3.0.0"
msgstr ""

#: src/intro/tooling.md:15
msgid "OpenOCD >=0.8. Tested versions: v0.9.0 and v0.10.0"
msgstr ""

#: src/intro/tooling.md:16
msgid ""
"GDB with ARM support. Version 7.12 or newer highly recommended. Tested "
"versions: 7.10, 7.11, 7.12 and 8.1"
msgstr ""

#: src/intro/tooling.md:18
msgid ""
"[`cargo-generate`](https://github.com/ashleygwilliams/cargo-generate) or "
"`git`. These tools are optional but will make it easier to follow along with "
"the book."
msgstr ""

#: src/intro/tooling.md:21
msgid ""
"The text below explains why we are using these tools. Installation "
"instructions can be found on the next page."
msgstr ""

#: src/intro/tooling.md:24
msgid "`cargo-generate` OR `git`"
msgstr "`cargo-generate` 或 `git`"

#: src/intro/tooling.md:26
msgid ""
"Bare metal programs are non-standard (`no_std`) Rust programs that require "
"some adjustments to the linking process in order to get the memory layout of "
"the program right. This requires some additional files (like linker scripts) "
"and settings (like linker flags). We have packaged those for you in a "
"template such that you only need to fill in the missing information (such as "
"the project name and the characteristics of your target hardware)."
msgstr ""

#: src/intro/tooling.md:33
msgid ""
"Our template is compatible with `cargo-generate`: a Cargo subcommand for "
"creating new Cargo projects from templates. You can also download the "
"template using `git`, `curl`, `wget`, or your web browser."
msgstr ""

#: src/intro/tooling.md:39
msgid ""
"`cargo-binutils` is a collection of Cargo subcommands that make it easy to "
"use the LLVM tools that are shipped with the Rust toolchain. These tools "
"include the LLVM versions of `objdump`, `nm` and `size` and are used for "
"inspecting binaries."
msgstr ""

#: src/intro/tooling.md:44
msgid ""
"The advantage of using these tools over GNU binutils is that (a) installing "
"the LLVM tools is the same one-command installation (`rustup component add "
"llvm-tools`) regardless of your OS and (b) tools like `objdump` support all "
"the architectures that `rustc` supports -- from ARM to x86_64 -- because "
"they both share the same LLVM backend."
msgstr ""

#: src/intro/tooling.md:50
msgid "`qemu-system-arm`"
msgstr ""

#: src/intro/tooling.md:52
msgid ""
"QEMU is an emulator. In this case we use the variant that can fully emulate "
"ARM systems. We use QEMU to run embedded programs on the host. Thanks to "
"this you can follow some parts of this book even if you don't have any "
"hardware with you!"
msgstr ""

#: src/intro/tooling.md:56
msgid "Tooling for Embedded Rust Debugging"
msgstr ""

#: src/intro/tooling.md:60
msgid ""
"Debugging embedded systems in Rust requires specialized tools including "
"software to manage the debugging process, debuggers to inspect and control "
"program execution, and hardware probes to facilitate interaction between the "
"host and the embedded device. This document outlines essential software "
"tools like Probe-rs and OpenOCD, which simplify and support the debugging "
"process, alongside prominent debuggers such as GDB and the Probe-rs Visual "
"Studio Code extension. Additionally, it covers key hardware probes such as "
"Rusty-probe, ST-Link, J-Link, and MCU-Link, which are integral for effective "
"debugging and programming of embedded devices."
msgstr ""

#: src/intro/tooling.md:62
msgid "Software that drives debugging tools"
msgstr "驅動除錯工具的軟體"

#: src/intro/tooling.md:64
msgid "Probe-rs"
msgstr ""

#: src/intro/tooling.md:66
msgid ""
"Probe-rs is a modern, Rust-focused software designed to work with debuggers "
"in embedded systems. Unlike OpenOCD, Probe-rs is built with simplicity in "
"mind and aims to reduce the configuration burden often found in other "
"debugging solutions. It supports various probes and targets, providing a "
"high-level interface for interacting with embedded hardware. Probe-rs "
"integrates directly with Rust tooling, and integrates with Visual Studio "
"Code through its extension, allowing developers to streamline their "
"debugging workflow."
msgstr ""

#: src/intro/tooling.md:69
msgid "OpenOCD (Open On-Chip Debugger)"
msgstr ""

#: src/intro/tooling.md:71
msgid ""
"OpenOCD is an open-source software tool used for debugging, testing, and "
"programming embedded systems. It provides an interface between the host "
"system and embedded hardware, supporting various transport layers like JTAG "
"and SWD (Serial Wire Debug). OpenOCD integrates with GDB, which is a "
"debugger. OpenOCD is widely supported, with extensive documentation and a "
"large community, but may require complex configuration, especially for "
"custom embedded setups."
msgstr ""

#: src/intro/tooling.md:73
msgid "Debuggers"
msgstr "除錯器"

#: src/intro/tooling.md:75
msgid ""
"A debugger allows developers to inspect and control the execution of a "
"program in order to identify and correct errors or bugs. It provides "
"functionalities such as setting breakpoints, stepping through code line by "
"line, and examining the values of variables and memory states. Debuggers are "
"essential for thorough software development and maintenance, enabling "
"developers to ensure that their code behaves as intended under various "
"conditions."
msgstr ""

#: src/intro/tooling.md:77
msgid "Debuggers know how to:"
msgstr "除錯器知道如何："

#: src/intro/tooling.md:78
msgid "Interact with the memory mapped registers."
msgstr ""

#: src/intro/tooling.md:79
msgid "Set Breakpoints/Watchpoints."
msgstr "設定中斷點/監看點。"

#: src/intro/tooling.md:80
msgid "Read and write to the memory mapped registers."
msgstr ""

#: src/intro/tooling.md:81
msgid "Detect when the MCU has been halted for a debug event."
msgstr ""

#: src/intro/tooling.md:82
msgid "Continue MCU execution after a debug event has been encountered."
msgstr ""

#: src/intro/tooling.md:83
msgid "Erase and write to the microcontroller's FLASH."
msgstr ""

#: src/intro/tooling.md:85
msgid "Probe-rs Visual Studio Code Extension"
msgstr ""

#: src/intro/tooling.md:87
msgid ""
"Probe-rs has a Visual Studio Code extension, providing a seamless debugging "
"experience without extensive setup. Through this connection, developers can "
"use Rust-specific features like pretty printing and detailed error messages, "
"ensuring that their debugging process aligns with the Rust ecosystem."
msgstr ""

#: src/intro/tooling.md:89
msgid "GDB (GNU Debugger)"
msgstr ""

#: src/intro/tooling.md:91
msgid ""
"GDB is a versatile debugging tool that allows developers to examine the "
"state of programs while they run or after they crash. For embedded Rust, GDB "
"connects to the target system via OpenOCD or other debugging servers to "
"interact with the embedded code. GDB is highly configurable and supports "
"features like remote debugging, variable inspection, and conditional "
"breakpoints. It can be used on a variety of platforms, and has extensive "
"support for Rust-specific debugging needs, such as pretty printing and "
"integration with IDEs."
msgstr ""

#: src/intro/tooling.md:94
msgid "Probes"
msgstr ""

#: src/intro/tooling.md:96
msgid ""
"A hardware probe is a device used in the development and debugging of "
"embedded systems to facilitate communication between a host computer and the "
"target embedded device. It typically supports protocols like JTAG or SWD, "
"enabling it to program, debug, and analyze the microcontroller or "
"microprocessor on the embedded system. Hardware probes are crucial for "
"developers to set breakpoints, step through code, and inspect memory and "
"processor registers, effectively allowing them to diagnose and fix issues in "
"real-time."
msgstr ""

#: src/intro/tooling.md:98
msgid "Rusty-probe"
msgstr ""

#: src/intro/tooling.md:100
msgid ""
"Rusty-probe is an open-sourced USB-based hardware debugging probe designed "
"to work with probe-rs. The combination of Rusty-Probe and probe-rs provides "
"an easy-to-use, cost-effective solution for developers working with embedded "
"Rust applications."
msgstr ""

#: src/intro/tooling.md:102
msgid "ST-Link"
msgstr ""

#: src/intro/tooling.md:104
msgid ""
"The ST-Link is a popular debugging and programming probe developed by "
"STMicroelectronics primarily for their STM32 and STM8 microcontroller "
"series. It supports both debugging and programming via JTAG or SWD (Serial "
"Wire Debug) interfaces. ST-Link is widely used due to its direct support "
"from STMicroelectronics' extensive range of development boards and its "
"integration into major IDEs, making it a convenient choice for developers "
"working with STM microcontrollers."
msgstr ""

#: src/intro/tooling.md:106
msgid "J-Link"
msgstr ""

#: src/intro/tooling.md:108
msgid ""
"J-Link, developed by SEGGER Microcontroller, is a robust and versatile "
"debugger supporting a wide range of CPU cores and devices beyond just ARM, "
"such as RISC-V. Known for its high performance and reliability, J-Link "
"supports various communication interfaces, including JTAG, SWD, and fine-"
"pitch JTAG interfaces. It is favored for its advanced features like "
"unlimited breakpoints in flash memory and its compatibility with a multitude "
"of development environments."
msgstr ""

#: src/intro/tooling.md:110
msgid "MCU-Link"
msgstr ""

#: src/intro/tooling.md:112
msgid ""
"MCU-Link is a debugging probe that also functions as a programmer, provided "
"by NXP Semiconductors. It supports a variety of ARM Cortex microcontrollers "
"and interfaces seamlessly with development tools like MCUXpresso IDE. MCU-"
"Link is particularly notable for its versatility and affordability, making "
"it an accessible option for hobbyists, educators, and professional "
"developers alike."
msgstr ""

#: src/peripherals/index.md:1
msgid "Peripherals"
msgstr "周邊"

#: src/peripherals/index.md:3
msgid "What are Peripherals?"
msgstr "什麼是周邊？"

#: src/peripherals/index.md:5
msgid ""
"Most Microcontrollers have more than just a CPU, RAM, or Flash Memory - they "
"contain sections of silicon which are used for interacting with systems "
"outside of the microcontroller, as well as directly and indirectly "
"interacting with their surroundings in the world via sensors, motor "
"controllers, or human interfaces such as a display or keyboard. These "
"components are collectively known as Peripherals."
msgstr ""
"多數微控制器不只有 CPU、RAM 或快閃記憶體，還包含用於與微控制器外部系統互動的"
"矽區塊，也會透過感測器、馬達控制器或顯示器、鍵盤等人機介面，直接或間接地與周"
"遭環境互動。這些元件統稱為周邊。"

#: src/peripherals/index.md:7
msgid ""
"These peripherals are useful because they allow a developer to offload "
"processing to them, avoiding having to handle everything in software. "
"Similar to how a desktop developer would offload graphics processing to a "
"video card, embedded developers can offload some tasks to peripherals "
"allowing the CPU to spend its time doing something else important, or doing "
"nothing in order to save power."
msgstr ""
"這些周邊之所以有用，是因為它們讓開發者可以把處理工作卸載給周邊，避免所有事都"
"由軟體處理。就像桌面開發者會把圖形處理交給顯示卡一樣，嵌入式開發者可把某些工"
"作交給周邊，讓 CPU 可以去做更重要的事，或不做事以節省功耗。"

#: src/peripherals/index.md:9
msgid ""
"If you look at the main circuit board in an old-fashioned home computer from "
"the 1970s or 1980s (and actually, the desktop PCs of yesterday are not so "
"far removed from the embedded systems of today) you would expect to see:"
msgstr ""
"如果你看看 1970 或 1980 年代老式家用電腦的主機板（其實昨日的桌機與今日的嵌入"
"式系統並沒有太大差別），你大概會看到："

#: src/peripherals/index.md:11
msgid "A processor"
msgstr "處理器"

#: src/peripherals/index.md:12
msgid "A RAM chip"
msgstr "RAM 晶片"

#: src/peripherals/index.md:13
msgid "A ROM chip"
msgstr "ROM 晶片"

#: src/peripherals/index.md:14
msgid "An I/O controller"
msgstr "I/O 控制器"

#: src/peripherals/index.md:16
msgid ""
"The RAM chip, ROM chip and I/O controller (the peripheral in this system) "
"would be joined to the processor through a series of parallel traces known "
"as a 'bus'. This bus carries address information, which selects which device "
"on the bus the processor wishes to communicate with, and a data bus which "
"carries the actual data. In our embedded microcontrollers, the same "
"principles apply - it's just that everything is packed on to a single piece "
"of silicon."
msgstr ""
"RAM 晶片、ROM 晶片與 I/O 控制器（此系統中的周邊）會透過一組稱為「匯流排」的平"
"行線路連接到處理器。匯流排負責攜帶位址資訊，用以選擇處理器想要溝通的裝置；以"
"及資料匯流排，用以傳輸實際資料。在嵌入式微控制器中，同樣的原理適用——只是所有"
"東西都被封裝在同一塊矽晶片上。"

#: src/peripherals/index.md:18
msgid ""
"However, unlike graphics cards, which typically have a Software API like "
"Vulkan, Metal, or OpenGL, peripherals are exposed to our Microcontroller "
"with a hardware interface, which is mapped to a chunk of the memory."
msgstr ""
"然而，不同於通常有 Vulkan、Metal 或 OpenGL 等軟體 API 的顯示卡，周邊會以硬體"
"介面呈現給微控制器，並對映到一段記憶體。"

#: src/peripherals/index.md:20
msgid "Linear and Real Memory Space"
msgstr "線性與實體記憶體空間"

#: src/peripherals/index.md:22
msgid ""
"On a microcontroller, writing some data to some other arbitrary address, "
"such as `0x4000_0000` or `0x0000_0000`, may also be a completely valid "
"action."
msgstr ""
"在微控制器上，將資料寫入其他任意位址（如 `0x4000_0000` 或 `0x0000_0000`）可能"
"也是完全合法的動作。"

#: src/peripherals/index.md:24
msgid ""
"On a desktop system, access to memory is tightly controlled by the MMU, or "
"Memory Management Unit. This component has two major responsibilities: "
"enforcing access permission to sections of memory (preventing one process "
"from reading or modifying the memory of another process); and re-mapping "
"segments of the physical memory to virtual memory ranges used in software. "
"Microcontrollers do not typically have an MMU, and instead only use real "
"physical addresses in software."
msgstr ""
"在桌面系統上，記憶體存取由 MMU（Memory Management Unit）嚴格控制。此元件有兩"
"項主要責任：強制記憶體區段的存取權限（防止某行程讀取或修改另一行程的記憶"
"體）；以及將實體記憶體區段重新對映到軟體使用的虛擬記憶體範圍。微控制器通常沒"
"有 MMU，而是只在軟體中使用實體位址。"

#: src/peripherals/index.md:26
msgid ""
"Although 32 bit microcontrollers have a real and linear address space from "
"`0x0000_0000`, and `0xFFFF_FFFF`, they generally only use a few hundred "
"kilobytes of that range for actual memory. This leaves a significant amount "
"of address space remaining. In earlier chapters, we were talking about RAM "
"being located at address `0x2000_0000`. If our RAM was 64 KiB long (i.e. "
"with a maximum address of 0xFFFF) then addresses `0x2000_0000` to "
"`0x2000_FFFF` would correspond to our RAM. When we write to a variable which "
"lives at address `0x2000_1234`, what happens internally is that some logic "
"detects the upper portion of the address (0x2000 in this example) and then "
"activates the RAM so that it can act upon the lower portion of the address "
"(0x1234 in this case). On a Cortex-M we also have our Flash ROM mapped in at "
"address `0x0000_0000` up to, say, address `0x0007_FFFF` (if we have a 512 "
"KiB Flash ROM). Rather than ignore all remaining space between these two "
"regions, Microcontroller designers instead mapped the interface for "
"peripherals in certain memory locations. This ends up looking something like "
"this:"
msgstr ""
"雖然 32 位元微控制器擁有從 `0x0000_0000` 到 `0xFFFF_FFFF` 的實體線性位址空"
"間，但實際記憶體通常只使用其中幾百 KB，留下大量位址空間。前面章節提到 RAM 位"
"於 `0x2000_0000`。若 RAM 為 64 KiB（最大位址 0xFFFF），那麼 `0x2000_0000` 到 "
"`0x2000_FFFF` 就對應到 RAM。當我們寫入位於 `0x2000_1234` 的變數時，內部會有邏"
"輯偵測位址高位（此例為 0x2000），並啟用 RAM 以處理低位址部分（此例為 "
"0x1234）。在 Cortex-M 上，Flash ROM 也會對映在 `0x0000_0000` 到例如 "
"`0x0007_FFFF`（若有 512 KiB Flash ROM）。微控制器設計者不會忽略這兩個區域之間"
"的空間，而是把周邊的介面對映到特定位址，結果看起來像這樣："

#: src/peripherals/index.md:28
msgid "![](../assets/nrf52-memory-map.png)"
msgstr ""

#: src/peripherals/index.md:30 src/peripherals/index.md:40
msgid ""
"[Nordic nRF52832 Datasheet (pdf)](http://infocenter.nordicsemi.com/pdf/"
"nRF52832_PS_v1.1.pdf)"
msgstr ""
"[Nordic nRF52832 規格書（pdf）](http://infocenter.nordicsemi.com/pdf/"
"nRF52832_PS_v1.1.pdf)"

#: src/peripherals/index.md:34
msgid ""
"Interaction with these peripherals is simple at a first glance - write the "
"right data to the correct address. For example, sending a 32 bit word over a "
"serial port could be as direct as writing that 32 bit word to a certain "
"memory address. The Serial Port Peripheral would then take over and send out "
"the data automatically."
msgstr ""
"乍看之下，與這些周邊互動很簡單——把正確資料寫到正確位址。例如，透過序列埠送出"
"一個 32 位元字，可能就只是將該 32 位元字寫入某個記憶體位址。序列埠周邊會接手"
"並自動送出資料。"

#: src/peripherals/index.md:36
msgid ""
"Configuration of these peripherals works similarly. Instead of calling a "
"function to configure a peripheral, a chunk of memory is exposed which "
"serves as the hardware API. Write `0x8000_0000` to a SPI Frequency "
"Configuration Register, and the SPI port will send data at 8 Megabits per "
"second. Write `0x0200_0000` to the same address, and the SPI port will send "
"data at 125 Kilobits per second. These configuration registers look a little "
"bit like this:"
msgstr ""
"周邊的設定方式也類似。不是呼叫函式來設定周邊，而是有一塊記憶體作為硬體 API。"
"把 `0x8000_0000` 寫到 SPI 頻率設定暫存器，SPI 就會以 8 Mbps 傳輸；把 "
"`0x0200_0000` 寫到同一位址，SPI 就會以 125 Kbps 傳輸。這些設定暫存器看起來像"
"這樣："

#: src/peripherals/index.md:38
msgid "![](../assets/nrf52-spi-frequency-register.png)"
msgstr ""

#: src/peripherals/index.md:42
msgid ""
"This interface is how interactions with the hardware are made, no matter "
"what language is used, whether that language is Assembly, C, or Rust."
msgstr "不論使用何種語言（組合語言、C 或 Rust），都必須透過此介面與硬體互動。"

#: src/peripherals/a-first-attempt.md:1
msgid "A First Attempt"
msgstr ""

#: src/peripherals/a-first-attempt.md:3
msgid "The Registers"
msgstr ""

#: src/peripherals/a-first-attempt.md:5
msgid ""
"Let's look at the 'SysTick' peripheral - a simple timer which comes with "
"every Cortex-M processor core. Typically you'll be looking these up in the "
"chip manufacturer's data sheet or _Technical Reference Manual_, but this "
"example is common to all ARM Cortex-M cores, let's look in the [ARM "
"reference manual](http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/"
"Babieigh.html). We see there are four registers:"
msgstr ""

#: src/peripherals/a-first-attempt.md:9
msgid "Offset"
msgstr ""

#: src/peripherals/a-first-attempt.md:9
msgid "Name"
msgstr ""

#: src/peripherals/a-first-attempt.md:9
msgid "Width"
msgstr ""

#: src/peripherals/a-first-attempt.md:11
msgid "0x00"
msgstr ""

#: src/peripherals/a-first-attempt.md:11
msgid "SYST_CSR"
msgstr ""

#: src/peripherals/a-first-attempt.md:11
msgid "Control and Status Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:11 src/peripherals/a-first-attempt.md:12
#: src/peripherals/a-first-attempt.md:13 src/peripherals/a-first-attempt.md:14
msgid "32 bits"
msgstr ""

#: src/peripherals/a-first-attempt.md:12
msgid "0x04"
msgstr ""

#: src/peripherals/a-first-attempt.md:12
msgid "SYST_RVR"
msgstr ""

#: src/peripherals/a-first-attempt.md:12
msgid "Reload Value Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:13
msgid "0x08"
msgstr ""

#: src/peripherals/a-first-attempt.md:13
msgid "SYST_CVR"
msgstr ""

#: src/peripherals/a-first-attempt.md:13
msgid "Current Value Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:14
msgid "0x0C"
msgstr ""

#: src/peripherals/a-first-attempt.md:14
msgid "SYST_CALIB"
msgstr ""

#: src/peripherals/a-first-attempt.md:14
msgid "Calibration Value Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:16
msgid "The C Approach"
msgstr ""

#: src/peripherals/a-first-attempt.md:18
msgid ""
"In Rust, we can represent a collection of registers in exactly the same way "
"as we do in C - with a `struct`."
msgstr ""

#: src/peripherals/a-first-attempt.md:30
msgid ""
"The qualifier `#[repr(C)]` tells the Rust compiler to lay this structure out "
"like a C compiler would. That's very important, as Rust allows structure "
"fields to be re-ordered, while C does not. You can imagine the debugging "
"we'd have to do if these fields were silently re-arranged by the compiler! "
"With this qualifier in place, we have our four 32-bit fields which "
"correspond to the table above. But of course, this `struct` is of no use by "
"itself - we need a variable."
msgstr ""

#: src/peripherals/a-first-attempt.md:37
msgid "Volatile Accesses"
msgstr ""

#: src/peripherals/a-first-attempt.md:39
msgid "Now, there are a couple of problems with the approach above."
msgstr ""

#: src/peripherals/a-first-attempt.md:41
msgid "We have to use unsafe every time we want to access our Peripheral."
msgstr ""

#: src/peripherals/a-first-attempt.md:42
msgid ""
"We've got no way of specifying which registers are read-only or read-write."
msgstr ""

#: src/peripherals/a-first-attempt.md:43
msgid ""
"Any piece of code anywhere in your program could access the hardware through "
"this structure."
msgstr ""

#: src/peripherals/a-first-attempt.md:45
msgid "Most importantly, it doesn't actually work..."
msgstr ""

#: src/peripherals/a-first-attempt.md:47
msgid ""
"Now, the problem is that compilers are clever. If you make two writes to the "
"same piece of RAM, one after the other, the compiler can notice this and "
"just skip the first write entirely. In C, we can mark variables as "
"`volatile` to ensure that every read or write occurs as intended. In Rust, "
"we instead mark the _accesses_ as volatile, not the variable."
msgstr ""

#: src/peripherals/a-first-attempt.md:54
msgid ""
"So, we've fixed one of our four problems, but now we have even more `unsafe` "
"code! Fortunately, there's a third party crate which can help - "
"[`volatile_register`](https://crates.io/crates/volatile_register)."
msgstr ""

#: src/peripherals/a-first-attempt.md:79
msgid ""
"Now, the volatile accesses are performed automatically through the `read` "
"and `write` methods. It's still `unsafe` to perform writes, but to be fair, "
"hardware is a bunch of mutable state and there's no way for the compiler to "
"know whether these writes are actually safe, so this is a good default "
"position."
msgstr ""

#: src/peripherals/a-first-attempt.md:81
msgid "The Rusty Wrapper"
msgstr ""

#: src/peripherals/a-first-attempt.md:83
msgid ""
"We need to wrap this `struct` up into a higher-layer API that is safe for "
"our users to call. As the driver author, we manually verify the unsafe code "
"is correct, and then present a safe API for our users so they don't have to "
"worry about it (provided they trust us to get it right!)."
msgstr ""

#: src/peripherals/a-first-attempt.md:85
msgid "One example might be:"
msgstr ""

#: src/peripherals/a-first-attempt.md:121
msgid "\"Time is now 0x{:08x}\""
msgstr ""

#: src/peripherals/a-first-attempt.md:125
msgid ""
"Now, the problem with this approach is that the following code is perfectly "
"acceptable to the compiler:"
msgstr ""

#: src/peripherals/a-first-attempt.md:139
msgid ""
"Our `&mut self` argument to the `set_reload` function checks that there are "
"no other references to _that_ particular `SystemTimer` struct, but they "
"don't stop the user creating a second `SystemTimer` which points to the "
"exact same peripheral! Code written in this fashion will work if the author "
"is diligent enough to spot all of these 'duplicate' driver instances, but "
"once the code is spread out over multiple modules, drivers, developers, and "
"days, it gets easier and easier to make these kinds of mistakes."
msgstr ""

#: src/SUMMARY.md:33
msgid "Singletons"
msgstr "單例"

#: src/peripherals/singletons.md:3
msgid ""
"In software engineering, the singleton pattern is a software design pattern "
"that restricts the instantiation of a class to one object."
msgstr ""

#: src/peripherals/singletons.md:5
msgid ""
"_Wikipedia: [Singleton Pattern](https://en.wikipedia.org/wiki/"
"Singleton_pattern)_"
msgstr ""

#: src/peripherals/singletons.md:10
msgid "But why can't we just use global variable(s)?"
msgstr ""

#: src/peripherals/singletons.md:12
msgid "We could make everything a public static, like this"
msgstr ""

#: src/peripherals/singletons.md:24
msgid ""
"But this has a few problems. It is a mutable global variable, and in Rust, "
"these are always unsafe to interact with. These variables are also visible "
"across your whole program, which means the borrow checker is unable to help "
"you track references and ownership of these variables."
msgstr ""

#: src/peripherals/singletons.md:26
msgid "How do we do this in Rust?"
msgstr ""

#: src/peripherals/singletons.md:28
msgid ""
"Instead of just making our peripheral a global variable, we might instead "
"decide to make a structure, in this case called `PERIPHERALS`, which "
"contains an `Option<T>` for each of our peripherals."
msgstr ""

#: src/peripherals/singletons.md:45
msgid ""
"This structure allows us to obtain a single instance of our peripheral. If "
"we try to call `take_serial()` more than once, our code will panic!"
msgstr ""

#: src/peripherals/singletons.md:50
msgid ""
"// This panics!\n"
"    // let serial_2 = unsafe { PERIPHERALS.take_serial() };\n"
msgstr ""

#: src/peripherals/singletons.md:55
msgid ""
"Although interacting with this structure is `unsafe`, once we have the "
"`SerialPort` it contained, we no longer need to use `unsafe`, or the "
"`PERIPHERALS` structure at all."
msgstr ""

#: src/peripherals/singletons.md:57
msgid ""
"This has a small runtime overhead because we must wrap the `SerialPort` "
"structure in an option, and we'll need to call `take_serial()` once, however "
"this small up-front cost allows us to leverage the borrow checker throughout "
"the rest of our program."
msgstr ""

#: src/peripherals/singletons.md:59
msgid "Existing library support"
msgstr ""

#: src/peripherals/singletons.md:61
msgid ""
"Although we created our own `Peripherals` structure above, it is not "
"necessary to do this for your code. the `cortex_m` crate contains a macro "
"called `singleton!()` that will perform this action for you."
msgstr ""

#: src/peripherals/singletons.md:67
msgid "// OK if `main` is executed only once\n"
msgstr ""

#: src/peripherals/singletons.md:73
msgid ""
"[cortex_m docs](https://docs.rs/cortex-m/latest/cortex_m/macro.singleton."
"html)"
msgstr ""

#: src/peripherals/singletons.md:75
msgid ""
"Additionally, if you use [`cortex-m-rtic`](https://github.com/rtic-rs/cortex-"
"m-rtic), the entire process of defining and obtaining these peripherals are "
"abstracted for you, and you are instead handed a `Peripherals` structure "
"that contains a non-`Option<T>` version of all of the items you define."
msgstr ""

#: src/peripherals/singletons.md:78
msgid "// cortex-m-rtic v0.5.x\n"
msgstr ""

#: src/peripherals/singletons.md:85
msgid "// Cortex-M peripherals\n"
msgstr ""

#: src/peripherals/singletons.md:88
msgid "// Device specific peripherals\n"
msgstr ""

#: src/peripherals/singletons.md:94
msgid "But why?"
msgstr ""

#: src/peripherals/singletons.md:96
msgid ""
"But how do these Singletons make a noticeable difference in how our Rust "
"code works?"
msgstr ""

#: src/peripherals/singletons.md:103
msgid "// <------ This is really, really important\n"
msgstr ""

#: src/peripherals/singletons.md:112
msgid "There are two important factors in play here:"
msgstr ""

#: src/peripherals/singletons.md:114
msgid ""
"Because we are using a singleton, there is only one way or place to obtain a "
"`SerialPort` structure"
msgstr ""

#: src/peripherals/singletons.md:115
msgid ""
"To call the `read_speed()` method, we must have ownership or a reference to "
"a `SerialPort` structure"
msgstr ""

#: src/peripherals/singletons.md:117
msgid ""
"These two factors put together means that it is only possible to access the "
"hardware if we have appropriately satisfied the borrow checker, meaning that "
"at no point do we have multiple mutable references to the same hardware!"
msgstr ""

#: src/peripherals/singletons.md:121
msgid ""
"// missing reference to `self`! Won't work.\n"
"    // SerialPort::read_speed();\n"
msgstr ""

#: src/peripherals/singletons.md:126
msgid "// you can only read what you have access to\n"
msgstr ""

#: src/peripherals/singletons.md:131
msgid "Treat your hardware like data"
msgstr ""

#: src/peripherals/singletons.md:133
msgid ""
"Additionally, because some references are mutable, and some are immutable, "
"it becomes possible to see whether a function or method could potentially "
"modify the state of the hardware. For example,"
msgstr ""

#: src/peripherals/singletons.md:135
msgid "This is allowed to change hardware settings:"
msgstr ""

#: src/peripherals/singletons.md:146
msgid "This isn't:"
msgstr ""

#: src/peripherals/singletons.md:154
msgid ""
"This allows us to enforce whether code should or should not make changes to "
"hardware at **compile time**, rather than at runtime. As a note, this "
"generally only works across one application, but for bare metal systems, our "
"software will be compiled into a single application, so this is not usually "
"a restriction."
msgstr ""

#: src/peripherals/borrowck.md:1
msgid "Mutable Global State"
msgstr ""

#: src/peripherals/borrowck.md:3
msgid ""
"Unfortunately, hardware is basically nothing but mutable global state, which "
"can feel very frightening for a Rust developer. Hardware exists "
"independently from the structures of the code we write, and can be modified "
"at any time by the real world."
msgstr ""

#: src/peripherals/borrowck.md:5
msgid "What should our rules be?"
msgstr ""

#: src/peripherals/borrowck.md:7
msgid "How can we reliably interact with these peripherals?"
msgstr ""

#: src/peripherals/borrowck.md:9
msgid ""
"Always use `volatile` methods to read or write to peripheral memory, as it "
"can change at any time"
msgstr ""

#: src/peripherals/borrowck.md:10
msgid ""
"In software, we should be able to share any number of read-only accesses to "
"these peripherals"
msgstr ""

#: src/peripherals/borrowck.md:11
msgid ""
"If some software should have read-write access to a peripheral, it should "
"hold the only reference to that peripheral"
msgstr ""

#: src/peripherals/borrowck.md:13
msgid "The Borrow Checker"
msgstr "借用檢查器"

#: src/peripherals/borrowck.md:15
msgid ""
"The last two of these rules sound suspiciously similar to what the Borrow "
"Checker does already!"
msgstr ""

#: src/peripherals/borrowck.md:17
msgid ""
"Imagine if we could pass around ownership of these peripherals, or offer "
"immutable or mutable references to them?"
msgstr ""

#: src/peripherals/borrowck.md:19
msgid ""
"Well, we can, but for the Borrow Checker, we need to have exactly one "
"instance of each peripheral, so Rust can handle this correctly. Well, "
"luckily in the hardware, there is only one instance of any given peripheral, "
"but how can we expose that in the structure of our code?"
msgstr ""

#: src/portability/index.md:1
msgid "Portability"
msgstr "可攜性"

#: src/portability/index.md:3
msgid ""
"In embedded environments portability is a very important topic: Every vendor "
"and even each family from a single manufacturer offers different peripherals "
"and capabilities and similarly the ways to interact with the peripherals "
"will vary."
msgstr ""
"在嵌入式環境中，可攜性是非常重要的主題：每個廠商，甚至同一廠商的不同家族，都"
"提供不同的周邊與能力，與周邊互動的方式也會有所差異。"

#: src/portability/index.md:5
msgid ""
"A common way to equalize such differences is via a layer called Hardware "
"Abstraction layer or **HAL**."
msgstr ""
"平衡這些差異的一個常見方式是透過稱為硬體抽象層（Hardware Abstraction Layer，"
"**HAL**）的層次。"

#: src/portability/index.md:7
msgid ""
"Hardware abstractions are sets of routines in software that emulate some "
"platform-specific details, giving programs direct access to the hardware "
"resources."
msgstr ""
"硬體抽象是在軟體中模擬部分平台特有細節的一組程式例程，讓程式能直接存取硬體資"
"源。"

#: src/portability/index.md:9
msgid ""
"They often allow programmers to write device-independent, high performance "
"applications by providing standard operating system (OS) calls to hardware."
msgstr ""
"它們通常透過向硬體提供標準作業系統（OS）呼叫，讓程式設計者能撰寫與裝置無關、"
"高效能的應用程式。"

#: src/portability/index.md:11
msgid ""
"_Wikipedia: [Hardware Abstraction Layer](https://en.wikipedia.org/wiki/"
"Hardware_abstraction)_"
msgstr ""
"_Wikipedia：[Hardware Abstraction Layer](https://en.wikipedia.org/wiki/"
"Hardware_abstraction)_"

#: src/portability/index.md:15
msgid ""
"Embedded systems are a bit special in this regard since we typically do not "
"have operating systems and user installable software but firmware images "
"which are compiled as a whole as well as a number of other constraints. So "
"while the traditional approach as defined by Wikipedia could potentially "
"work it is likely not the most productive approach to ensure portability."
msgstr ""
"嵌入式系統在這方面有些特殊，因為我們通常沒有作業系統與可由使用者安裝的軟體，"
"而是整體編譯的韌體映像，以及許多其他限制。因此，雖然 Wikipedia 所定義的傳統作"
"法可能可行，但可能不是最有效率的可攜性確保方式。"

#: src/portability/index.md:17
msgid ""
"How do we do this in Rust? Enter **[embedded-hal](https://crates.io/crates/"
"embedded-hal)**..."
msgstr ""
"在 Rust 中如何做到？答案是 **[embedded-hal](https://crates.io/crates/"
"embedded-hal)**…"

#: src/portability/index.md:19
msgid "What is [embedded-hal](https://crates.io/crates/embedded-hal)?"
msgstr "什麼是 [embedded-hal](https://crates.io/crates/embedded-hal)？"

#: src/portability/index.md:21
msgid ""
"In a nutshell it is a set of traits which define implementation contracts "
"between **HAL implementations**, **drivers** and **applications (or "
"firmwares)**. Those contracts include both capabilities (i.e. if a trait is "
"implemented for a certain type, the **HAL implementation** provides a "
"certain capability) and methods (i.e. if you can construct a type "
"implementing a trait it is guaranteed that you have the methods specified in "
"the trait available)."
msgstr ""
"簡而言之，它是一組 traits，用於定義 **HAL 實作**、**驅動程式** 與 **應用程式"
"（或韌體）** 之間的實作契約。這些契約同時包含能力（例如某個型別實作了某 "
"trait，表示 **HAL 實作**提供了某種能力）與方法（例如你能建立一個實作 trait 的"
"型別，就保證擁有 trait 所指定的方法）。"

#: src/portability/index.md:23
msgid "A typical layering might look like this:"
msgstr "典型的分層可能如下："

#: src/portability/index.md:25
msgid "![](../assets/rust_layers.svg)"
msgstr ""

#: src/portability/index.md:27
msgid ""
"Some of the defined traits in **[embedded-hal](https://crates.io/crates/"
"embedded-hal)** are:"
msgstr ""
"**[embedded-hal](https://crates.io/crates/embedded-hal)** 中定義的一些 trait "
"包含："

#: src/portability/index.md:28
msgid "GPIO (input and output pins)"
msgstr "GPIO（輸入與輸出腳位）"

#: src/portability/index.md:29
msgid "Serial communication"
msgstr "序列通訊"

#: src/portability/index.md:32
msgid "Timers/Countdowns"
msgstr "計時器／倒數計時"

#: src/portability/index.md:33
msgid "Analog Digital Conversion"
msgstr "類比訊號轉換"

#: src/portability/index.md:35
msgid ""
"The main reason for having the **embedded-hal** traits and crates "
"implementing and using them is to keep complexity in check. If you consider "
"that an application might have to implement the use of the peripheral in the "
"hardware as well as the application and potentially drivers for additional "
"hardware components, then it should be easy to see that the re-usability is "
"very limited. Expressed mathematically, if **M** is the number of peripheral "
"HAL implementations and **N** the number of drivers then if we were to "
"reinvent the wheel for every application then we would end up with **M\\*N** "
"implementations while by using the _API_ provided by the **[embedded-hal]"
"(https://crates.io/crates/embedded-hal)** traits will make the "
"implementation complexity approach **M+N**. Of course there're additional "
"benefits to be had, such as less trial-and-error due to a well-defined and "
"ready-to-use APIs."
msgstr ""
"擁有 **embedded-hal** traits 以及實作並使用它們的套件，主要是為了控制複雜度。"
"若一個應用程式同時要實作硬體周邊的使用、應用程式本身，以及可能的額外硬體驅"
"動，很容易看出可重用性會非常有限。用數學表示，若 **M** 是周邊 HAL 實作數量，"
"**N** 是驅動數量，若每個應用都重造輪子，最終會有 **M\\*N** 種實作；而使用 "
"**[embedded-hal](https://crates.io/crates/embedded-hal)** traits 提供的 "
"_API_，實作複雜度會趨近 **M+N**。當然還有其他好處，例如因為 API 定義清楚且可"
"直接使用，能減少試錯。"

#: src/portability/index.md:37
msgid "Users of the [embedded-hal](https://crates.io/crates/embedded-hal)"
msgstr "[embedded-hal](https://crates.io/crates/embedded-hal) 的使用者"

#: src/portability/index.md:39
msgid "As said above there are three main users of the HAL:"
msgstr "如上所述，HAL 有三種主要使用者："

#: src/portability/index.md:41
msgid "HAL implementation"
msgstr "HAL 實作"

#: src/portability/index.md:43
msgid ""
"A HAL implementation provides the interfacing between the hardware and the "
"users of the HAL traits. Typical implementations consist of three parts:"
msgstr "HAL 實作提供硬體與 HAL traits 使用者之間的介面。典型實作包含三部分："

#: src/portability/index.md:44
msgid "One or more hardware specific types"
msgstr "一或多個硬體特定型別"

#: src/portability/index.md:45
msgid ""
"Functions to create and initialize such a type, often providing various "
"configuration options (speed, operation mode, use pins, etc.)"
msgstr ""
"用來建立並初始化該型別的函式，通常提供各種設定選項（速度、操作模式、使用腳位"
"等）"

#: src/portability/index.md:46
msgid ""
"one or more `trait` `impl` of **[embedded-hal](https://crates.io/crates/"
"embedded-hal)** traits for that type"
msgstr ""
"該型別的一或多個 **[embedded-hal](https://crates.io/crates/embedded-hal)** "
"traits 的 `trait` `impl`"

#: src/portability/index.md:48
msgid "Such a **HAL implementation** can come in various flavours:"
msgstr "這樣的 **HAL 實作** 可有不同形式："

#: src/portability/index.md:49
msgid "Via low-level hardware access, e.g. via registers"
msgstr "透過低階硬體存取，例如暫存器"

#: src/portability/index.md:50
msgid "Via operating system, e.g. by using the `sysfs` under Linux"
msgstr "透過作業系統，例如在 Linux 使用 `sysfs`"

#: src/portability/index.md:51
msgid "Via adapter, e.g. a mock of types for unit testing"
msgstr "透過轉接層，例如用於單元測試的型別 mock"

#: src/portability/index.md:52
msgid "Via driver for hardware adapters, e.g. I2C multiplexer or GPIO expander"
msgstr "透過硬體轉接器的驅動程式，例如 I2C 多工器或 GPIO 擴充器"

#: src/portability/index.md:54
msgid "Driver"
msgstr "驅動程式"

#: src/portability/index.md:56
msgid ""
"A driver implements a set of custom functionality for an internal or "
"external component, connected to a peripheral implementing the [embedded-hal]"
"(https://crates.io/crates/embedded-hal) traits. Typical examples for such "
"drivers include various sensors (temperature, magnetometer, accelerometer, "
"light), display devices (LED arrays, LCD displays) and actuators (motors, "
"transmitters)."
msgstr ""
"驅動程式為內部或外部元件提供一組自訂功能，該元件連接到實作 [embedded-hal]"
"(https://crates.io/crates/embedded-hal) traits 的周邊。典型例子包括各種感測器"
"（溫度、磁力計、加速度計、光）、顯示裝置（LED 陣列、LCD 顯示器）與致動器（馬"
"達、發射器）。"

#: src/portability/index.md:58
msgid ""
"A driver has to be initialized with an instance of type that implements a "
"certain `trait` of the [embedded-hal](https://crates.io/crates/embedded-hal) "
"which is ensured via trait bound and provides its own type instance with a "
"custom set of methods allowing to interact with the driven device."
msgstr ""
"驅動程式必須以實作 [embedded-hal](https://crates.io/crates/embedded-hal) 某"
"個 `trait` 的型別實例初始化，這由 trait bound 保證，並提供其自有型別實例與自"
"訂方法集合，用來與所驅動的裝置互動。"

#: src/portability/index.md:60
msgid "Application"
msgstr "應用程式"

#: src/portability/index.md:62
msgid ""
"The application binds the various parts together and ensures that the "
"desired functionality is achieved. When porting between different systems, "
"this is the part which requires the most adaptation efforts, since the "
"application needs to correctly initialize the real hardware via the HAL "
"implementation and the initialisation of different hardware differs, "
"sometimes drastically so. Also the user choice often plays a big role, since "
"components can be physically connected to different terminals, hardware "
"buses sometimes need external hardware to match the configuration or there "
"are different trade-offs to be made in the use of internal peripherals (e.g. "
"multiple timers with different capabilities are available or peripherals "
"conflict with others)."
msgstr ""
"應用程式把各部分組合起來，確保達成所需功能。在不同系統間移植時，這部分需要最"
"多的調整努力，因為應用程式必須透過 HAL 實作正確初始化實體硬體，而不同硬體的初"
"始化方式可能差異很大。此外，使用者選擇也常扮演重要角色，因為元件可能實體連接"
"到不同端子，硬體匯流排有時需要外部硬體配合設定，或是內部周邊的使用需要不同取"
"捨（例如存在多個能力不同的計時器或周邊彼此衝突）。"

#: src/static-guarantees/index.md:1
msgid "Static Guarantees"
msgstr "靜態保證"

#: src/static-guarantees/index.md:3
msgid ""
"Rust's type system prevents data races at compile time (see [`Send`](https://"
"doc.rust-lang.org/core/marker/trait.Send.html) and [`Sync`](https://doc.rust-"
"lang.org/core/marker/trait.Sync.html) traits). The type system can also be "
"used to check other properties at compile time; reducing the need for "
"runtime checks in some cases."
msgstr ""
"Rust 的型別系統可在編譯期防止資料競爭（見 [`Send`](https://doc.rust-lang.org/"
"core/marker/trait.Send.html) 與 [`Sync`](https://doc.rust-lang.org/core/"
"marker/trait.Sync.html) traits）。型別系統也可用來在編譯期檢查其他性質，在某"
"些情況下減少執行期檢查的需求。"

#: src/static-guarantees/index.md:10
msgid ""
"When applied to embedded programs these _static checks_ can be used, for "
"example, to enforce that configuration of I/O interfaces is done properly. "
"For instance, one can design an API where it is only possible to initialize "
"a serial interface by first configuring the pins that will be used by the "
"interface."
msgstr ""
"將這些_靜態檢查_應用在嵌入式程式時，可用來強制 I/O 介面正確設定。例如，可以設"
"計一個 API，使得必須先設定將要使用的腳位，才能初始化序列介面。"

#: src/static-guarantees/index.md:15
msgid ""
"One can also statically check that operations, like setting a pin low, can "
"only be performed on correctly configured peripherals. For example, trying "
"to change the output state of a pin configured in floating input mode would "
"raise a compile error."
msgstr ""
"也可在編譯期檢查像是將腳位設為低電位等操作，是否只能對已正確設定的周邊執行。"
"例如，嘗試變更被設定為浮動輸入模式的腳位輸出狀態，會產生編譯錯誤。"

#: src/static-guarantees/index.md:20
msgid ""
"And, as seen in the previous chapter, the concept of ownership can be "
"applied to peripherals to ensure that only certain parts of a program can "
"modify a peripheral. This _access control_ makes software easier to reason "
"about compared to the alternative of treating peripherals as global mutable "
"state."
msgstr ""
"此外，如前章所示，所有權概念可應用於周邊，以確保只有程式的特定部分能修改周"
"邊。這種_存取控制_相較於把周邊視為全域可變狀態，更容易推理軟體行為。"

#: src/SUMMARY.md:37
msgid "Design Contracts"
msgstr "設計契約"

#: src/static-guarantees/design-contracts.md:3
msgid ""
"In our last chapter, we wrote an interface that _didn't_ enforce design "
"contracts. Let's take another look at our imaginary GPIO configuration "
"register:"
msgstr ""

#: src/static-guarantees/design-contracts.md:5
msgid "Bit Number(s)"
msgstr ""

#: src/static-guarantees/design-contracts.md:5
msgid "Value"
msgstr ""

#: src/static-guarantees/design-contracts.md:5
msgid "Meaning"
msgstr ""

#: src/static-guarantees/design-contracts.md:5
msgid "Notes"
msgstr ""

#: src/static-guarantees/design-contracts.md:7
msgid "enable"
msgstr ""

#: src/static-guarantees/design-contracts.md:7
#: src/static-guarantees/design-contracts.md:9
#: src/static-guarantees/design-contracts.md:15
msgid "0"
msgstr ""

#: src/static-guarantees/design-contracts.md:7
msgid "disabled"
msgstr ""

#: src/static-guarantees/design-contracts.md:7
msgid "Disables the GPIO"
msgstr "停用 GPIO"

#: src/static-guarantees/design-contracts.md:8
#: src/static-guarantees/design-contracts.md:9
#: src/static-guarantees/design-contracts.md:10
#: src/static-guarantees/design-contracts.md:16
msgid "1"
msgstr ""

#: src/static-guarantees/design-contracts.md:8
msgid "enabled"
msgstr ""

#: src/static-guarantees/design-contracts.md:8
msgid "Enables the GPIO"
msgstr "啟用 GPIO"

#: src/static-guarantees/design-contracts.md:9
msgid "direction"
msgstr ""

#: src/static-guarantees/design-contracts.md:9
msgid "input"
msgstr ""

#: src/static-guarantees/design-contracts.md:9
msgid "Sets the direction to Input"
msgstr "設定輸入的方向"

#: src/static-guarantees/design-contracts.md:10
msgid "output"
msgstr ""

#: src/static-guarantees/design-contracts.md:10
msgid "Sets the direction to Output"
msgstr "設定輸出的方向"

#: src/static-guarantees/design-contracts.md:11
msgid "input_mode"
msgstr ""

#: src/static-guarantees/design-contracts.md:11
msgid "2..3"
msgstr ""

#: src/static-guarantees/design-contracts.md:11
msgid "00"
msgstr ""

#: src/static-guarantees/design-contracts.md:11
msgid "hi-z"
msgstr ""

#: src/static-guarantees/design-contracts.md:11
msgid "Sets the input as high resistance"
msgstr ""

#: src/static-guarantees/design-contracts.md:12
msgid "01"
msgstr ""

#: src/static-guarantees/design-contracts.md:12
msgid "pull-low"
msgstr ""

#: src/static-guarantees/design-contracts.md:12
msgid "Input pin is pulled low"
msgstr ""

#: src/static-guarantees/design-contracts.md:13
msgid "10"
msgstr ""

#: src/static-guarantees/design-contracts.md:13
msgid "pull-high"
msgstr ""

#: src/static-guarantees/design-contracts.md:13
msgid "Input pin is pulled high"
msgstr ""

#: src/static-guarantees/design-contracts.md:14
msgid "11"
msgstr ""

#: src/static-guarantees/design-contracts.md:14
msgid "n/a"
msgstr ""

#: src/static-guarantees/design-contracts.md:14
msgid "Invalid state. Do not set"
msgstr ""

#: src/static-guarantees/design-contracts.md:15
msgid "output_mode"
msgstr ""

#: src/static-guarantees/design-contracts.md:15
msgid "4"
msgstr ""

#: src/static-guarantees/design-contracts.md:15
msgid "set-low"
msgstr ""

#: src/static-guarantees/design-contracts.md:15
msgid "Output pin is driven low"
msgstr ""

#: src/static-guarantees/design-contracts.md:16
msgid "set-high"
msgstr ""

#: src/static-guarantees/design-contracts.md:16
msgid "Output pin is driven high"
msgstr ""

#: src/static-guarantees/design-contracts.md:17
msgid "input_status"
msgstr ""

#: src/static-guarantees/design-contracts.md:17
msgid "5"
msgstr ""

#: src/static-guarantees/design-contracts.md:17
msgid "x"
msgstr ""

#: src/static-guarantees/design-contracts.md:17
msgid "in-val"
msgstr ""

#: src/static-guarantees/design-contracts.md:17
msgid "0 if input is \\< 1.5v, 1 if input >= 1.5v"
msgstr ""

#: src/static-guarantees/design-contracts.md:19
msgid ""
"If we instead checked the state before making use of the underlying "
"hardware, enforcing our design contracts at runtime, we might write code "
"that looks like this instead:"
msgstr ""

#: src/static-guarantees/design-contracts.md:22
#: src/static-guarantees/design-contracts.md:107
msgid "/// GPIO interface\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:24
#: src/static-guarantees/design-contracts.md:109
msgid "/// GPIO Configuration structure generated by svd2rust\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:37
msgid "// Must be enabled to set direction\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:50
msgid "// Must be enabled to set input mode\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:55
#: src/static-guarantees/design-contracts.md:91
msgid "// Direction must be input\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:68
msgid "// Must be enabled to set output status\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:73
msgid "// Direction must be output\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:86
msgid "// Must be enabled to get status\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:100
msgid ""
"Because we need to enforce the restrictions on the hardware, we end up doing "
"a lot of runtime checking which wastes time and resources, and this code "
"will be much less pleasant for the developer to use."
msgstr ""

#: src/static-guarantees/design-contracts.md:102
msgid "Type States"
msgstr ""

#: src/static-guarantees/design-contracts.md:104
msgid ""
"But what if instead, we used Rust's type system to enforce the state "
"transition rules? Take this example:"
msgstr ""

#: src/static-guarantees/design-contracts.md:115
msgid "// Type states for MODE in GpioConfig\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:125
msgid "/// These functions may be used on any GPIO Pin\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:166
msgid "/// This function may be used on an Output Pin\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:173
msgid "/// These methods may be used on any enabled input GPIO\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:212
msgid "Now let's see what the code using this would look like:"
msgstr ""

#: src/static-guarantees/design-contracts.md:215
msgid ""
"/*\n"
" * Example 1: Unconfigured to High-Z input\n"
" */"
msgstr ""

#: src/static-guarantees/design-contracts.md:219
msgid ""
"// Can't do this, pin isn't enabled!\n"
"// pin.into_input_pull_down();\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:222
msgid "// Now turn the pin from unconfigured to a high-z input\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:225
msgid "// Read from the pin\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:228
msgid ""
"// Can't do this, input pins don't have this interface!\n"
"// input_pin.set_bit(true);\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:231
msgid ""
"/*\n"
" * Example 2: High-Z input to Pulled Low input\n"
" */"
msgstr ""

#: src/static-guarantees/design-contracts.md:237
msgid ""
"/*\n"
" * Example 3: Pulled Low input to Output, set high\n"
" */"
msgstr ""

#: src/static-guarantees/design-contracts.md:243
msgid ""
"// Can't do this, output pins don't have this interface!\n"
"// output_pin.into_input_pull_down();\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:248
msgid ""
"This is definitely a convenient way to store the state of the pin, but why "
"do it this way? Why is this better than storing the state as an `enum` "
"inside of our `GpioConfig` structure?"
msgstr ""

#: src/static-guarantees/design-contracts.md:250
msgid "Compile Time Functional Safety"
msgstr ""

#: src/static-guarantees/design-contracts.md:252
msgid ""
"Because we are enforcing our design constraints entirely at compile time, "
"this incurs no runtime cost. It is impossible to set an output mode when you "
"have a pin in an input mode. Instead, you must walk through the states by "
"converting it to an output pin, and then setting the output mode. Because of "
"this, there is no runtime penalty due to checking the current state before "
"executing a function."
msgstr ""

#: src/static-guarantees/design-contracts.md:254
msgid ""
"Also, because these states are enforced by the type system, there is no "
"longer room for errors by consumers of this interface. If they try to "
"perform an illegal state transition, the code will not compile!"
msgstr ""

#: src/SUMMARY.md:36
msgid "Peripherals as State Machines"
msgstr "將周邊視為狀態機"

#: src/static-guarantees/state-machines.md:3
msgid ""
"The peripherals of a microcontroller can be thought of as set of state "
"machines. For example, the configuration of a simplified [GPIO pin](https://"
"en.wikipedia.org/wiki/General-purpose_input/output) could be represented as "
"the following tree of states:"
msgstr ""

#: src/static-guarantees/state-machines.md:7
#: src/static-guarantees/state-machines.md:19
msgid "Disabled"
msgstr ""

#: src/static-guarantees/state-machines.md:8
#: src/static-guarantees/state-machines.md:20
msgid "Enabled"
msgstr ""

#: src/static-guarantees/state-machines.md:9
#: src/static-guarantees/state-machines.md:33
msgid "Configured as Output"
msgstr ""

#: src/static-guarantees/state-machines.md:10
#: src/static-guarantees/state-machines.md:34
msgid "Output: High"
msgstr ""

#: src/static-guarantees/state-machines.md:11
msgid "Output: Low"
msgstr ""

#: src/static-guarantees/state-machines.md:12
#: src/static-guarantees/state-machines.md:21
#: src/static-guarantees/state-machines.md:32
msgid "Configured as Input"
msgstr ""

#: src/static-guarantees/state-machines.md:13
#: src/static-guarantees/state-machines.md:22
#: src/static-guarantees/state-machines.md:26
msgid "Input: High Resistance"
msgstr ""

#: src/static-guarantees/state-machines.md:14
#: src/static-guarantees/state-machines.md:27
#: src/static-guarantees/state-machines.md:31
msgid "Input: Pulled Low"
msgstr ""

#: src/static-guarantees/state-machines.md:15
msgid "Input: Pulled High"
msgstr ""

#: src/static-guarantees/state-machines.md:17
msgid ""
"If the peripheral starts in the `Disabled` mode, to move to the `Input: High "
"Resistance` mode, we must perform the following steps:"
msgstr ""

#: src/static-guarantees/state-machines.md:24
msgid ""
"If we wanted to move from `Input: High Resistance` to `Input: Pulled Low`, "
"we must perform the following steps:"
msgstr ""

#: src/static-guarantees/state-machines.md:29
msgid ""
"Similarly, if we want to move a GPIO pin from configured as `Input: Pulled "
"Low` to `Output: High`, we must perform the following steps:"
msgstr ""

#: src/static-guarantees/state-machines.md:36
msgid "Hardware Representation"
msgstr ""

#: src/static-guarantees/state-machines.md:38
msgid ""
"Typically the states listed above are set by writing values to given "
"registers mapped to a GPIO peripheral. Let's define an imaginary GPIO "
"Configuration Register to illustrate this:"
msgstr ""

#: src/static-guarantees/state-machines.md:54
msgid "We _could_ expose the following structure in Rust to control this GPIO:"
msgstr ""

#: src/static-guarantees/state-machines.md:94
msgid ""
"However, this would allow us to modify certain registers that do not make "
"sense. For example, what happens if we set the `output_mode` field when our "
"GPIO is configured as an input?"
msgstr ""

#: src/static-guarantees/state-machines.md:96
msgid ""
"In general, use of this structure would allow us to reach states not defined "
"by our state machine above: e.g. an output that is pulled low, or an input "
"that is set high. For some hardware, this may not matter. On other hardware, "
"it could cause unexpected or undefined behavior!"
msgstr ""

#: src/static-guarantees/state-machines.md:98
msgid ""
"Although this interface is convenient to write, it doesn't enforce the "
"design contracts set out by our hardware implementation."
msgstr ""

#: src/SUMMARY.md:35
msgid "Typestate Programming"
msgstr "型別狀態程式設計"

#: src/static-guarantees/typestate-programming.md:3
msgid ""
"The concept of [typestates](https://en.wikipedia.org/wiki/"
"Typestate_analysis) describes the encoding of information about the current "
"state of an object into the type of that object. Although this can sound a "
"little arcane, if you have used the [Builder Pattern](https://doc.rust-lang."
"org/1.0.0/style/ownership/builders.html) in Rust, you have already started "
"using Typestate Programming!"
msgstr ""

#: src/static-guarantees/typestate-programming.md:52
msgid ""
"In this example, there is no direct way to create a `Foo` object. We must "
"create a `FooBuilder`, and properly initialize it before we can obtain the "
"`Foo` object we want."
msgstr ""

#: src/static-guarantees/typestate-programming.md:54
msgid "This minimal example encodes two states:"
msgstr ""

#: src/static-guarantees/typestate-programming.md:56
msgid ""
"`FooBuilder`, which represents an \"unconfigured\", or \"configuration in "
"process\" state"
msgstr ""

#: src/static-guarantees/typestate-programming.md:57
msgid "`Foo`, which represents a \"configured\", or \"ready to use\" state."
msgstr ""

#: src/static-guarantees/typestate-programming.md:59
msgid "Strong Types"
msgstr "強型別"

#: src/static-guarantees/typestate-programming.md:61
msgid ""
"Because Rust has a [Strong Type System](https://en.wikipedia.org/wiki/"
"Strong_and_weak_typing), there is no easy way to magically create an "
"instance of `Foo`, or to turn a `FooBuilder` into a `Foo` without calling "
"the `into_foo()` method. Additionally, calling the `into_foo()` method "
"consumes the original `FooBuilder` structure, meaning it can not be reused "
"without the creation of a new instance."
msgstr ""

#: src/static-guarantees/typestate-programming.md:65
msgid ""
"This allows us to represent the states of our system as types, and to "
"include the necessary actions for state transitions into the methods that "
"exchange one type for another. By creating a `FooBuilder`, and exchanging it "
"for a `Foo` object, we have walked through the steps of a basic state "
"machine."
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:1
msgid "Zero Cost Abstractions"
msgstr "零成本抽象"

#: src/static-guarantees/zero-cost-abstractions.md:3
msgid ""
"Type states are also an excellent example of Zero Cost Abstractions - the "
"ability to move certain behaviors to compile time execution or analysis. "
"These type states contain no actual data, and are instead used as markers. "
"Since they contain no data, they have no actual representation in memory at "
"runtime:"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:8
#: src/static-guarantees/zero-cost-abstractions.md:9
#: src/static-guarantees/zero-cost-abstractions.md:10
#: src/static-guarantees/zero-cost-abstractions.md:11
msgid "// == 0\n"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:14
msgid "Zero Sized Types"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:20
msgid ""
"Structures defined like this are called Zero Sized Types, as they contain no "
"actual data. Although these types act \"real\" at compile time - you can "
"copy them, move them, take references to them, etc., however the optimizer "
"will completely strip them away."
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:22
msgid "In this snippet of code:"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:36
msgid ""
"The GpioConfig we return never exists at runtime. Calling this function will "
"generally boil down to a single assembly instruction - storing a constant "
"register value to a register location. This means that the type state "
"interface we've developed is a zero cost abstraction - it uses no more CPU, "
"RAM, or code space tracking the state of `GpioConfig`, and renders to the "
"same machine code as a direct register access."
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:38
msgid "Nesting"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:40
msgid ""
"In general, these abstractions may be nested as deeply as you would like. As "
"long as all components used are zero sized types, the whole structure will "
"not exist at runtime."
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:42
msgid ""
"For complex or deeply nested structures, it may be tedious to define all "
"possible combinations of state. In these cases, macros may be used to "
"generate all implementations."
msgstr ""

#: src/SUMMARY.md:14
msgid "`no_std`"
msgstr ""

#: src/SUMMARY.md:16
msgid "Installation"
msgstr "安裝"

#: src/SUMMARY.md:18
msgid "MacOS"
msgstr ""

#: src/SUMMARY.md:21
msgid "Getting started"
msgstr "開始上手"

#: src/SUMMARY.md:24
msgid "Memory-mapped Registers"
msgstr "記憶體對映暫存器"

#: src/SUMMARY.md:31
msgid "A first attempt in Rust"
msgstr "Rust 的首次嘗試"

#: src/SUMMARY.md:43
msgid "HALs"
msgstr ""

#: src/SUMMARY.md:44
msgid "Checklist"
msgstr "檢查清單"

#: src/SUMMARY.md:48
msgid "GPIO"
msgstr ""

#: src/SUMMARY.md:49
msgid "Tips for embedded C developers"
msgstr "給嵌入式 C 開發者的提示"

#: src/SUMMARY.md:54
msgid "Unsorted topics"
msgstr "未分類主題"

#: src/SUMMARY.md:55
msgid "Optimizations: The speed size tradeoff"
msgstr "最佳化：速度與大小的取捨"

#: src/SUMMARY.md:56
msgid "Performing Math Functionality"
msgstr "數學運算功能"

#: src/c-tips/index.md:3
msgid ""
"This chapter collects a variety of tips that might be useful to experienced "
"embedded C developers looking to start writing Rust. It will especially "
"highlight how things you might already be used to in C are different in Rust."
msgstr ""
"本章收錄各種可能對有經驗的嵌入式 C 開發者有用的提示，以便開始撰寫 Rust。其中"
"會特別強調你在 C 中習以為常的事，在 Rust 中有何不同。"

#: src/c-tips/index.md:7
msgid "Preprocessor"
msgstr "預處理器"

#: src/c-tips/index.md:9
msgid ""
"In embedded C it is very common to use the preprocessor for a variety of "
"purposes, such as:"
msgstr "在嵌入式 C 中，預處理器常被用於各種用途，例如："

#: src/c-tips/index.md:12
msgid "Compile-time selection of code blocks with `#ifdef`"
msgstr "使用 `#ifdef` 於編譯期選擇程式碼區塊"

#: src/c-tips/index.md:13
msgid "Compile-time array sizes and computations"
msgstr "編譯期的陣列大小與計算"

#: src/c-tips/index.md:14
msgid "Macros to simplify common patterns (to avoid function call overhead)"
msgstr "用巨集簡化常見模式（避免函式呼叫開銷）"

#: src/c-tips/index.md:16
msgid ""
"In Rust there is no preprocessor, and so many of these use cases are "
"addressed differently. In the rest of this section we cover various "
"alternatives to using the preprocessor."
msgstr ""
"Rust 沒有預處理器，因此這些用例多半以不同方式處理。在本節其餘部分，我們會介紹"
"多種預處理器的替代方案。"

#: src/c-tips/index.md:20
msgid "Compile-Time Code Selection"
msgstr "編譯期程式碼選擇"

#: src/c-tips/index.md:22
msgid ""
"The closest match to `#ifdef ... #endif` in Rust are [Cargo features]"
"(https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-"
"section). These are a little more formal than the C preprocessor: all "
"possible features are explicitly listed per crate, and can only be either on "
"or off. Features are turned on when you list a crate as a dependency, and "
"are additive: if any crate in your dependency tree enables a feature for "
"another crate, that feature will be enabled for all users of that crate."
msgstr ""
"在 Rust 中，最接近 `#ifdef ... #endif` 的是 [Cargo features](https://doc."
"rust-lang.org/cargo/reference/manifest.html#the-features-section)。它們比 C "
"預處理器更正式：每個 crate 會明確列出所有可能的 feature，且只能是開或關。當你"
"把某個 crate 列為相依時會啟用 feature，而且 feature 是可累加的：若相依樹中任"
"何 crate 為另一個 crate 啟用 feature，該 crate 的所有使用者都會啟用該 "
"feature。"

#: src/c-tips/index.md:31
msgid ""
"For example, you might have a crate which provides a library of signal "
"processing primitives. Each one might take some extra time to compile or "
"declare some large table of constants which you'd like to avoid. You could "
"declare a Cargo feature for each component in your `Cargo.toml`:"
msgstr ""
"例如，你可能有個 crate 提供訊號處理基礎元件。每個元件可能需要額外編譯時間或宣"
"告大型常數表，而你希望避免。你可以在 `Cargo.toml` 為每個元件宣告一個 Cargo "
"feature："

#: src/c-tips/index.md:42
msgid ""
"Then, in your code, use `#[cfg(feature=\"FIR\")]` to control what is "
"included."
msgstr "然後在程式碼中使用 `#[cfg(feature=\"FIR\")]` 來控制要包含哪些內容。"

#: src/c-tips/index.md:45
msgid "/// In your top-level lib.rs\n"
msgstr "/// 在你的頂層 lib.rs 中\n"

#: src/c-tips/index.md:47
msgid "\"FIR\""
msgstr ""

#: src/c-tips/index.md:50
msgid "\"IIR\""
msgstr ""

#: src/c-tips/index.md:54
msgid ""
"You can similarly include code blocks only if a feature is _not_ enabled, or "
"if any combination of features are or are not enabled."
msgstr ""
"你也可以在 feature _未_啟用時包含程式碼區塊，或在某些 feature 組合啟用或未啟"
"用時包含程式碼。"

#: src/c-tips/index.md:57
msgid ""
"Additionally, Rust provides a number of automatically-set conditions you can "
"use, such as `target_arch` to select different code based on architecture. "
"For full details of the conditional compilation support, refer to the "
"[conditional compilation](https://doc.rust-lang.org/reference/conditional-"
"compilation.html) chapter of the Rust reference."
msgstr ""
"此外，Rust 提供多種自動設定的條件可用，例如 `target_arch` 可依架構選擇不同程"
"式碼。關於條件式編譯支援的完整細節，請參考 Rust 參考文件中的[條件式編譯]"
"(https://doc.rust-lang.org/reference/conditional-compilation.html) 章節。"

#: src/c-tips/index.md:64
msgid ""
"The conditional compilation will only apply to the next statement or block. "
"If a block can not be used in the current scope then the `cfg` attribute "
"will need to be used multiple times.  It's worth noting that most of the "
"time it is better to simply include all the code and allow the compiler to "
"remove dead code when optimising: it's simpler for you and your users, and "
"in general the compiler will do a good job of removing unused code."
msgstr ""
"條件式編譯只會套用到下一個敘述或區塊。若某個區塊在目前作用域無法使用，就需要"
"多次使用 `cfg` 屬性。值得注意的是，多數情況下更好的作法是直接包含所有程式碼，"
"讓編譯器在最佳化時移除死碼：對你與使用者都更簡單，且通常編譯器能很好地移除未"
"使用的程式碼。"

#: src/c-tips/index.md:71
msgid "Compile-Time Sizes and Computation"
msgstr "編譯期大小與計算"

#: src/c-tips/index.md:73
msgid ""
"Rust supports `const fn`, functions which are guaranteed to be evaluable at "
"compile-time and can therefore be used where constants are required, such as "
"in the size of arrays. This can be used alongside features mentioned above, "
"for example:"
msgstr ""
"Rust 支援 `const fn`，其函式可保證在編譯期求值，因此可用於需要常數的地方，例"
"如陣列大小。它可與上述 feature 一起使用，例如："

#: src/c-tips/index.md:80 src/c-tips/index.md:82
msgid "\"use_more_ram\""
msgstr ""

#: src/c-tips/index.md:89
msgid ""
"These are new to stable Rust as of 1.31, so documentation is still sparse. "
"The functionality available to `const fn` is also very limited at the time "
"of writing; in future Rust releases it is expected to expand on what is "
"permitted in a `const fn`."
msgstr ""
"這些功能自 Rust 1.31 起才進入穩定版，因此文件仍較少。撰寫本書時，`const fn` "
"可用的功能也相當有限；未來 Rust 版本預期會擴充 `const fn` 允許的內容。"

#: src/c-tips/index.md:94
msgid "Macros"
msgstr "巨集"

#: src/c-tips/index.md:96
msgid ""
"Rust provides an extremely powerful [macro system](https://doc.rust-lang.org/"
"book/ch19-06-macros.html). While the C preprocessor operates almost directly "
"on the text of your source code, the Rust macro system operates at a higher "
"level. There are two varieties of Rust macro: _macros by example_ and "
"_procedural macros_. The former are simpler and most common; they look like "
"function calls and can expand to a complete expression, statement, item, or "
"pattern. Procedural macros are more complex but permit extremely powerful "
"additions to the Rust language: they can transform arbitrary Rust syntax "
"into new Rust syntax."
msgstr ""
"Rust 提供非常強大的[巨集系統](https://doc.rust-lang.org/book/ch19-06-macros."
"html)。C 的預處理器幾乎直接操作原始碼文字，而 Rust 巨集系統在更高層級運作。"
"Rust 的巨集有兩種：_巨集範例（macros by example）_ 與 _程序式巨集"
"（procedural macros）_。前者較簡單且最常見，看起來像函式呼叫，能展開成完整的"
"表達式、敘述、項目或樣式。程序式巨集更複雜，但可對 Rust 語言進行極其強大的擴"
"展：它們可將任意 Rust語法轉換成新的 Rust 語法。"

#: src/c-tips/index.md:107
msgid ""
"In general, where you might have used a C preprocessor macro, you probably "
"want to see if a macro-by-example can do the job instead. They can be "
"defined in your crate and easily used by your own crate or exported for "
"other users. Be aware that since they must expand to complete expressions, "
"statements, items, or patterns, some use cases of C preprocessor macros will "
"not work, for example a macro that expands to part of a variable name or an "
"incomplete set of items in a list."
msgstr ""
"一般而言，若你原本會用 C 預處理器巨集，應先看看巨集範例是否能完成任務。它們可"
"在你的 crate 中定義，並輕鬆供自己的 crate 使用或匯出給其他使用者。請注意，因"
"為它們必須展開成完整的表達式、敘述、項目或樣式，所以某些 C 預處理器巨集的用法"
"無法使用，例如展開成變數名稱的一部分，或清單中不完整的一組項目。"

#: src/c-tips/index.md:115
msgid ""
"As with Cargo features, it is worth considering if you even need the macro. "
"In many cases a regular function is easier to understand and will be inlined "
"to the same code as a macro. The `#[inline]` and `#[inline(always)]` "
"[attributes](https://doc.rust-lang.org/reference/attributes.html#inline-"
"attribute) give you further control over this process, although care should "
"be taken here as well — the compiler will automatically inline functions "
"from the same crate where appropriate, so forcing it to do so "
"inappropriately might actually lead to decreased performance."
msgstr ""
"和 Cargo features 一樣，也值得考慮是否真的需要巨集。許多情況下，一般函式更容"
"易理解，且會被內聯成與巨集相同的程式碼。`#[inline]` 與 `#[inline(always)]` "
"[屬性](https://doc.rust-lang.org/reference/attributes.html#inline-attribute) "
"可提供更多控制，但也需小心——編譯器會在適當時自動內聯同一 crate 的函式，若強制"
"內聯不恰當，反而可能降低效能。"

#: src/c-tips/index.md:125
msgid ""
"Explaining the entire Rust macro system is out of scope for this tips page, "
"so you are encouraged to consult the Rust documentation for full details."
msgstr ""
"完整說明 Rust 巨集系統超出本提示頁的範圍，建議參考 Rust 文件以了解完整細節。"

#: src/c-tips/index.md:128
msgid "Build System"
msgstr "建置系統"

#: src/c-tips/index.md:130
msgid ""
"Most Rust crates are built using Cargo (although it is not required). This "
"takes care of many difficult problems with traditional build systems. "
"However, you may wish to customise the build process. Cargo provides [`build."
"rs` scripts](https://doc.rust-lang.org/cargo/reference/build-scripts.html) "
"for this purpose. They are Rust scripts which can interact with the Cargo "
"build system as required."
msgstr ""
"多數 Rust crate 以 Cargo 建置（雖非必須）。這解決了傳統建置系統的許多難題。不"
"過，你可能希望自訂建置流程。Cargo 提供 [`build.rs` 腳本](https://doc.rust-"
"lang.org/cargo/reference/build-scripts.html) 來達成此目的。這些是可依需求與 "
"Cargo 建置系統互動的 Rust 腳本。"

#: src/c-tips/index.md:138
msgid "Common use cases for build scripts include:"
msgstr "建置腳本的常見用途包括："

#: src/c-tips/index.md:140
msgid ""
"provide build-time information, for example statically embedding the build "
"date or Git commit hash into your executable"
msgstr "提供建置時資訊，例如將建置日期或 Git 提交雜湊值靜態嵌入可執行檔"

#: src/c-tips/index.md:142
msgid ""
"generate linker scripts at build time depending on selected features or "
"other logic"
msgstr "依選擇的 feature 或其他邏輯在建置時產生連結器腳本"

#: src/c-tips/index.md:144
msgid "change the Cargo build configuration"
msgstr "變更 Cargo 建置設定"

#: src/c-tips/index.md:145
msgid "add extra static libraries to link against"
msgstr "加入額外要連結的靜態函式庫"

#: src/c-tips/index.md:147
msgid ""
"At present there is no support for post-build scripts, which you might "
"traditionally have used for tasks like automatic generation of binaries from "
"the build objects or printing build information."
msgstr ""
"目前沒有後置建置腳本的支援，而你可能曾用它來自動從建置物件產生二進位檔或輸出"
"建置資訊。"

#: src/c-tips/index.md:151
msgid "Cross-Compiling"
msgstr "交叉編譯"

#: src/c-tips/index.md:153
msgid ""
"Using Cargo for your build system also simplifies cross-compiling. In most "
"cases it suffices to tell Cargo `--target thumbv6m-none-eabi` and find a "
"suitable executable in `target/thumbv6m-none-eabi/debug/myapp`."
msgstr ""
"使用 Cargo 作為建置系統也能簡化交叉編譯。多數情況下只需告訴 Cargo `--target "
"thumbv6m-none-eabi`，並在 `target/thumbv6m-none-eabi/debug/myapp` 找到合適的"
"可執行檔。"

#: src/c-tips/index.md:157
msgid ""
"For platforms not natively supported by Rust, you will need to build "
"`libcore` for that target yourself. On such platforms, [Xargo](https://"
"github.com/japaric/xargo) can be used as a stand-in for Cargo which "
"automatically builds `libcore` for you."
msgstr ""
"對於 Rust 尚未原生支援的平台，你需要自行為該目標建置 `libcore`。在這類平台"
"上，可使用 [Xargo](https://github.com/japaric/xargo) 作為 Cargo 的替代，為你"
"自動建置 `libcore`。"

#: src/c-tips/index.md:163
msgid "Iterators vs Array Access"
msgstr "疊代器與陣列存取"

#: src/c-tips/index.md:165
msgid "In C you are probably used to accessing arrays directly by their index:"
msgstr "在 C 中，你可能習慣以索引直接存取陣列："

#: src/c-tips/index.md:175
msgid ""
"In Rust this is an anti-pattern: indexed access can be slower (as it needs "
"to be bounds checked) and may prevent various compiler optimisations. This "
"is an important distinction and worth repeating: Rust will check for out-of-"
"bounds access on manual array indexing to guarantee memory safety, while C "
"will happily index outside the array."
msgstr ""
"在 Rust 中這是反模式：索引存取可能較慢（因為需要邊界檢查），也可能阻礙各種編"
"譯器最佳化。這點很重要，值得重申：Rust 會對手動索引陣列進行越界檢查以保證記憶"
"體安全，而 C 則會愉快地索引到陣列之外。"

#: src/c-tips/index.md:181
msgid "Instead, use iterators:"
msgstr "改用疊代器："

#: src/c-tips/index.md:190
msgid ""
"Iterators provide a powerful array of functionality you would have to "
"implement manually in C, such as chaining, zipping, enumerating, finding the "
"min or max, summing, and more. Iterator methods can also be chained, giving "
"very readable data processing code."
msgstr ""
"疊代器提供了你在 C 中必須手動實作的一系列強大功能，例如串接、拉鍊化、枚舉、找"
"最小/最大值、加總等。疊代器方法也可串接，讓資料處理程式碼非常易讀。"

#: src/c-tips/index.md:195
msgid ""
"See the [Iterators in the Book](https://doc.rust-lang.org/book/ch13-02-"
"iterators.html) and [Iterator documentation](https://doc.rust-lang.org/core/"
"iter/trait.Iterator.html) for more details."
msgstr ""
"更多細節請參考[手冊中的疊代器](https://doc.rust-lang.org/book/ch13-02-"
"iterators.html)與[Iterator 文件](https://doc.rust-lang.org/core/iter/trait."
"Iterator.html)。"

#: src/c-tips/index.md:200
msgid "References vs Pointers"
msgstr "參考與指標"

#: src/c-tips/index.md:202
msgid ""
"In Rust, pointers (called [_raw pointers_](https://doc.rust-lang.org/book/"
"ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer)) exist but are only "
"used in specific circumstances, as dereferencing them is always considered "
"`unsafe` -- Rust cannot provide its usual guarantees about what might be "
"behind the pointer."
msgstr ""
"在 Rust 中確實有指標（稱為[_裸指標_](https://doc.rust-lang.org/book/ch19-01-"
"unsafe-rust.html#dereferencing-a-raw-pointer)），但只在特定情況下使用，因為解"
"參考它們一律被視為 `unsafe`——Rust 無法對指標背後的內容提供一貫的保證。"

#: src/c-tips/index.md:208
msgid ""
"In most cases, we instead use _references_, indicated by the `&` symbol, or "
"_mutable references_, indicated by `&mut`. References behave similarly to "
"pointers, in that they can be dereferenced to access the underlying values, "
"but they are a key part of Rust's ownership system: Rust will strictly "
"enforce that you may only have one mutable reference _or_ multiple non-"
"mutable references to the same value at any given time."
msgstr ""
"在多數情況下，我們會改用_參考_（以 `&` 表示），或_可變參考_（以 `&mut` 表"
"示）。參考的行為類似指標，可解參考以存取底層值，但它們是 Rust 所有權系統的關"
"鍵：Rust 嚴格保證在任何時刻對同一個值只能有一個可變參考，_或_ 多個不可變參"
"考。"

#: src/c-tips/index.md:215
msgid ""
"In practice this means you have to be more careful about whether you need "
"mutable access to data: where in C the default is mutable and you must be "
"explicit about `const`, in Rust the opposite is true."
msgstr ""
"實務上這代表你必須更謹慎考慮是否真的需要對資料進行可變存取：在 C 中預設可變且"
"需明確標示 `const`，在 Rust 中則相反。"

#: src/c-tips/index.md:219
msgid ""
"One situation where you might still use raw pointers is interacting directly "
"with hardware (for example, writing a pointer to a buffer into a DMA "
"peripheral register), and they are also used under the hood for all "
"peripheral access crates to allow you to read and write memory-mapped "
"registers."
msgstr ""
"仍可能使用裸指標的情況之一是直接與硬體互動（例如將緩衝區指標寫入 DMA 周邊暫存"
"器）。它們也被所有周邊存取套件在底層使用，以允許讀寫記憶體對映暫存器。"

#: src/c-tips/index.md:224
msgid "Volatile Access"
msgstr "易變存取"

#: src/c-tips/index.md:226
msgid ""
"In C, individual variables may be marked `volatile`, indicating to the "
"compiler that the value in the variable may change between accesses. "
"Volatile variables are commonly used in an embedded context for memory-"
"mapped registers."
msgstr ""
"在 C 中，單一變數可標記為 `volatile`，告訴編譯器該變數的值可能在存取之間改"
"變。易變變數在嵌入式情境中常用於記憶體對映暫存器。"

#: src/c-tips/index.md:230
msgid ""
"In Rust, instead of marking a variable as `volatile`, we use specific "
"methods to perform volatile access: [`core::ptr::read_volatile`](https://doc."
"rust-lang.org/core/ptr/fn.read_volatile.html) and [`core::ptr::"
"write_volatile`](https://doc.rust-lang.org/core/ptr/fn.write_volatile.html). "
"These methods take a `*const T` or a `*mut T` (_raw pointers_, as discussed "
"above) and perform a volatile read or write."
msgstr ""
"在 Rust 中，不是將變數標記為 `volatile`，而是使用特定方法進行易變存取："
"[`core::ptr::read_volatile`](https://doc.rust-lang.org/core/ptr/fn."
"read_volatile.html) 與[`core::ptr::write_volatile`](https://doc.rust-lang."
"org/core/ptr/fn.write_volatile.html)。這些方法接受 `*const T` 或 `*mut T`（如"
"上所述的_裸指標_），並執行易變讀寫。"

#: src/c-tips/index.md:238
msgid "For example, in C you might write:"
msgstr "例如，在 C 中你可能會寫："

#: src/c-tips/index.md:244
msgid "// Signal that the interrupt has occurred\n"
msgstr "// 表示中斷已發生\n"

#: src/c-tips/index.md:250 src/c-tips/index.md:275
msgid "// Sleep until signalled\n"
msgstr "// 睡眠直到收到訊號\n"

#: src/c-tips/index.md:252 src/c-tips/index.md:277
msgid "// Reset signalled indicator\n"
msgstr "// 重設已通知的指示\n"

#: src/c-tips/index.md:254 src/c-tips/index.md:279
msgid "// Perform some task that was waiting for the interrupt\n"
msgstr "// 執行先前等待中斷的任務\n"

#: src/c-tips/index.md:260
msgid "The equivalent in Rust would use volatile methods on each access:"
msgstr "在 Rust 中等效作法是在每次存取時使用易變方法："

#: src/c-tips/index.md:267
msgid ""
"// Signal that the interrupt has occurred\n"
"    // (In real code, you should consider a higher level primitive,\n"
"    //  such as an atomic type).\n"
msgstr ""
"// 表示中斷已發生\n"
"    //（在實際程式碼中，你應考慮更高階的原語，\n"
"    //  例如原子型別）。\n"

#: src/c-tips/index.md:285
msgid "A few things are worth noting in the code sample:"
msgstr "程式碼範例中有幾點值得注意："

#: src/c-tips/index.md:286
msgid ""
"We can pass `&mut SIGNALLED` into the function requiring `*mut T`, since "
"`&mut T` automatically converts to a `*mut T` (and the same for `*const T`)"
msgstr ""
"我們可以將 `&mut SIGNALLED` 傳給需要 `*mut T` 的函式，因為 `&mut T` 會自動轉"
"換為 `*mut T`（`*const T` 亦同）"

#: src/c-tips/index.md:288
msgid ""
"We need `unsafe` blocks for the `read_volatile`/`write_volatile` methods, "
"since they are `unsafe` functions. It is the programmer's responsibility to "
"ensure safe use: see the methods' documentation for further details."
msgstr ""
"由於 `read_volatile`/`write_volatile` 是 `unsafe` 函式，我們需要使用 "
"`unsafe` 區塊。確保安全使用是程式設計者的責任：詳情請參考這些方法的文件。"

#: src/c-tips/index.md:292
msgid ""
"It is rare to require these functions directly in your code, as they will "
"usually be taken care of for you by higher-level libraries. For memory "
"mapped peripherals, the peripheral access crates will implement volatile "
"access automatically, while for concurrency primitives there are better "
"abstractions available (see the [Concurrency chapter](../concurrency/index."
"md))."
msgstr ""
"通常不需要在程式中直接呼叫這些函式，因為高階函式庫會替你處理。對記憶體對映周"
"邊而言，周邊存取套件會自動實作易變存取；對並行原語則有更好的抽象可用（參見[並"
"行章節](../concurrency/index.md)）。"

#: src/c-tips/index.md:300
msgid "Packed and Aligned Types"
msgstr "打包與對齊型別"

#: src/c-tips/index.md:302
msgid ""
"In embedded C it is common to tell the compiler a variable must have a "
"certain alignment or a struct must be packed rather than aligned, usually to "
"meet specific hardware or protocol requirements."
msgstr ""
"在嵌入式 C 中，常見做法是告訴編譯器某變數必須有特定位元組對齊，或某個結構體必"
"須打包而非對齊，通常是為了滿足特定硬體或通訊協定需求。"

#: src/c-tips/index.md:306
msgid ""
"In Rust this is controlled by the `repr` attribute on a struct or union. The "
"default representation provides no guarantees of layout, so should not be "
"used for code that interoperates with hardware or C. The compiler may re-"
"order struct members or insert padding and the behaviour may change with "
"future versions of Rust."
msgstr ""
"在 Rust 中，這由結構體或聯合體上的 `repr` 屬性控制。預設表現形式不保證版面配"
"置，因此不應用於與硬體或 C 互通的程式碼。編譯器可能會重新排序結構體成員或插入"
"填充，且行為可能在未來 Rust 版本中改變。"

#: src/c-tips/index.md:321 src/c-tips/index.md:340 src/c-tips/index.md:366
#: src/c-tips/index.md:390 src/c-tips/index.md:391
msgid "\"{:p} {:p} {:p}\""
msgstr ""

#: src/c-tips/index.md:323
msgid ""
"// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2\n"
"// Note ordering has been changed to x, z, y to improve packing.\n"
msgstr ""
"// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2\n"
"// 注意為了改善打包，順序已改為 x、z、y。\n"

#: src/c-tips/index.md:328
msgid "To ensure layouts that are interoperable with C, use `repr(C)`:"
msgstr "為了確保與 C 互通的版面配置，使用 `repr(C)`："

#: src/c-tips/index.md:342
msgid ""
"// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64\n"
"// Ordering is preserved and the layout will not change over time.\n"
"// `z` is two-byte aligned so a byte of padding exists between `y` and `z`.\n"
msgstr ""
"// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64\n"
"// 順序保持不變，且版面配置不會隨時間改變。\n"
"// `z` 需 2 位元組對齊，因此 `y` 與 `z` 之間存在 1 位元組填充。\n"

#: src/c-tips/index.md:348
msgid "To ensure a packed representation, use `repr(packed)`:"
msgstr "若要確保打包表示，使用 `repr(packed)`："

#: src/c-tips/index.md:360
msgid ""
"// References must always be aligned, so to check the addresses of the\n"
"    // struct's fields, we use `std::ptr::addr_of!()` to get a raw pointer\n"
"    // instead of just printing `&v.x`.\n"
msgstr ""
"// 參考必須永遠對齊，因此要檢查結構體欄位位址時，\n"
"    // 我們使用 `std::ptr::addr_of!()` 取得裸指標，\n"
"    // 而不是直接列印 `&v.x`。\n"

#: src/c-tips/index.md:368
msgid ""
"// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493\n"
"// No padding has been inserted between `y` and `z`, so now `z` is "
"unaligned.\n"
msgstr ""
"// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493\n"
"// `y` 與 `z` 之間未插入填充，因此 `z` 現在未對齊。\n"

#: src/c-tips/index.md:373
msgid ""
"Note that using `repr(packed)` also sets the alignment of the type to `1`."
msgstr "注意，使用 `repr(packed)` 也會把型別對齊設為 `1`。"

#: src/c-tips/index.md:375
msgid ""
"Finally, to specify a specific alignment, use `repr(align(n))`, where `n` is "
"the number of bytes to align to (and must be a power of two):"
msgstr ""
"最後，若要指定特定對齊方式，使用 `repr(align(n))`，其中 `n` 是對齊到的位元組"
"數（且必須為 2 的冪）："

#: src/c-tips/index.md:393
msgid ""
"// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004\n"
"// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004\n"
"// The two instances `u` and `v` have been placed on 4096-byte alignments,\n"
"// evidenced by the `000` at the end of their addresses.\n"
msgstr ""
"// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004\n"
"// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004\n"
"// 兩個實例 `u` 與 `v` 被放在 4096 位元組對齊的位置，\n"
"// 從位址末尾的 `000` 可看出。\n"

#: src/c-tips/index.md:400
msgid ""
"Note we can combine `repr(C)` with `repr(align(n))` to obtain an aligned and "
"C-compatible layout. It is not permissible to combine `repr(align(n))` with "
"`repr(packed)`, since `repr(packed)` sets the alignment to `1`. It is also "
"not permissible for a `repr(packed)` type to contain a `repr(align(n))` type."
msgstr ""
"注意，我們可將 `repr(C)` 與 `repr(align(n))` 結合以取得對齊且相容 C 的配置。"
"不得將 `repr(align(n))` 與 `repr(packed)` 結合，因為 `repr(packed)` 會把對齊"
"設為 `1`。`repr(packed)` 型別也不得包含 `repr(align(n))` 型別。"

#: src/c-tips/index.md:405
msgid ""
"For further details on type layouts, refer to the [type layout](https://doc."
"rust-lang.org/reference/type-layout.html) chapter of the Rust Reference."
msgstr ""
"關於型別配置的更多細節，請參考 Rust 參考文件的 [type layout](https://doc."
"rust-lang.org/reference/type-layout.html) 章節。"

#: src/c-tips/index.md:412
msgid "In this book:"
msgstr "本書中的資源："

#: src/c-tips/index.md:413
msgid "[A little C with your Rust](../interoperability/c-with-rust.md)"
msgstr "[在 Rust 中用點 C](../interoperability/c-with-rust.md)"

#: src/c-tips/index.md:414
msgid "[A little Rust with your C](../interoperability/rust-with-c.md)"
msgstr "[在 C 中用點 Rust](../interoperability/rust-with-c.md)"

#: src/c-tips/index.md:415
msgid "[The Rust Embedded FAQs](https://docs.rust-embedded.org/faq.html)"
msgstr "[Rust Embedded 常見問題](https://docs.rust-embedded.org/faq.html)"

#: src/c-tips/index.md:416
msgid "[Rust Pointers for C Programmers](http://blahg.josefsipek.net/?p=580)"
msgstr "[給 C 程式設計者的 Rust 指標](http://blahg.josefsipek.net/?p=580)"

#: src/c-tips/index.md:417
msgid ""
"[I used to use pointers - now what?](https://github.com/diwic/reffers-rs/"
"blob/master/docs/Pointers.md)"
msgstr ""
"[我以前用指標—現在呢？](https://github.com/diwic/reffers-rs/blob/master/docs/"
"Pointers.md)"

#: src/unsorted/speed-vs-size.md:1
msgid "Optimizations: the speed size tradeoff"
msgstr ""

#: src/unsorted/speed-vs-size.md:3
msgid ""
"Everyone wants their program to be super fast and super small but it's "
"usually not possible to have both characteristics. This section discusses "
"the different optimization levels that `rustc` provides and how they affect "
"the execution time and binary size of a program."
msgstr ""

#: src/unsorted/speed-vs-size.md:8
msgid "No optimizations"
msgstr ""

#: src/unsorted/speed-vs-size.md:10
msgid ""
"This is the default. When you call `cargo build` you use the development "
"(AKA `dev`) profile. This profile is optimized for debugging so it enables "
"debug information and does _not_ enable any optimizations, i.e. it uses `-C "
"opt-level = 0`."
msgstr ""

#: src/unsorted/speed-vs-size.md:15
msgid ""
"At least for bare metal development, debuginfo is zero cost in the sense "
"that it won't occupy space in Flash / ROM so we actually recommend that you "
"enable debuginfo in the release profile -- it is disabled by default. That "
"will let you use breakpoints when debugging release builds."
msgstr ""

#: src/unsorted/speed-vs-size.md:26
msgid ""
"No optimizations is great for debugging because stepping through the code "
"feels like you are executing the program statement by statement, plus you "
"can `print` stack variables and function arguments in GDB. When the code is "
"optimized, trying to print variables results in `$0 = <value optimized out>` "
"being printed."
msgstr ""

#: src/unsorted/speed-vs-size.md:31
msgid ""
"The biggest downside of the `dev` profile is that the resulting binary will "
"be huge and slow. The size is usually more of a problem because unoptimized "
"binaries can occupy dozens of KiB of Flash, which your target device may not "
"have -- the result: your unoptimized binary doesn't fit in your device!"
msgstr ""

#: src/unsorted/speed-vs-size.md:36
msgid "Can we have smaller, debugger friendly binaries? Yes, there's a trick."
msgstr ""

#: src/unsorted/speed-vs-size.md:38
msgid "Optimizing dependencies"
msgstr ""

#: src/unsorted/speed-vs-size.md:40
msgid ""
"There's a Cargo feature named [`profile-overrides`](https://doc.rust-lang."
"org/cargo/reference/profiles.html#overrides) that lets you override the "
"optimization level of dependencies. You can use that feature to optimize all "
"dependencies for size while keeping the top crate unoptimized and debugger "
"friendly."
msgstr ""

#: src/unsorted/speed-vs-size.md:45
msgid ""
"Beware that generic code can sometimes be optimized alongside the crate "
"where it is instantiated, rather than the crate where it is defined. If you "
"create an instance of a generic struct in your application and find that it "
"pulls in code with a large footprint, it may be that increasing the "
"optimisation level of the relevant dependencies has no effect."
msgstr ""

#: src/unsorted/speed-vs-size.md:53
msgid "Here's an example:"
msgstr ""

#: src/unsorted/speed-vs-size.md:55
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[package]\n"
"name = \"app\"\n"
"# ..\n"
"\n"
"[profile.dev.package.\"*\"] # +\n"
"opt-level = \"z\" # +\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:65
msgid "Without the override:"
msgstr ""

#: src/unsorted/speed-vs-size.md:78
msgid "With the override:"
msgstr ""

#: src/unsorted/speed-vs-size.md:91
msgid ""
"That's a 6 KiB reduction in Flash usage without any loss in the "
"debuggability of the top crate. If you step into a dependency then you'll "
"start seeing those `<value optimized out>` messages again but it's usually "
"the case that you want to debug the top crate and not the dependencies. And "
"if you _do_ need to debug a dependency then you can use the `profile-"
"overrides` feature to exclude a particular dependency from being optimized. "
"See example below:"
msgstr ""

#: src/unsorted/speed-vs-size.md:98
msgid ""
"```toml\n"
"# ..\n"
"\n"
"# don't optimize the `cortex-m-rt` crate\n"
"[profile.dev.package.cortex-m-rt] # +\n"
"opt-level = 0 # +\n"
"\n"
"# but do optimize all the other dependencies\n"
"[profile.dev.package.\"*\"]\n"
"codegen-units = 1 # better optimizations\n"
"opt-level = \"z\"\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:111
msgid "Now the top crate and `cortex-m-rt` are debugger friendly!"
msgstr ""

#: src/unsorted/speed-vs-size.md:113
msgid "Optimize for speed"
msgstr ""

#: src/unsorted/speed-vs-size.md:115
msgid ""
"As of 2018-09-18 `rustc` supports three \"optimize for speed\" levels: `opt-"
"level = 1`, `2` and `3`. When you run `cargo build --release` you are using "
"the release profile which defaults to `opt-level = 3`."
msgstr ""

#: src/unsorted/speed-vs-size.md:119
msgid ""
"Both `opt-level = 2` and `3` optimize for speed at the expense of binary "
"size, but level `3` does more vectorization and inlining than level `2`. In "
"particular, you'll see that at `opt-level` equal to or greater than `2` LLVM "
"will unroll loops. Loop unrolling has a rather high cost in terms of Flash / "
"ROM (e.g. from 26 bytes to 194 for a zero this array loop) but can also "
"halve the execution time given the right conditions (e.g. number of "
"iterations is big enough)."
msgstr ""

#: src/unsorted/speed-vs-size.md:127
msgid ""
"Currently there's no way to disable loop unrolling in `opt-level = 2` and "
"`3` so if you can't afford its cost you should optimize your program for "
"size."
msgstr ""

#: src/unsorted/speed-vs-size.md:130
msgid "Optimize for size"
msgstr ""

#: src/unsorted/speed-vs-size.md:132
msgid ""
"As of 2018-09-18 `rustc` supports two \"optimize for size\" levels: `opt-"
"level = \"s\"` and `\"z\"`. These names were inherited from clang / LLVM and "
"are not too descriptive but `\"z\"` is meant to give the idea that it "
"produces smaller binaries than `\"s\"`."
msgstr ""

#: src/unsorted/speed-vs-size.md:137
msgid ""
"If you want your release binaries to be optimized for size then change the "
"`profile.release.opt-level` setting in `Cargo.toml` as shown below."
msgstr ""

#: src/unsorted/speed-vs-size.md:140
msgid ""
"```toml\n"
"[profile.release]\n"
"# or \"z\"\n"
"opt-level = \"s\"\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:146
msgid ""
"These two optimization levels greatly reduce LLVM's inline threshold, a "
"metric used to decide whether to inline a function or not. One of Rust "
"principles are zero cost abstractions; these abstractions tend to use a lot "
"of newtypes and small functions to hold invariants (e.g. functions that "
"borrow an inner value like `deref`, `as_ref`) so a low inline threshold can "
"make LLVM miss optimization opportunities (e.g. eliminate dead branches, "
"inline calls to closures)."
msgstr ""

#: src/unsorted/speed-vs-size.md:154
msgid ""
"When optimizing for size you may want to try increasing the inline threshold "
"to see if that has any effect on the binary size. The recommended way to "
"change the inline threshold is to append the `-C inline-threshold` flag to "
"the other rustflags in `.cargo/config.toml`."
msgstr ""

#: src/unsorted/speed-vs-size.md:159
msgid ""
"```toml\n"
"# .cargo/config.toml\n"
"# this assumes that you are using the cortex-m-quickstart template\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"rustflags = [\n"
"  # ..\n"
"  \"-C\", \"inline-threshold=123\", # +\n"
"]\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:169
msgid ""
"What value to use? [As of 1.29.0 these are the inline thresholds that the "
"different optimization levels use](https://github.com/rust-lang/rust/"
"blob/1.29.0/src/librustc_codegen_llvm/back/write.rs#L2105-L2122):"
msgstr ""

#: src/unsorted/speed-vs-size.md:174
msgid "`opt-level = 3` uses 275"
msgstr ""

#: src/unsorted/speed-vs-size.md:175
msgid "`opt-level = 2` uses 225"
msgstr ""

#: src/unsorted/speed-vs-size.md:176
msgid "`opt-level = \"s\"` uses 75"
msgstr ""

#: src/unsorted/speed-vs-size.md:177
msgid "`opt-level = \"z\"` uses 25"
msgstr ""

#: src/unsorted/speed-vs-size.md:179
msgid "You should try `225` and `275` when optimizing for size."
msgstr ""

#: src/unsorted/math.md:1
msgid "Performing math functionality with `#[no_std]`"
msgstr ""

#: src/unsorted/math.md:3
msgid ""
"If you want to perform math related functionality like calculating the "
"squareroot or the exponential of a number and you have the full standard "
"library available, your code might look like this:"
msgstr ""

#: src/unsorted/math.md:8
msgid "//! Some mathematical functions with standard support available\n"
msgstr ""

#: src/unsorted/math.md:19 src/unsorted/math.md:53
msgid "\"Floored test float {} to {}\""
msgstr ""

#: src/unsorted/math.md:20 src/unsorted/math.md:54
msgid "\"The square root of {} is {}\""
msgstr ""

#: src/unsorted/math.md:21 src/unsorted/math.md:55
msgid "\"The sinus of four is {}\""
msgstr ""

#: src/unsorted/math.md:23 src/unsorted/math.md:57
msgid "\"The exponential of four to the base e is {}\""
msgstr ""

#: src/unsorted/math.md:29
msgid ""
"Without standard library support, these functions are not available. An "
"external crate like [`libm`](https://crates.io/crates/libm) can be used "
"instead. The example code would then look like this:"
msgstr ""

#: src/unsorted/math.md:69
msgid ""
"If you need to perform more complex operations like DSP signal processing or "
"advanced linear algebra on your MCU, the following crates might help you"
msgstr ""

#: src/unsorted/math.md:72
msgid ""
"[CMSIS DSP library binding](https://github.com/jacobrosenthal/cmsis-dsp-sys)"
msgstr ""

#: src/unsorted/math.md:73
msgid "[`constgebra`](https://crates.io/crates/constgebra)"
msgstr "[`constgebra`](https://crates.io/crates/constgebra)"

#: src/unsorted/math.md:74
msgid "[`micromath`](https://github.com/tarcieri/micromath)"
msgstr "[`micromath`](https://github.com/tarcieri/micromath)"

#: src/unsorted/math.md:75
msgid "[`microfft`](https://crates.io/crates/microfft)"
msgstr "[`microfft`](https://crates.io/crates/microfft)"

#: src/unsorted/math.md:76
msgid "[`nalgebra`](https://github.com/dimforge/nalgebra)"
msgstr "[`nalgebra`](https://github.com/dimforge/nalgebra)"
